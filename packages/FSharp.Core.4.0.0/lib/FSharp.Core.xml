<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Core</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.BuildSettings.Version">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Tail">
 <summary>Gets the tail of the list, which is a list containing all the elements of the list, excluding the first element </summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Length">
 <summary>Gets the number of items contained in the list</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Item(System.Int32)">
 <summary>Gets the element of the list at the given position.</summary>
 <remarks>Lists are represented as linked lists so this is an O(n) operation.</remarks>
 <param name="index">The index.</param>
 <returns>The value at the given index.</returns>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.IsEmpty">
 <summary>Gets a value indicating if the list contains no entries</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Head">
 <summary>Gets the first element of the list</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Empty">
 <summary>Returns an empty list of a particular type</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpList`1.Cons(`0,Microsoft.FSharp.Collections.FSharpList{`0})">
 <summary>Returns a list with <c>head</c> as its first element and <c>tail</c> as its subsequent elements</summary>
 <param name="head">A new head value for the list.</param>
 <param name="tail">The existing list.</param>
 <returns>The list with head appended to the front of tail.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpList`1">
 <summary>The type of immutable singly-linked lists.</summary>

 <remarks>Use the constructors <c>[]</c> and <c>::</c> (infix) to create values of this type, or
 the notation <c>[1;2;3]</c>. Use the values in the <c>List</c> module to manipulate 
 values of this type, or pattern match against the values directly.</remarks>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Item(`0)">
 <summary>Lookup an element in the map. Raise <c>KeyNotFoundException</c> if no binding
 exists in the map.</summary>
 <param name="key">The input key.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown when the key is not found.</exception>
 <returns>The value mapped to the key.</returns>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.IsEmpty">
 <summary>Returns true if there are no bindings in the map.</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Count">
 <summary>The number of bindings in the map.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.TryFind(`0)">
 <summary>Lookup an element in the map, returning a <c>Some</c> value if the element is in the domain 
 of the map and <c>None</c> if not.</summary>
 <param name="key">The input key.</param>
 <returns>The mapped value, or None if the key is not in the map.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Remove(`0)">
 <summary>Removes an element from the domain of the map. No exception is raised if the element is not present.</summary>
 <param name="key">The input key.</param>
 <returns>The resulting map.</returns>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.ContainsKey(`0)">
 <summary>Tests if an element is in the domain of the map.</summary>
 <param name="key">The input key.</param>
 <returns>True if the map contains the given key.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Add(`0,`1)">
 <summary>Returns a new map with the binding added to the given map.</summary>
 <param name="key">The input key.</param>
 <returns>The resulting map.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple`2{`0,`1}})">
 <summary>Builds a map that contains the bindings of the given IEnumerable.</summary>
 <param name="elements">The input sequence of key/value pairs.</param>
 <returns>The resulting map.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpMap`2">
 <summary>Immutable maps. Keys are ordered by F# generic comparison.</summary>
 
 <remarks>Maps based on generic comparison are efficient for small keys. They are not a suitable choice if keys are recursive data structures 
 or if keys require bespoke comparison semantics.

 All members of this class are thread-safe and may be used concurrently from multiple threads.</remarks>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray`1">
 <summary>An abbreviation for the CLI type <c>System.Collections.Generic.List&lt;_&gt;</c></summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.op_Subtraction(Microsoft.FSharp.Collections.FSharpSet{`0},Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Returns a new set with the elements of the second set removed from the first.</summary>
 <param name="set1">The first input set.</param>
 <param name="set2">The second input set.</param>
 <returns>A set containing elements of the first set that are not contained in the second set.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.op_Addition(Microsoft.FSharp.Collections.FSharpSet{`0},Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Compute the union of the two sets.</summary>
 <param name="set1">The first input set.</param>
 <param name="set2">The second input set.</param>
 <returns>The union of the two input sets.</returns>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.MinimumElement">
 <summary>Returns the lowest element in the set according to the ordering being used for the set.</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.MaximumElement">
 <summary>Returns the highest element in the set according to the ordering being used for the set.</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.IsEmpty">
 <summary>A useful shortcut for Set.isEmpty. See the Set module for further operations on sets.</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.Count">
 <summary>The number of elements in the set</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Remove(`0)">
 <summary>A useful shortcut for Set.remove. Note this operation produces a new set
 and does not mutate the original set. The new set will share many storage
 nodes with the original. See the Set module for further operations on sets.</summary>
 <param name="value">The value to remove from the set.</param>
 <returns>The result set.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsSupersetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first.</summary>
 <param name="otherSet">The set to test against.</param>
 <returns>True if this set is a superset of <c>otherSet</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsSubsetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second.</summary>
 <param name="otherSet">The set to test against.</param>
 <returns>True if this set is a subset of <c>otherSet</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsProperSupersetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first, and at least 
 one element of the first is not in the second.</summary>
 <param name="otherSet">The set to test against.</param>
 <returns>True if this set is a proper superset of <c>otherSet</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsProperSubsetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second, and at least 
 one element of the second is not in the first.</summary>
 <param name="otherSet">The set to test against.</param>
 <returns>True if this set is a proper subset of <c>otherSet</c>.</returns>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Contains(`0)">
 <summary>A useful shortcut for Set.contains. See the Set module for further operations on sets.</summary>
 <param name="value">The value to check.</param>
 <returns>True if the set contains <c>value</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Add(`0)">
 <summary>A useful shortcut for Set.add. Note this operation produces a new set
 and does not mutate the original set. The new set will share many storage
 nodes with the original. See the Set module for further operations on sets.</summary>
 <param name="value">The value to add to the set.</param>
 <returns>The result set.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
 <summary>Create a set containing elements drawn from the given sequence.</summary>
 <param name="elements">The input sequence.</param>
 <returns>The result set.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpSet`1">
 <summary>Immutable sets based on binary trees, where comparison is the
 F# structural comparison function, potentially using implementations
 of the IComparable interface on key values.</summary>

 <remarks>See the Set module for further operations on sets.

 All members of this class are thread-safe and may be used concurrently from multiple threads.</remarks>
</member>
<member name="T:Microsoft.FSharp.Collections.list`1">
 <summary>An abbreviation for the type of immutable singly-linked lists. </summary>

 <remarks>Use the constructors <c>[]</c> and <c>::</c> (infix) to create values of this type, or
 the notation <c>[1;2;3]</c>. Use the values in the <c>List</c> module to manipulate 
 values of this type, or pattern match against the values directly.</remarks>
</member>
<member name="T:Microsoft.FSharp.Collections.seq`1">
 <summary>An abbreviation for the CLI type <c>System.Collections.Generic.IEnumerable&lt;_&gt;</c></summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Get``1(``0[0:,0:],System.Int32,System.Int32)">
 <summary>Fetches an element from a 2D array. You can also use the syntax <c>array.[index1,index2]</c>.</summary>

 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>

 <returns>The value of the array at the given index.</returns>
 <exception cref="System.ArgumentException">Thrown when the indices are negative or exceed the bounds of the array.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Set``1(``0[0:,0:],System.Int32,System.Int32,``0)">
 <summary>Sets the value of an element in an array. You can also use the syntax <c>array.[index1,index2] &lt;- value</c>.</summary>

 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="value">The value to set in the array.</param>
 <exception cref="System.ArgumentException">Thrown when the indices are negative or exceed the bounds of the array.</exception> 
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Rebase``1(``0[0:,0:])">
 <summary>Builds a new array whose elements are the same as the input array but
 where a non-zero-based input array generates a corresponding zero-based 
 output array.</summary>

 <param name="array">The input array.</param>

 <returns>The zero-based output array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}}},``0[0:,0:])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propagated to the output
 array.</remarks>

 <param name="mapping">A function that is applied to transform each element of the array.  The two integers
 provide the index of the element.</param>
 <param name="array">The input array.</param>

 <returns>An array whose elements have been transformed by the given mapping.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[0:,0:])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propogated to the output
 array.</remarks>

 <param name="mapping">A function that is applied to transform each item of the input array.</param>
 <param name="array">The input array.</param>

 <returns>An array whose elements have been transformed by the given mapping.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Length2``1(``0[0:,0:])">
 <summary>Returns the length of an array in the second dimension.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the second dimension.</returns>  
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Length1``1(``0[0:,0:])">
 <summary>Returns the length of an array in the first dimension.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the first dimension.</returns>  
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}}},``0[0:,0:])">
 <summary>Applies the given function to each element of the array.  The integer indices passed to the
 function indicates the index of element.</summary>

 <param name="action">A function to apply to each element of the array with the indices available as an argument.</param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[0:,0:])">
 <summary>Applies the given function to each element of the array.</summary>

 <param name="action">A function to apply to each element of the array.</param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.ZeroCreateBased``1(System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Creates a based array where the entries are initially Unchecked.defaultof&lt;'T&gt;.</summary>

 <param name="base1">The base for the first dimension of the array.</param>
 <param name="base2">The base for the second dimension of the array.</param>
 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>

 <returns>The created array.</returns>
 <exception cref="System.ArgumentException">Thrown when base1, base2, length1, or length2 is negative.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.CreateBased``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
 <summary>Creates a based array whose elements are all initially the given value.</summary>

 <param name="base1">The base for the first dimension of the array.</param>
 <param name="base2">The base for the second dimension of the array.</param>
 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>
 <param name="initial">The value to populate the new array.</param>

 <returns>The created array.</returns>
 <exception cref="System.ArgumentException">Thrown when base1, base2, length1, or length2 is negative.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.InitializeBased``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}})">
 <summary>Creates a based array given the dimensions and a generator function to compute the elements.</summary>

 <param name="base1">The base for the first dimension of the array.</param>
 <param name="base2">The base for the second dimension of the array.</param>
 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>
 <param name="initializer">A function to produce elements of the array given the two indices.</param>

 <returns>The created array.</returns>
 <exception cref="System.ArgumentException">Thrown when base1, base2, length1, or length2 is negative.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.ZeroCreate``1(System.Int32,System.Int32)">
 <summary>Creates an array where the entries are initially Unchecked.defaultof&lt;'T&gt;.</summary>

 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>

 <returns>The created array.</returns>
 <exception cref="System.ArgumentException">Thrown when length1 or length2 is negative.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Create``1(System.Int32,System.Int32,``0)">
 <summary>Creates an array whose elements are all initially the given value.</summary>

 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>
 <param name="value">The value to populate the new array.</param>

 <returns>The created array.</returns>
 <exception cref="System.ArgumentException">Thrown when length1 or length2 is negative.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Initialize``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}})">
 <summary>Creates an array given the dimensions and a generator function to compute the elements.</summary>

 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>
 <param name="initializer">A function to produce elements of the array given the two indices.</param>

 <returns>The generated array.</returns>
 <exception cref="System.ArgumentException">Thrown when either of the lengths is negative.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.CopyTo``1(``0[0:,0:],System.Int32,System.Int32,``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Reads a range of elements from the first array and write them into the second.</summary>

 <param name="source">The source array.</param>
 <param name="sourceIndex1">The first-dimension index to begin copying from in the source array.</param>
 <param name="sourceIndex2">The second-dimension index to begin copying from in the source array.</param>
 <param name="target">The target array.</param>
 <param name="targetIndex1">The first-dimension index to begin copying into in the target array.</param>
 <param name="targetIndex2">The second-dimension index to begin copying into in the target array.</param>
 <param name="length1">The number of elements to copy across the first dimension of the arrays.</param>
 <param name="length2">The number of elements to copy across the second dimension of the arrays.</param>
 <exception cref="System.ArgumentException">Thrown when any of the indices are negative or if either of
 the counts are larger than the dimensions of the array allow.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Copy``1(``0[0:,0:])">
 <summary>Builds a new array whose elements are the same as the input array.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propogated to the output
 array.</remarks>

 <param name="array">The input array.</param>

 <returns>A copy of the input array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Base2``1(``0[0:,0:])">
 <summary>Fetches the base-index for the second dimension of the array.</summary>

 <param name="array">The input array.</param>

 <returns>The base-index of the second dimension of the array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Base1``1(``0[0:,0:])">
 <summary>Fetches the base-index for the first dimension of the array.</summary>

 <param name="array">The input array.</param>

 <returns>The base-index of the first dimension of the array.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.Array2DModule">
 <summary>Basic operations on 2-dimensional arrays.</summary>

 <remarks>F# and CLI multi-dimensional arrays are typically zero-based. 
 However, CLI multi-dimensional arrays used in conjunction with external
 libraries (e.g. libraries associated with Visual Basic) be 
 non-zero based, using a potentially different base for each dimension.
 The operations in this module will accept such arrays, and
 the basing on an input array will be propagated to a matching output
 array on the <c>Array2D.map</c> and <c>Array2D.mapi</c> operations.
 Non-zero-based arrays can also be created using <c>Array2D.zeroCreateBased</c>, 
 <c>Array2D.createBased</c> and <c>Array2D.initBased</c>.</remarks>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.ZeroCreate``1(System.Int32,System.Int32,System.Int32)">
 <summary>Creates an array where the entries are initially the "default" value.</summary>
 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <returns>The created array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Set``1(``0[0:,0:,0:],System.Int32,System.Int32,System.Int32,``0)">
 <summary>Sets the value of an element in an array. You can also 
 use the syntax 'array.[index1,index2,index3] &lt;- value'.</summary>
 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="index3">The index along the third dimension.</param>
 <param name="value">The value to set at the given index.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}}}},``0[0:,0:,0:])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propogated to the output
 array.</remarks>
 <param name="mapping">The function to transform the elements at each index in the array.</param>
 <param name="array">The input array.</param>
 <returns>The array created from the transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[0:,0:,0:])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propogated to the output
 array.</remarks>
 <param name="mapping">The function to transform each element of the array.</param>
 <param name="array">The input array.</param>
 <returns>The array created from the transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length3``1(``0[0:,0:,0:])">
 <summary>Returns the length of an array in the third dimension.</summary>
 <param name="array">The input array.</param>
 <returns>The length of the array in the third dimension.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length2``1(``0[0:,0:,0:])">
 <summary>Returns the length of an array in the second dimension.</summary>
 <param name="array">The input array.</param>
 <returns>The length of the array in the second dimension.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length1``1(``0[0:,0:,0:])">
 <summary>Returns the length of an array in the first dimension  </summary>
 <param name="array">The input array.</param>
 <returns>The length of the array in the first dimension.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}}}},``0[0:,0:,0:])">
 <summary>Applies the given function to each element of the array. The integer indicies passed to the
 function indicates the index of element.</summary>
 <param name="action">The function to apply to each element of the array.</param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[0:,0:,0:])">
 <summary>Applies the given function to each element of the array.</summary>
 <param name="action">The function to apply to each element of the array.</param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Get``1(``0[0:,0:,0:],System.Int32,System.Int32,System.Int32)">
 <summary>Fetches an element from a 3D array. You can also use the syntax 'array.[index1,index2,index3]'</summary>
 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="index3">The index along the third dimension.</param>
 <returns>The value at the given index.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Initialize``1(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}}})">
 <summary>Creates an array given the dimensions and a generator function to compute the elements.</summary>
 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="initializer">The function to create an initial value at each index into the array.</param>
 <returns>The created array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Create``1(System.Int32,System.Int32,System.Int32,``0)">
 <summary>Creates an array whose elements are all initially the given value.</summary>
 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="initial">The value of the array elements.</param>
 <returns>The created array.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.Array3DModule">
 <summary>Basic operations on rank 3 arrays.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Set``1(``0[0:,0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,``0)">
 <summary>Sets the value of an element in an array. You can also 
 use the syntax 'array.[index1,index2,index3,index4] &lt;- value'.</summary>
 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="index3">The index along the third dimension.</param>
 <param name="index4">The index along the fourth dimension.</param>
 <param name="value">The value to set.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Get``1(``0[0:,0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Fetches an element from a 4D array. You can also use the syntax 'array.[index1,index2,index3,index4]'</summary>
 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="index3">The index along the third dimension.</param>
 <param name="index4">The index along the fourth dimension.</param>
 <returns>The value at the given index.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.ZeroCreate``1(System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Creates an array where the entries are initially the "default" value.</summary>
 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="length4">The length of the fourth dimension.</param>
 <returns>The created array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length4``1(``0[0:,0:,0:,0:])">
 <summary>Returns the length of an array in the fourth dimension.</summary>
 <param name="array">The input array.</param>
 <returns>The length of the array in the fourth dimension.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length3``1(``0[0:,0:,0:,0:])">
 <summary>Returns the length of an array in the third dimension.</summary>
 <param name="array">The input array.</param>
 <returns>The length of the array in the third dimension.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length2``1(``0[0:,0:,0:,0:])">
 <summary>Returns the length of an array in the second dimension.</summary>
 <param name="array">The input array.</param>
 <returns>The length of the array in the second dimension.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length1``1(``0[0:,0:,0:,0:])">
 <summary>Returns the length of an array in the first dimension  </summary>
 <param name="array">The input array.</param>
 <returns>The length of the array in the first dimension.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Initialize``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}}}})">
 <summary>Creates an array given the dimensions and a generator function to compute the elements.</summary>
 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="length4">The length of the fourth dimension.</param>
 <param name="initializer">The function to create an initial value at each index in the array.</param>
 <returns>The created array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Create``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
 <summary>Creates an array whose elements are all initially the given value</summary>
 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="length4">The length of the fourth dimension.</param>
 <param name="initial">The initial value for each element of the array.</param>
 <returns>The created array.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.Array4DModule">
 <summary>Basic operations on rank 4 arrays. </summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Zip3``3(``0[],``1[],``2[])">
 <summary>Combines three arrays into an array of pairs. The three arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <param name="array3">The third input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <returns>The array of tupled elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Zip``2(``0[],``1[])">
 <summary>Combines the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <returns>The array of tupled elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Unzip3``3(System.Tuple`3{``0,``1,``2}[])">
 <summary>Splits an array of triples into three arrays.</summary>
 <param name="array">The input array.</param>
 <returns>The tuple of three arrays.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Unzip``2(System.Tuple`2{``0,``1}[])">
 <summary>Splits an array of pairs into two arrays.</summary>
 <param name="array">The input array.</param>
 <returns>The two arrays.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[])">
 <summary>Returns the index of the first element in the array
 that satisfies the given predicate.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <returns>The index of the first element that satisfies the predicate, or None.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[])">
 <summary>Returns the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <returns>The first element that satisfies the predicate, or None.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ToSeq``1(``0[])">
 <summary>Views the given array as a sequence.</summary>
 <param name="array">The input array.</param>
 <returns>The sequence of array elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ToList``1(``0[])">
 <summary>Builds a list from the given array.</summary>
 <param name="array">The input array.</param>
 <returns>The list of array elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[])">
 <summary>Returns the sum of the results generated by applying the function to each element of the array.</summary>
 <param name="projection">The function to transform the array elements into the type to be summed.</param>
 <param name="array">The input array.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Sum``1(``0[])">
 <summary>Returns the sum of the elements in the array.</summary>
 <param name="array">The input array.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlace``1(``0[])">
 <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function. 
 Elements are compared using Operators.compare.</summary>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceWith``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},``0[])">
 <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function as the order.</summary>
 <param name="comparer">The function to compare pairs of array elements.</param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[])">
 <summary>Sorts the elements of an array by mutating the array in-place, using the given projection for the keys. 
 Elements are compared using Operators.compare.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="projection">The function to transform array elements into the type that is compared.</param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},``0[])">
 <summary>Sorts the elements of an array, using the given comparison function as the order, returning a new array.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="comparer">The function to compare pairs of array elements.</param>
 <param name="array">The input array.</param>
 <returns>The sorted array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[])">
 <summary>Sorts the elements of an array, using the given projection for the keys and returning a new array. 
 Elements are compared using Operators.compare.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="projection">The function to transform array elements into the type that is compared.</param>
 <param name="array">The input array.</param>
 <returns>The sorted array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Sort``1(``0[])">
 <summary>Sorts the elements of an array, returning a new array. Elements are compared using Operators.compare. </summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="array">The input array.</param>
 <returns>The sorted array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.GetSubArray``1(``0[],System.Int32,System.Int32)">
 <summary>Builds a new array that contains the given subrange specified by
 starting index and length.</summary>
 <param name="array">The input array.</param>
 <param name="startIndex">The index of the first element of the sub array.</param>
 <param name="count">The length of the sub array.</param>
 <returns>The created sub array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Set``1(``0[],System.Int32,``0)">
 <summary>Sets an element of an array.</summary>
 <param name="array">The input array.</param>
 <param name="index">The input index.</param>
 <param name="value">The input value.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},``0[],``1)">
 <summary>Like <c>foldBack</c>, but return both the intermediary and final results.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="array">The input array.</param>
 <param name="state">The initial state.</param>
 <returns>The array of state values.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,``0[])">
 <summary>Like <c>fold</c>, but return the intermediary and final results.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="array">The input array.</param>
 <returns>The array of state values.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Reverse``1(``0[])">
 <summary>Returns a new array with the elements in reverse order.</summary>
 <param name="array">The input array.</param>
 <returns>The reversed array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0[])">
 <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.
 Raises ArgumentException if the array has size zero.</summary>
 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The final result of the reductions.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0[])">
 <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises ArgumentException if the array has size zero.</summary>
 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The final result of the redcutions.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32},``0[])">
 <summary>Returns an array with all elements permuted according to the
 specified permutation.</summary>
 <param name="indexMap">The function that maps input indices to output indices.</param>
 <param name="array">The input array.</param>
 <returns>The output array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[])">
 <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <returns>A pair of arrays. The first containing the elements the predicate evaluated to true,
 and the second containing those evaluated to false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new array from the given enumerable object.</summary>
 <param name="source">The input sequence.</param>
 <returns>The array of elements from the sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds an array from the given list.</summary>
 <param name="list">The input list.</param>
 <returns>The array of elements from the list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[])">
 <summary>Returns the lowest of all elements of the array, compared via Operators.min on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The minimum element.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Min``1(``0[])">
 <summary>Returns the lowest of all elements of the array, compared via Operators.min.</summary>

 <remarks>Throws ArgumentException for empty arrays</remarks>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The minimum element.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[])">
 <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Max``1(``0[])">
 <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``0[])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.</summary>
 <param name="mapping">The function to transform elements and their indices.</param>
 <param name="array">The input array.</param>
 <returns>The array of transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},``0[],``1[])">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise, also passing the index of 
 the elements. The two input arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="mapping">The function to transform pairs of input elements and their indices.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <returns>The array of transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},``0[],``1[])">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="mapping">The function to transform the pairs of the input elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <returns>The array of transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>
 <param name="mapping">The function to transform elements of the array.</param>
 <param name="array">The input array.</param>
 <returns>The array of transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Length``1(``0[])">
 <summary>Returns the length of an array. You can also use property arr.Length.</summary>
 <param name="array">The input array.</param>
 <returns>The length of the array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}}},``0[],``1[])">
 <summary>Applies the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an <c>ArgumentException</c> is raised.</summary>
 <param name="action">The function to apply to each index and pair of elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}},``0[])">
 <summary>Applies the given function to each element of the array. The integer passed to the
 function indicates the index of element.</summary>
 <param name="action">The function to apply to each index and element.</param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},``0[],``1[])">
 <summary>Applies the given function to pair of elements drawn from matching indices in two arrays. The
 two arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="action">The function to apply.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[])">
 <summary>Applies the given function to each element of the array.</summary>
 <param name="action">The function to apply.</param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IsEmpty``1(``0[])">
 <summary>Returns true if the given array is empty, otherwise false.</summary>
 <param name="array">The input array.</param>
 <returns>True if the array is empty.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ZeroCreate``1(System.Int32)">
 <summary>Creates an array where the entries are initially the default value Unchecked.defaultof&lt;'T&gt;.</summary>
 <param name="count">The length of the array to create.</param>
 <returns>The created array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
 <summary>Creates an array given the dimension and a generator function to compute the elements.</summary>
 <param name="count">The number of elements to initialize.</param>
 <param name="initializer">The function to generate the initial values for each index.</param>
 <returns>The created array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Get``1(``0[],System.Int32)">
 <summary>Gets an element from an array.</summary>
 <param name="array">The input array.</param>
 <param name="index">The input index.</param>
 <returns>The value of the array at the given index.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``2}}},``0[],``1[],``2)">
 <summary>Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <param name="state">The initial state.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <returns>The final state.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},``2,``0[],``1[])">
 <summary>Applies a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <returns>The final state.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},``0[],``1)">
 <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN s))</c></summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="array">The input array.</param>
 <param name="state">The initial state.</param>
 <returns>The final state.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,``0[])">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f s i0)...) iN</c></summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="array">The input array.</param>
 <returns>The final state.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},``0[],``1[])">
 <summary>Tests if all corresponding elements of the array satisfy the given predicate pairwise.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <returns>True if all of the array elements satisfy the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[])">
 <summary>Tests if all elements of the array satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input collection. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <returns>True if all of the array elements satisfy the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[])">
 <summary>Returns the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisy the predicate.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <returns>The index of the first element in the array that satisfies the given predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Find``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[])">
 <summary>Returns the first element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <returns>The first element for which <c>predicate</c> returns true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[])">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <returns>An array containing the elements for which the given predicate returns true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},``0[],``1[])">
 <summary>Tests if any pair of corresponding elements of the arrays satisfies the given predicate.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <returns>True if any result from <c>predicate</c> is true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[])">
 <summary>Tests if any element of the array satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input array. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <returns>True if any result from <c>predicate</c> is true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Empty``1">
 <summary>Returns an empty array of the given type.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Applies the given function to each element of the array. Returns
 the array comprised of the results "x" for each element where
 the function returns Some(x)</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="array">The input array.</param>
 <returns>The array of results.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>KeyNotFoundException</c> is raised.</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="array">The input array.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if every result from
 <c>chooser</c> is <c>None</c>.</exception>
 <returns>The first result.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fill``1(``0[],System.Int32,System.Int32,``0)">
 <summary>Fills a range of elements of the array with the given value.</summary>
 <param name="target">The target array.</param>
 <param name="targetIndex">The index of the first element to set.</param>
 <param name="count">The number of elements to set.</param>
 <param name="value">The value to set.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>None</c> is returned.</summary>
 <param name="chooser">The function to transform the array elements into options.</param>
 <param name="array">The input array.</param>
 <returns>The first transformed element that is <c>Some(x)</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Create``1(System.Int32,``0)">
 <summary>Creates an array whose elements are all initially the given value.</summary>
 <param name="count">The length of the array to create.</param>
 <param name="value">The value for the elements.</param>
 <returns>The created array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Copy``1(``0[])">
 <summary>Builds a new array that contains the elements of the given array.</summary>
 <param name="array">The input array.</param>
 <returns>A copy of the input array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Concat``1(System.Collections.Generic.IEnumerable{``0[]})">
 <summary>Builds a new array that contains the elements of each of the given sequence of arrays.</summary>
 <param name="arrays">The input sequence of arrays.</param>
 <returns>The concatenation of the sequence of input arrays.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1[]},``0[])">
 <summary>For each element of the array, applies the given function. Concatenates all the results and return the combined array.</summary>
 <param name="mapping">The function to create sub-arrays from the input array elements.</param>
 <param name="array">The input array.</param>
 <returns>The concatenation of the sub-arrays.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CopyTo``1(``0[],System.Int32,``0[],System.Int32,System.Int32)">
 <summary>Reads a range of elements from the first array and write them into the second.</summary>
 <param name="source">The source array.</param>
 <param name="sourceIndex">The starting index of the source array.</param>
 <param name="target">The target array.</param>
 <param name="targetIndex">The starting index of the target array.</param>
 <param name="count">The number of elements to copy.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[])">
 <summary>Returns the average of the elements generated by applying the function to each element of the array.</summary>
 <param name="projection">The function to transform the array elements before averaging.</param>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when <c>array</c> is empty.</exception>
 <returns>The computed average.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Average``1(``0[])">
 <summary>Returns the average of the elements in the array.</summary>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when <c>array</c> is empty.</exception>
 <returns>The average of the elements in the array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Append``1(``0[],``0[])">
 <summary>Builds a new array that contains the elements of the first array followed by the elements of the second array.</summary>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <returns>The resulting array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[])">
 <summary>Split the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively </summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to indicies is not specified.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>
 <returns>'T[] * 'T[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
 <summary>Create an array given the dimension and a generator function to compute the elements.</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to indicies is not specified.</remarks>
 <param name="count"></param>
 <param name="initializer"></param>
 <returns>'T[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}},``0[])">
 <summary>Apply the given function to each element of the array. The integer passed to the
 function indicates the index of element.</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>
 <param name="action"></param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[])">
 <summary>Apply the given function to each element of the array. </summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>
 <param name="action"></param>
 <param name="array">The input array.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``0[])">
 <summary>Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>
 <param name="mapping"></param>
 <param name="array">The input array.</param>
 <returns>'U[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[])">
 <summary>Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>
 <param name="mapping"></param>
 <param name="array">The input array.</param>
 <returns>'U[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Collect``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1[]},``0[])">
 <summary>For each element of the array, apply the given function. Concatenate all the results and return the combined array.</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>
 <param name="mapping"></param>
 <param name="array">The input array.</param>
 <returns>'U[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Apply the given function to each element of the array. Return
 the array comprised of the results "x" for each element where
 the function returns Some(x).</summary>

 <remarks>Performs the operation in parallel using System.Threading.Parallel.For.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="array">The input array.</param>
 <returns>'U[]</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.ArrayModule.Parallel">
 <summary>Provides parallel operations on arrays </summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ArrayModule">
 <summary>Basic operations on arrays.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.FromFunction``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}})">
 <summary>Compare using the given comparer function.</summary>
 <param name="comparer">A function to compare two values.</param>
 <returns>An object implementing IComparer using the supplied comparer.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.Structural``1">
 <summary>Structural comparison.  Compare using Operators.compare.</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ComparisonIdentity">
 <summary>Common notions of comparison identity used with sorted data structures.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.FromFunctions``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}})">
 <summary>Hash using the given hashing and equality functions.</summary>
 <param name="hasher">A function to generate a hash code from a value.</param>
 <param name="equality">A function to test equality of two values.</param>
 <returns>An object implementing IEqualityComparer using the supplied functions.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Reference``1">
 <summary>Physical hashing (hash on reference identity of objects, and the contents of value types).  
 Hash using LanguagePrimitives.PhysicalEquality and LanguagePrimitives.PhysicalHash,
 That is, for value types use GetHashCode and Object.Equals (if no other optimization available),
 and for reference types use System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode and 
 reference equality.</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Structural``1">
 <summary>Structural hashing.  Hash using Operators.(=) and Operators.hash.</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashIdentity">
 <summary>Common notions of value identity used with hash tables.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Zip3``3(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
 <summary>Combines the three lists into a list of triples. The lists must have equal lengths.</summary>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <param name="list3">The third input list.</param>
 <returns>A single list containing triples of matching elements from the input lists.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Zip``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Combines the two lists into a list of pairs. The two lists must have equal lengths.</summary>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <returns>A single list containing pairs of matching elements from the input lists.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Unzip3``3(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{``0,``1,``2}})">
 <summary>Splits a list of triples into three lists.</summary>
 <param name="list">The input list.</param>
 <returns>Three lists of split elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Unzip``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
 <summary>Splits a list of pairs into two lists.</summary>
 <param name="list">The input list.</param>
 <returns>Two lists of split elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the index of the first element in the list
 that satisfies the given predicate.
 Return <c>None</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>The index of the first element for which the predicate returns true, or None if
 every element evaluates to false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first element for which the given function returns <c>true.</c>.
 Return <c>None</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>The first element for which the predicate returns true, or None if
 every element evaluates to false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies the given function to successive elements, returning <c>Some(x)</c> the first
 result where function returns <c>Some(x)</c> for some x. If no such element 
 exists then return <c>None</c>.</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="list">The input list.</param>
 <returns>The first resulting value or None.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ToSeq``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Views the given list as a sequence.</summary>
 <param name="list">The input list.</param>
 <returns>The sequence of elements in the list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ToArray``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds an array from the given list.</summary>
 <param name="list">The input list.</param>
 <returns>The array containing the elements of the list.</returns>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the sum of the results generated by applying the function to each element of the list.</summary>
 <param name="projection">The function to transform the list elements into the type to be summed.</param>
 <param name="list">The input list.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Sum``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the sum of the elements in the list.</summary>
 <param name="list">The input list.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Sort``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Sorts the given list using Operators.compare.</summary>

 <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
 <param name="list">The input list.</param>
 <returns>The sorted list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Sorts the given list using keys given by the given projection. Keys are compared using Operators.compare.</summary>

 <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
 <param name="projection">The function to transform the list elements into the type to be compared.</param>
 <param name="list">The input list.</param>
 <returns>The sorted list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Sorts the given list using the given comparison function.</summary>

 <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
 <param name="comparer">The function to compare the list elements.</param>
 <param name="list">The input list.</param>
 <returns>The sorted list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
 <summary>Like <c>foldBack</c>, but returns both the intermediary and final results</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="list">The input list.</param>
 <param name="state">The initial state.</param>
 <returns>The list of states.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list. Then feed this result into the function along
 with the second element and so on. Returns the list of intermediate results and the final result.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="list">The input list.</param>
 <returns>The list of states.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Reverse``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new list with the elements in reverse order.</summary>
 <param name="list">The input list.</param>
 <returns>The reversed list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Replicate``1(System.Int32,``0)">
 <summary>Creates a list by calling the given generator on each index.</summary>
 <param name="count">The number of elements to replicate.</param>
 <param name="initial">The value to replicate</param>
 <returns>The generated list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN-1 iN))</c>.</summary>

 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
 <param name="reduction">The function to reduce two list elements to a single element.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The final reduced value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Apply the function to the first two elements of the list.
 Then feed this result into the function along with the third element and so on. 
 Return the final result. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f i0 i1) i2 ...) iN</c>.</summary>

 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
 <param name="reduction">The function to reduce two list elements to a single element.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The final reduced value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list with all elements permuted according to the
 specified permutation.</summary>
 <param name="indexMap">The function to map input indices to output indices.</param>
 <param name="list">The input list.</param>
 <returns>The permutated list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some x. If no such
 element exists then raise <c>System.Collections.Generic.KeyNotFoundException</c></summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="list">The input list.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown when the list is empty.</exception>
 <returns>The first resulting value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns <c>true</c> and <c>false</c>
 respectively.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>A list containing the elements for which the predicate evaluated to false and a list
 containing the elements for which the predicate evaluated to true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new list from the given enumerable object.</summary>
 <param name="source">The input sequence.</param>
 <returns>The list of elements from the sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.OfArray``1(``0[])">
 <summary>Builds a list from the given array.</summary>
 <param name="array">The input array.</param>
 <returns>The list of elements from the array.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Get``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
 <summary>Indexes into the list. The first element has index 0.</summary>
 <param name="list">The input list.</param>
 <param name="index">The index to retrieve.</param>
 <returns>The value at the given index.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the lowest of all elements of the list, compared via Operators.min on the function result</summary>

 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty.</remarks>
 <param name="projection">The function to transform list elements into the type to be compared.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The minimum value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Min``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the lowest of all elements of the list, compared via Operators.min.</summary>

 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The minimum value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the greatest of all elements of the list, compared via Operators.max on the function result.</summary>

 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty.</remarks>
 <param name="projection">The function to transform the list elements into the type to be compared.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Max``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Return the greatest of all elements of the list, compared via Operators.max.</summary>

 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Like mapi, but mapping corresponding elements from two lists of equal length.</summary>
 <param name="mapping">The function to transform pairs of elements from the two lists and their index.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <returns>The list of transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>
 <param name="mapping">The function to transform elements and their indices.</param>
 <param name="list">The input list.</param>
 <returns>The list of transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the three collections simultaneously.</summary>
 <param name="mapping">The function to transform triples of elements from the input lists.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <param name="list3">The third input list.</param>
 <returns>The list of transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.</summary>
 <param name="mapping">The function to transform pairs of elements from the input lists.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <returns>The list of transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.</summary>
 <param name="mapping">The function to transform elements from the input list.</param>
 <param name="list">The input list.</param>
 <returns>The list of transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Length``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the length of the list.</summary>
 <param name="list">The input list.</param>
 <returns>The length of the list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Applies the given function to two collections simultaneously. The
 collections must have identical size. The integer passed to the
 function indicates the index of element.</summary>
 <param name="action">The function to apply to a pair of elements from the input lists along with their index.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies the given function to each element of the collection. The integer passed to the
 function indicates the index of element.</summary>
 <param name="action">The function to apply to the elements of the list along with their index.</param>
 <param name="list">The input list.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Applies the given function to two collections simultaneously. The
 collections must have identical size.</summary>
 <param name="action">The function to apply to pairs of elements from the input lists.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies the given function to each element of the collection.</summary>
 <param name="action">The function to apply to elements from the input list.</param>
 <param name="list">The input list.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns true if the list contains no elements, false otherwise.</summary>
 <param name="list">The input list.</param>
 <returns>True if the list is empty.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
 <summary>Creates a list by calling the given generator on each index.</summary>
 <param name="length">The length of the list to generate.</param>
 <param name="initializer">The function to generate an element from an index.</param>
 <returns>The list of generated elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Head``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first element of the list.</summary>

 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The first element of the list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Tests if all corresponding elements of the collection satisfy the given predicate pairwise.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <c>System.ArgumentException</c> exception is raised. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
 <returns>True if all of the pairs of elements satisfy the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Tests if all elements of the collection satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input list. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>True if all of the elements satisfy the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},``2)">
 <summary>Applies a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f i0 j0 (...(f iN jN s))</c>.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <param name="state">The initial state.</param>
 <returns>The final state value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f i0 (...(f iN s))</c>.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="list">The input list.</param>
 <param name="state">The initial state.</param>
 <returns>The final state value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},``2,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Applies a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f (... (f s i0 j0)...) iN jN</c>.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <returns>The final state value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list. Then feed this result into the function along
 with the second element and so on. Return the final result.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f (... (f s i0) i1 ...) iN</c>.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="list">The input list.</param>
 <returns>The final state value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true"</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>A list containing only the elements that satisfy the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the index of the first element in the list
 that satisfies the given predicate.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown if the predicate evaluates to false for all the
 elements of the list.</exception>
 <returns>The index of the first element that satisfies the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Find``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first element for which the given function returns <c>true</c>.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if the predicate evaluates to false for
 all the elements of the list.</exception>
 <returns>The first element that satisfies the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Tests if any pair of corresponding elements of the lists satisfies the given predicate.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <c>System.ArgumentException</c> exception is raised. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
 <returns>True if any pair of elements satisfy the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Tests if any element of the list satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input list. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>True if any element satisfies the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Empty``1">
 <summary>Returns an empty list of the given type.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Concat``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{``0}})">
 <summary>Returns a new list that contains the elements of each the lists in order.</summary>
 <param name="lists">The input sequence of lists.</param>
 <returns>The resulting concatenated list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>For each element of the list, applies the given function. Concatenates all the results and return the combined list.</summary>
 <param name="mapping">The function to transform each input element into a sublist to be concatenated.</param>
 <param name="list">The input list.</param>
 <returns>The concatenation of the transformed sublists.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies the given function to each element of the list. Returns
 the list comprised of the results <c>x</c> for each element where
 the function returns Some(x)</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="list">The input list.</param>
 <returns>The list comprising the values selected from the chooser function.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the average of the elements generated by applying the function to each element of the list.</summary>

 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty.</remarks>
 <param name="projection">The function to transform the list elements into the type to be averaged.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The resulting average.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Average``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the average of the elements in the list.</summary>

 <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty.</remarks>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The resulting average.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new list that contains the elements of the first list
 followed by elements of the second.</summary>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <returns>The resulting list.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.ListModule">
 <summary>Basic operations on lists.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryFindKey``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns the key of the first mapping in the collection that satisfies the given predicate. 
 Returns 'None' if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <returns>The first key for which the predicate returns true or None if the predicate evaluates to false for each key/value pair.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.FindKey``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Evaluates the function on each mapping in the collection. Returns the key for the first mapping
 where the function returns 'true'. Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if the key does not exist in the map.</exception>
 <returns>The first key for which the predicate evaluates true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryFind``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Lookup an element in the map, returning a <c>Some</c> value if the element is in the domain 
 of the map and <c>None</c> if not.</summary>
 <param name="key">The input key.</param>
 <param name="table">The input map.</param>
 <returns>The found <c>Some</c> value or <c>None</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Remove``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Removes an element from the domain of the map. No exception is raised if the element is not present.</summary>
 <param name="key">The input key.</param>
 <param name="table">The input map.</param>
 <returns>The resulting map.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds two new maps, one containing the bindings for which the given predicate returns 'true',
 and the other the remaining bindings.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <returns>A pair of maps in which the first contains the elements for which the predicate returned true
 and the second containing the elements for which the predicated returned false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ContainsKey``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Tests if an element is in the domain of the map.</summary>
 <param name="key">The input key.</param>
 <param name="table">The input map.</param>
 <returns>True if the map contains the key.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The key passed to the
 function indicates the key of element being transformed.</summary>
 <param name="mapping">The function to transform the key/value pairs.</param>
 <param name="table">The input map.</param>
 <returns>The resulting map of keys and transformed values.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ForAll``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns true if the given predicate returns true for all of the
 bindings in the map.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <returns>True if the predicate evaluates to true for all of the bindings in the map.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds a new map containing only the bindings for which the given predicate returns 'true'.</summary>
 <param name="predicate">The function to test the key/value pairs.</param>
 <param name="table">The input map.</param>
 <returns>The filtered map.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns true if the given predicate returns true for one of the
 bindings in the map.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <returns>True if the predicate returns true for one of the key/value pairs.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Applies the given function to each binding in the dictionary</summary>
 <param name="action">The function to apply to each key/value pair.</param>
 <param name="table">The input map.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},``2,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Folds over the bindings in the map </summary>
 <param name="folder">The function to update the state given the input key/value pairs.</param>
 <param name="state">The initial state.</param>
 <param name="table">The input map.</param>
 <returns>The final state value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1},``2)">
 <summary>Folds over the bindings in the map.</summary>
 <param name="folder">The function to update the state given the input key/value pairs.</param>
 <param name="table">The input map.</param>
 <param name="state">The initial state.</param>
 <returns>The final state value.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Pick``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Searches the map looking for the first element where the given function returns a <c>Some</c> value</summary>
 <param name="chooser">The function to generate options from the key/value pairs.</param>
 <param name="table">The input map.</param>
 <returns>The first result.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryPick``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Searches the map looking for the first element where the given function returns a <c>Some</c> value.</summary>
 <param name="chooser">The function to generate options from the key/value pairs.</param>
 <param name="table">The input map.</param>
 <returns>The first result.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Find``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Lookup an element in the map, raising <c>KeyNotFoundException</c> if no binding
 exists in the map.</summary>
 <param name="key">The input key.</param>
 <param name="table">The input map.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown when the key does not exist in the map.</exception>
 <returns>The value mapped to the given key.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Empty``2">
 <summary>The empty map.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.IsEmpty``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Is the map empty?</summary>
 <param name="table">The input map.</param>
 <returns>True if the map is empty.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToArray``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns an array of all key-value pairs in the mapping.
 The array will be ordered by the keys of the map.</summary>
 <param name="table">The input map.</param>
 <returns>The array of key/value pairs.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.</summary>
 <param name="table">The input map.</param>
 <returns>The list of key/value pairs.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToSeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.</summary>
 <param name="table">The input map.</param>
 <returns>The sequence of key/value pairs.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple`2{``0,``1}})">
 <summary>Returns a new map made from the given bindings.</summary>
 <param name="elements">The input sequence of key/value pairs.</param>
 <returns>The resulting map.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfArray``2(System.Tuple`2{``0,``1}[])">
 <summary>Returns a new map made from the given bindings.</summary>
 <param name="elements">The input array of key/value pairs.</param>
 <returns>The resulting map.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
 <summary>Returns a new map made from the given bindings.</summary>
 <param name="elements">The input list of key/value pairs.</param>
 <returns>The resulting map.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Add``2(``0,``1,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns a new map with the binding added to the given map.</summary>
 <param name="key">The input key.</param>
 <param name="value">The input value.</param>
 <param name="table">The input map.</param>
 <returns>The resulting map.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.MapModule">
 <summary>Functional programming operators related to the <c>Map&lt;_,_&gt;</c> type.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Zip3``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
 <summary>Combines the three sequences into a list of triples. The sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequences are ignored.</summary>

 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>
 <param name="source3">The third input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when any of the input sequences is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Combines the two sequences into a list of pairs. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.</summary>

 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Windowed``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that yields sliding windows of containing elements drawn from the input
 sequence. Each window is returned as a fresh array.</summary>

 <param name="windowSize">The number of elements in each window.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple`2{``1,``0}}},``0)">
 <summary>Returns a sequence that contains the elements generated by the given computation.
 The given initial <c>state</c> argument is passed to the element generator.
 For each IEnumerator elements in the stream are generated on-demand by applying the element
 generator, until a None value is returned by the element generator. Each call to the element
 generator returns a new residual <c>state</c>.</summary>

 <remarks>The stream will be recomputed each time an IEnumerator is requested and iterated for the Seq.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="generator">A function that takes in the current state and returns an option tuple of the next
 element of the sequence and the next state value.</param>
 <param name="state">The initial state value.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Truncate``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that when enumerated returns at most N elements.</summary>

 <param name="count">The maximum number of items to enumerate.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to successive elements, returning the first
 result where the function returns "Some(x)".</summary>

 <param name="chooser">A function that transforms items from the input sequence into options.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the index of the first element in the sequence 
 that satisfies the given predicate. Return <c>None</c> if no such element exists.</summary>

 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.</summary>

 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ToList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a list from the given collection.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds an array from the given collection.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that, when iterated, yields elements of the underlying sequence while the 
 given predicate returns <c>true</c>, and then returns no further elements.</summary>

 <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Take``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first N elements of the sequence.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the sequence. <c>Seq.truncate</c>
 returns as many items as the sequence contains instead of throwing an exception.</remarks>

 <param name="count">The number of items to take.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the sequence.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the sum of the results generated by applying the function to each element of the sequence.</summary>
 <remarks>The generated elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.</remarks>

 <param name="projection">A function to transform items from the input sequence into the type that will be summed.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Sum``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the sum of the elements in the sequence.</summary>

 <remarks>The elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered
 by keys.  The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.</summary> 
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="projection">A function to transform items of the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Sort``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Yields a sequence ordered by keys.</summary>
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that, when iterated, skips elements of the underlying sequence while the 
 given predicate returns <c>true</c>, and then yields the remaining elements of the sequence.</summary>

 <param name="predicate">A function that evaluates an element of the sequence to a boolean value.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Skip``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that skips N elements of the underlying sequence and then yields the
 remaining elements of the sequence.</summary>

 <param name="count">The number of items to skip.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the sequence.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Singleton``1(``0)">
 <summary>Returns a sequence that yields one item only.</summary>

 <param name="value">The input item.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Like fold, but computes on-demand and returns the sequence of intermediary and final results.</summary>

 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a function to each element of the sequence, threading an accumulator argument
 through the computation. Begin by applying the function to the first two elements.
 Then feed this result into the function along with the third element and so on.  
 Return the final result.</summary>

 <param name="reduction">A function that takes in the current accumulated result and the next
 element of the sequence to produce the next accumulated result.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new sequence object that delegates to the given sequence object. This ensures 
 the original sequence cannot be rediscovered and mutated by a type cast. For example, 
 if given an array the returned sequence will return the elements of the array, but
 you cannot cast the returned sequence object to an array.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to successive elements, returning the first
 <c>x</c> where the function returns "Some(x)".</summary>

 <param name="chooser">A function to transform each item of the input sequence into an option of the output type.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown when every item of the sequence
 evaluates to <c>None</c> when the given function is applied.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Pairwise``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence of each element in the input sequence and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Views the given list as a sequence.</summary>

 <param name="source">The input list.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.OfArray``1(``0[])">
 <summary>Views the given array as a sequence.</summary>

 <param name="source">The input array.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Get``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Computes the nth element in the collection.</summary>

 <param name="index">The index of element to retrieve.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the lowest of all elements of the sequence, compared via Operators.min on the function result.</summary>

 <param name="projection">A function to transform items from the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Min``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the lowest of all elements of the sequence, compared via <c>Operators.min</c>.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the greatest of all elements of the sequence, compared via Operators.max on the function result.</summary>

 <param name="projection">A function to transform items from the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Max``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the greatest of all elements of the sequence, compared via Operators.max</summary>

 <param name="source">The input sequence.</param>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>

 <param name="mapping">A function to transform items from the input sequence that also supplies the current index.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.</summary>

 <param name="mapping">A function to transform pairs of items from the input sequences.</param>
 <param name="source">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.  The given function will be applied
 as elements are demanded using the <c>MoveNext</c> method on enumerators retrieved from the
 object.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="mapping">A function to transform items from the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Length``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the length of the sequence</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Applies the given function to two collections simultaneously. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.</summary>

 <param name="action">A function to apply to each pair of elements from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to each element of the collection. The integer passed to the
 function indicates the index of element.</summary>

 <param name="action">A function to apply to each element of the sequence that can also access the current index.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to each element of the collection.</summary>

 <param name="action">A function to apply to each element of the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.InitializeInfinite``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
 <summary>Generates a new sequence which, when iterated, will return successive
 elements by calling the given function.  The results of calling the function
 will not be saved, that is the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
 Iteration can continue up to <c>Int32.MaxValue</c>.</remarks>

 <param name="initializer">A function that generates an item in the sequence from a given index.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
 <summary>Generates a new sequence which, when iterated, will return successive
 elements by calling the given function, up to the given count.  The results of calling the function
 will not be saved, that is the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="count">The maximum number of items to generate for the sequence.</param>
 <param name="initializer">A function that generates an item in the sequence from a given index.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns true if the sequence contains no elements, false otherwise.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Head``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first element of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a key-generating function to each element of a sequence and yields a sequence of 
 unique keys. Each unique key has also contains a sequence of all elements that match 
 to this key.</summary>
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.</remarks>

 <param name="projection">A function that transforms an element of the sequence into a comparable key.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Tests the all pairs of elements drawn from the two sequences satisfy the
 given predicate. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.</summary>

 <param name="predicate">A function to test pairs of elements from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Tests if all elements of the sequence satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input sequence. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>

 <param name="predicate">A function to test an element of the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f s i0)...) iN</c></summary>

 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the index of the first element for which the given function returns <c>true</c>.</summary>

 <param name="predicate">A function to test whether the index of a particular element should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Find``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first element for which the given function returns <c>true</c>.</summary>

 <param name="predicate">A function to test whether an item in the sequence should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>

 <param name="predicate">A function to test whether each item in the input sequence should be included in the output.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>    
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Tests if any pair of corresponding elements of the input sequences satisfies the given predicate.</summary>

 <remarks>The predicate is applied to matching elements in the two sequences up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, false is returned. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.</remarks>

 <param name="predicate">A function to test each pair of items from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the two input sequences is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Tests if any element of the sequence satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input sequence. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>

 <param name="predicate">A function to test each item of the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Empty``1">
 <summary>Creates an empty sequence.</summary>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.</summary>

 <param name="projection">A function transforming the sequence items into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Delay``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{``0}})">
 <summary>Returns a sequence that is built from the given delayed specification of a
 sequence.</summary>

 <remarks>The input function is evaluated each time an IEnumerator for the sequence 
 is requested.</remarks>

 <param name="generator">The generating function for the sequence.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a key-generating function to each element of a sequence and return a sequence yielding unique
 keys and their number of occurrences in the original sequence.</summary>
 
 <remarks>Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.</remarks>

 <param name="projection">A function transforming each item of input sequence into a key to be
 compared against the others.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Concat``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>Combines the given enumeration-of-enumerations as a single concatenated
 enumeration.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="sources">The input enumeration-of-enumerations.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Compares two sequences using the given comparison function, element by element.
 Returns the first non-zero result from the comparison function.  If the end of a sequence
 is reached it returns a -1 if the first sequence is shorter and a 1 if the second sequence
 is shorter.</summary>

 <param name="comparer">A function that takes an element from each sequence and returns an int.
 If it evaluates to a non-zero value iteration is stopped and that value is returned.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the input sequences
 is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Collect``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to each element of the sequence and concatenates all the
 results.</summary>

 <remarks>Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>

 <param name="mapping">A function to transform elements of the input sequence into the sequences
 that will then be concatenated.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to each element of the list. Return
 the list comprised of the results "x" for each element where
 the function returns Some(x).</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not
 be accessed concurrently.</remarks>

 <param name="chooser">A function to transform items of type T into options of type U.</param>
 <param name="source">The input sequence of type T.</param>

 <returns>The result sequence.</returns>
 
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Cast``1(System.Collections.IEnumerable)">
 <summary>Wraps a loosely-typed System.Collections sequence as a typed sequence.</summary>

 <remarks>The use of this function usually requires a type annotation.
 An incorrect type annotation may result in runtime type
 errors.
 Individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>
 
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Cache``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that corresponds to a cached version of the input sequence.
 This result sequence will have the same elements as the input sequence. The result 
 can be enumerated multiple times. The input sequence will be enumerated at most 
 once and only as far as is necessary.  Caching a sequence is typically useful when repeatedly
 evaluating items in the original sequence is computationally expensive or if
 iterating the sequence causes side-effects that the user does not want to be
 repeated multiple times.

 Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
 values may be used simultaneously from different threads (accesses to 
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not typically thread safe and should not be accessed concurrently.</summary>

 <remarks>Once enumeration of the input sequence has started,
 it's enumerator will be kept live by this object until the enumeration has completed.
 At that point, the enumerator will be disposed. 

 The enumerator may be disposed and underlying cache storage released by 
 converting the returned sequence object to type IDisposable, and calling the Dispose method
 on this object. The sequence object may then be re-enumerated and a fresh enumerator will
 be used.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the average of the results generated by applying the function to each element 
 of the sequence.</summary>

 <remarks>The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property 
 associated with the generated type.</remarks>

 <param name="projection">A function applied to transform each element of the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence has zero elements.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Average``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the average of the elements in the sequence.</summary>

 <remarks>The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property 
 associated with the element type.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence has zero elements.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Wraps the two given enumerations as a single concatenated
 enumeration.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed
 concurrently.</remarks>

 <param name="source1">The first sequence.</param>
 <param name="source2">The second sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the two provided sequences is
 null.</exception>
</member>
<member name="T:Microsoft.FSharp.Collections.SeqModule">
 <summary>Basic operations on IEnumerables.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Difference``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new set with the elements of the second set removed from the first.</summary>
 <param name="set1">The first input set.</param>
 <param name="set2">The set whose elements will be removed from <c>set1</c>.</param>
 <returns>The set with the elements of <c>set2</c> removed from <c>set1</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new collection from the given enumerable object.</summary>
 <param name="elements">The input sequence.</param>
 <returns>The set containing <c>elements</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToSeq``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns an ordered view of the collection as an enumerable object.</summary>
 <param name="set">The input set.</param>
 <returns>An ordered sequence of the elements of <c>set</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToArray``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Builds an array that contains the elements of the set in order.</summary>
 <param name="set">The input set.</param>
 <returns>An ordered array of the elements of <c>set</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfArray``1(``0[])">
 <summary>Builds a set that contains the same elements as the given array.</summary>
 <param name="array">The input array.</param>
 <returns>A set containing the elements of <c>array</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToList``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Builds a list that contains the elements of the set in order.</summary>
 <param name="set">The input set.</param>
 <returns>An ordered list of the elements of <c>set</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a set that contains the same elements as the given list.</summary>
 <param name="elements">The input list.</param>
 <returns>A set containing the elements form the input list.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.MaxElement``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns the highest element in the set according to the ordering being used for the set.</summary>
 <param name="set">The input set.</param>
 <returns>The max value from the set.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.MinElement``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns the lowest element in the set according to the ordering being used for the set.</summary>
 <param name="set">The input set.</param>
 <returns>The min value from the set.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Remove``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new set with the given element removed. No exception is raised if 
 the set doesn't contain the given element.</summary>
 <param name="value">The element to remove.</param>
 <param name="set">The input set.</param>
 <returns>The input set with <c>value</c> removed.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Splits the set into two sets containing the elements for which the given predicate
 returns true and false respectively.</summary>
 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>
 <returns>A pair of sets with the first containing the elements for which <c>predicate</c> returns
 true and the second containing the elements for which <c>predicate</c> returns false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Applies the given function to each element of the set, in order according
 to the comparison function.</summary>
 <param name="action">The function to apply to each element.</param>
 <param name="set">The input set.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns "true" if the set is empty.</summary>
 <param name="set">The input set.</param>
 <returns>True if <c>set</c> is empty.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.UnionMany``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpSet{``0}})">
 <summary>Computes the union of a sequence of sets.</summary>
 <param name="sets">The sequence of sets to untion.</param>
 <returns>The union of the input sets.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Union``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Computes the union of the two sets.</summary>
 <param name="set1">The first input set.</param>
 <param name="set2">The second input set.</param>
 <returns>The union of <c>set1</c> and <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IntersectMany``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpSet{``0}})">
 <summary>Computes the intersection of a sequence of sets. The sequence must be non-empty.</summary>
 <param name="sets">The sequence of sets to intersect.</param>
 <returns>The intersection of the input sets.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Intersect``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Computes the intersection of the two sets.</summary>
 <param name="set1">The first input set.</param>
 <param name="set2">The second input set.</param>
 <returns>The intersection of <c>set1</c> and <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Tests if all elements of the collection satisfy the given predicate.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and "j0...jN"
 then computes <c>p i0 &amp;&amp; ... &amp;&amp; p iN</c>.</summary>
 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>
 <returns>True if all elements of <c>set</c> satisfy <c>predicate</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpSet{``0},``1)">
 <summary>Applies the given accumulating function to all the elements of the set.</summary>
 <param name="folder">The accumulating function.</param>
 <param name="set">The input set.</param>
 <param name="state">The initial state.</param>
 <returns>The final state.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Applies the given accumulating function to all the elements of the set</summary>
 <param name="folder">The accumulating function.</param>
 <param name="state">The initial state.</param>
 <param name="set">The input set.</param>
 <returns>The final state.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new collection containing the results of applying the
 given function to each element of the input set.</summary>
 <param name="mapping">The function to transform elements of the input set.</param>
 <param name="set">The input set.</param>
 <returns>A set containing the transformed elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns <c>true</c>.</summary>
 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>
 <returns>The set containing only the elements for which <c>predicate</c> returns true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Tests if any element of the collection satisfies the given predicate.
 If the input function is <c>predicate</c> and the elements are <c>i0...iN</c> 
 then computes <c>p i0 or ... or p iN</c>.</summary>
 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>
 <returns>True if any element of <c>set</c> satisfies <c>predicate</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Count``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns the number of elements in the set. Same as <c>size</c>.</summary>
 <param name="set">The input set.</param>
 <returns>The number of elements in the set.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsProperSuperset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first, and at least 
 one element of the first is not in the second.</summary>
 <param name="set1">The potential superset.</param>
 <param name="set2">The set to test against.</param>
 <returns>True if <c>set1</c> is a proper superset of <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsSuperset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first.</summary>
 <param name="set1">The potential superset.</param>
 <param name="set2">The set to test against.</param>
 <returns>True if <c>set1</c> is a superset of <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsProperSubset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second, and at least 
 one element of the second is not in the first.</summary>
 <param name="set1">The potential subset.</param>
 <param name="set2">The set to test against.</param>
 <returns>True if <c>set1</c> is a proper subset of <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsSubset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second</summary>
 <param name="set1">The potential subset.</param>
 <param name="set2">The set to test against.</param>
 <returns>True if <c>set1</c> is a subset of <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Contains``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if the given element is in the given set.</summary>
 <param name="element">The element to test.</param>
 <param name="set">The input set.</param>
 <returns>True if <c>element</c> is in <c>set</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Add``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new set with an element added to the set. No exception is raised if
 the set already contains the given element.</summary>
 <param name="value">The value to add.</param>
 <param name="set">The input set.</param>
 <returns>A new set containing <c>value</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Singleton``1(``0)">
 <summary>The set containing the given element.</summary>
 <param name="value">The value for the set to contain.</param>
 <returns>The set containing <c>value</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Empty``1">
 <summary>The empty set for the type 'T.</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.SetModule">
 <summary>Functional programming operators related to the <c>Set&lt;_&gt;</c> type.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpAsync.DefaultCancellationToken">
 <summary>Gets the default cancellation token for executing asynchronous computations.</summary>
 <returns>The default CancellationToken.</returns>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpAsync.CancellationToken">
 <summary>Creates an asynchronous computation that returns the CancellationToken governing the execution 
 of the computation.</summary>
 <remarks>In <c>async { let! token = Async.CancellationToken ...}</c> token can be used to initiate other 
 asynchronous operations that will cancel cooperatively with this workflow.</remarks>
 <returns>An asynchronous computation capable of retrieving the CancellationToken from a computation
 expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.TryCancelled``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})">
 <summary>Creates an asynchronous computation that executes <c>computation</c>.
 If this computation is cancelled before it completes then the computation generated by 
 running <c>compensation</c> is executed.</summary>
 <param name="computation">The input asynchronous computation.</param>
 <param name="compensation">The function to be run if the computation is cancelled.</param>
 <returns>An asynchronous computation that runs the compensation if the input computation
 is cancelled.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToThreadPool">
 <summary>Creates an asynchronous computation that queues a work item that runs
 its continuation.</summary>
 <returns>A computation that generates a new work item in the thread pool.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToNewThread">
 <summary>Creates an asynchronous computation that creates a new thread and runs
 its continuation in that thread.</summary>
 <returns>A computation that will execute on a new thread.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToContext(System.Threading.SynchronizationContext)">
 <summary>Creates an asynchronous computation that runs
 its continuation using syncContext.Post. If syncContext is null 
 then the asynchronous computation is equivalent to SwitchToThreadPool().</summary>
 <param name="syncContext">The synchronization context to accept the posted computation.</param>
 <returns>An asynchronous computation that uses the syncContext context to execute.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartWithContinuations``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Runs an asynchronous computation, starting immediately on the current operating system
 thread. Call one of the three continuations when the operation completes.</summary>
 <remarks>If no cancellation token is provided then the default cancellation token
 is used.</remarks>
 <param name="computation">The asynchronous computation to execute.</param>
 <param name="continuation">The function called on success.</param>
 <param name="exceptionContinuation">The function called on exception.</param>
 <param name="cancellationContinuation">The function called on cancellation.</param>
 <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartImmediate(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Runs an asynchronous computation, starting immediately on the current operating system
 thread.</summary>
 <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>
 <param name="computation">The asynchronous computation to execute.</param>
 <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartChildAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions})">
<summary>
 Creates an asynchronous computation which starts the given computation as a &lt;c&gt;System.Threading.Tasks.Task&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartChild``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Starts a child computation within an asynchronous workflow. 
 This allows multiple asynchronous computations to be executed simultaneously.</summary>
 
 <remarks>This method should normally be used as the immediate 
 right-hand-side of a <c>let!</c> binding in an F# asynchronous workflow, that is,
 
        async { ...
                let! completor1 = childComputation1 |> Async.StartChild  
                let! completor2 = childComputation2 |> Async.StartChild  
                ... 
                let! result1 = completor1 
                let! result2 = completor2 
                ... }
 
 When used in this way, each use of <c>StartChild</c> starts an instance of <c>childComputation</c> 
 and returns a completor object representing a computation to wait for the completion of the operation.
 When executed, the completor awaits the completion of <c>childComputation</c>.</remarks>
 <param name="computation">The child computation.</param>
 <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>A new computation that waits for the input computation to finish.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Executes a computation in the thread pool. Returns a &lt;c&gt;System.Threading.Tasks.Task&lt;/c&gt; that will be completed
 in the corresponding state once the computation terminates (produces the result, throws exception or gets canceled)
        
 If no cancellation token is provided then the default cancellation token is used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Start(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Starts the asynchronous computation in the thread pool. Do not await its result.</summary>

 <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>
 <param name="computation">The computation to run asynchronously.</param>
 <param name="cancellationToken">The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Sleep(System.Int32)">
 <summary>Creates an asynchronous computation that will sleep for the given time. This is scheduled
 using a System.Threading.Timer object. The operation will not block operating system threads
 for the duration of the wait.</summary>
 <param name="millisecondsDueTime">The number of milliseconds to sleep.</param>
 <returns>An asynchronous computation that will sleep for the given time.</returns>
 <exception cref="System.ArgumentOutOfRangeException">Thrown when the due time is negative
 and not infinite.</exception>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.RunSynchronously``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Runs the asynchronous computation and await its result.</summary>

 <remarks>If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.
        
 If no cancellation token is provided then the default cancellation token is used.

 The timeout parameter is given in milliseconds.  A value of -1 is equivalent to
 System.Threading.Timeout.Infinite.</remarks>
 <param name="computation">The computation to run.</param>
 <param name="timeout">The amount of time in milliseconds to wait for the result of the
 computation before raising a <c>System.TimeoutException</c>.  If no value is provided
 for timeout then a default of -1 is used to correspond to System.Threading.Timeout.Infinite.</param>
 <param name="cancellationToken">The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</param>
 <returns>The result of the computation.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Creates an asynchronous computation that executes all the given asynchronous computations, 
 initially queueing each as work items and using a fork/join pattern.</summary>

 <remarks>If all child computations succeed, an array of results is passed to the success continuation.
 
 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</remarks>
 <param name="computationList">A sequence of distinct computations to be parallelized.</param>
 <returns>A computation that returns an array of values from the sequence of input computations.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.OnCancel(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Generates a scoped, cooperative cancellation handler for use within an asynchronous workflow.</summary>

 <remarks>For example,
     <c>async { use! holder = Async.OnCancel interruption ... }</c> 
 generates an asynchronous computation where, if a cancellation happens any time during 
 the execution of the asynchronous computation in the scope of <c>holder</c>, then action 
 <c>interruption</c> is executed on the thread that is performing the cancellation. This can 
 be used to arrange for a computation to be asynchronously notified that a cancellation 
 has occurred, e.g. by setting a flag, or deregistering a pending I/O action.</remarks>
 <param name="interruption">The function that is executed on the thread performing the
 cancellation.</param>
 <returns>An asynchronous computation that triggers the interruption if it is cancelled
 before being disposed.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Ignore``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Creates an asynchronous computation that runs the given computation and ignores 
 its result.</summary>
 <param name="computation">The input computation.</param>
 <returns>A computation that is equivalent to the input computation, but disregards the result.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromContinuations``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">
 <summary>Creates an asynchronous computation that captures the current
 success, exception and cancellation continuations. The callback must 
 eventually call exactly one of the given continuations.</summary>
 <param name="callback">The function that accepts the current success, exception, and cancellation
 continuations.</param>
 <returns>An asynchronous computation that provides the callback with the current continuations.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`5{``0,``1,``2,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``3},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overlaod should be used if the operation is 
 qualified by three arguments. For example, 
     <c>Async.FromBeginEnd(arg1,arg2,arg3,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>

 <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
 <param name="arg1">The first argument for the operation.</param>
 <param name="arg2">The second argument for the operation.</param>
 <param name="arg3">The third argument for the operation.</param>
 <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
 <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
 <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
 <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`4{``0,``1,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overlaod should be used if the operation is 
 qualified by two arguments. For example, 
     <c>Async.FromBeginEnd(arg1,arg2,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>

 <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
 <param name="arg1">The first argument for the operation.</param>
 <param name="arg2">The second argument for the operation.</param>
 <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
 <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
 <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
 <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{``0,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overlaod should be used if the operation is 
 qualified by one argument. For example, 
     <c>Async.FromBeginEnd(place,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>

 <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
 <param name="arg">The argument for the operation.</param>
 <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
 <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
 <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
 <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. For example, 
     <c>Async.FromBeginEnd(ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>

 <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
 <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
 <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
 <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
 <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Catch``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Creates an asynchronous computation that executes <c>computation</c>.
 If this computation completes successfully then return <c>Choice1Of2</c> with the returned
 value. If this computation raises an exception before it completes then return <c>Choice2Of2</c>
 with the raised exception.</summary>
 <param name="computation">The input computation that returns the type T.</param>
 <returns>A computation that returns a choice of type T or exception.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.CancelDefaultToken">
 <summary>Raises the cancellation condition for the most recent set of asynchronous computations started 
 without any specific CancellationToken. Replaces the global CancellationTokenSource with a new 
 global token source for any asynchronous computations created after this point without any 
 specific CancellationToken.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitWaitHandle(System.Threading.WaitHandle,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Creates an asynchronous computation that will wait on the given WaitHandle.</summary>

 <remarks>The computation returns true if the handle indicated a result within the given timeout.</remarks>
 <param name="waitHandle">The <c>WaitHandle</c> that can be signalled.</param>
 <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>An asynchronous computation that waits on the given <c>WaitHandle</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitTask``1(System.Threading.Tasks.Task{``0})">
<summary>
 Return an asynchronous computation that will wait for the given task to complete and return
 its result.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitIAsyncResult(System.IAsyncResult,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Creates an asynchronous computation that will wait on the IAsyncResult.</summary>

 <remarks>The computation returns true if the handle indicated a result within the given timeout.</remarks>
 <param name="iar">The IAsyncResult to wait on.</param>
 <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>An asynchronous computation that waits on the given <c>IAsyncResult</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitEvent``2(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Creates an asynchronous computation that waits for a single invocation of a CLI 
 event by adding a handler to the event. Once the computation completes or is 
 cancelled, the handler is removed from the event.</summary>

 <remarks>The computation will respond to cancellation while waiting for the event. If a 
 cancellation occurs, and <c>cancelAction</c> is specified, then it is executed, and 
 the computation continues to wait for the event.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to cancel immediately.</remarks>
 <param name="event">The event to handle once.</param>
 <param name="cancelAction">An optional function to execute instead of cancelling when a
 cancellation is issued.</param>
 <returns>An asynchronous computation that waits for the event to be invoked.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AsBeginEnd``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
 <summary>Creates three functions that can be used to implement the .NET Asynchronous 
 Programming Model (APM) for a given asynchronous computation.</summary>
 
 <remarks>The functions should normally be published as members with prefix <c>Begin</c>,
 <c>End</c> and <c>Cancel</c>, and can be used within a type definition as follows:
 <c>
   let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun arg -&gt; computation)
   member x.BeginSomeOperation(arg,callback,state:obj) = beginAction(arg,callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 </c>

 If the asynchronous computation takes no arguments, then AsBeginEnd is used as follows:
 <c>
   let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun () -&gt; computation)
   member x.BeginSomeOperation(callback,state:obj) = beginAction((),callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 </c>


 If the asynchronous computation takes two arguments, then AsBeginEnd is used as follows:
 <c>
   let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun arg1 arg2 -&gt; computation)
   member x.BeginSomeOperation(arg1,arg2,callback,state:obj) = beginAction((),callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 </c>

 In each case, the resulting API will be familiar to programmers in other CLI languages and 
 is a useful way to publish asynchronous computations in CLI components.</remarks>
 <param name="computation">A function generating the asynchronous computation to split into the traditional
 .NET Asynchronous Programming Model.</param>
 <returns>A tuple of the begin, end, and cancel members.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsync">
 <summary>This static class holds members for creating and manipulating asynchronous computations.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Zero">
 <summary>Creates an asynchronous computation that just returns <c>()</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of empty <c>else</c> branches in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <returns>An asynchronous computation that returns <c>()</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.While(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
 <summary>Creates an asynchronous computation that runs <c>computation</c> repeatedly 
 until <c>guard()</c> becomes false.</summary>

 <remarks>A cancellation check is performed whenever the computation is executed.

 The existence of this method permits the use of <c>while</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <param name="guard">The function to determine when to stop executing <c>computation</c>.</param>
 <param name="computation">The function to be executed.  Equivalent to the body
 of a <c>while</c> expression.</param>
 <returns>An asynchronous computation that behaves similarly to a while loop when run.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
 <summary>Creates an asynchronous computation that runs <c>binder(resource)</c>. 
 The action <c>resource.Dispose()</c> is executed as this computation yields its result
 or if the asynchronous computation exits by an exception or by cancellation.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>use</c> and <c>use!</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <param name="resource">The resource to be used and disposed.</param>
 <param name="binder">The function that takes the resource and returns an asynchronous
 computation.</param>
 <returns>An asynchronous computation that binds and eventually disposes <c>resource</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.TryWith``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Creates an asynchronous computation that runs <c>computation</c> and returns its result.
 If an exception happens then <c>catchHandler(exn)</c> is called and the resulting computation executed instead.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>try/with</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <param name="computation">The input computation.</param>
 <param name="catchHandler">The function to run when <c>computation</c> throws an exception.</param>
 <returns>An asynchronous computation that executes <c>computation</c> and calls <c>catchHandler</c> if an
 exception is thrown.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.TryFinally``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Creates an asynchronous computation that runs <c>computation</c>. The action <c>compensation</c> is executed 
 after <c>computation</c> completes, whether <c>computation</c> exits normally or by an exception. If <c>compensation</c> raises an exception itself
 the original exception is discarded and the new exception becomes the overall result of the computation.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>try/finally</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <param name="computation">The input computation.</param>
 <param name="compensation">The action to be run after <c>computation</c> completes or raises an
 exception (including cancellation).</param>
 <returns>An asynchronous computation that executes computation and compensation aftewards or
 when an exception is raised.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.ReturnFrom``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Delegates to the input computation.</summary>

 <remarks>The existence of this method permits the use of <c>return!</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <param name="computation">The input computation.</param>
 <returns>The input computation.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Return``1(``0)">
 <summary>Creates an asynchronous computation that returns the result <c>v</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>return</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <param name="value">The value to return from the computation.</param>
 <returns>An asynchronous computation that returns <c>value</c> when executed.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.For``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
 <summary>Creates an asynchronous computation that enumerates the sequence <c>seq</c>
 on demand and runs <c>body</c> for each element.</summary>

 <remarks>A cancellation check is performed on each iteration of the loop.

 The existence of this method permits the use of <c>for</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <param name="sequence">The sequence to enumerate.</param>
 <param name="body">A function to take an item from the sequence and create
 an asynchronous computation.  Can be seen as the body of the <c>for</c> expression.</param>
 <returns>An asynchronous computation that will enumerate the sequence and run <c>body</c>
 for each element.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Delay``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Creates an asynchronous computation that runs <c>generator</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.</remarks>
 <param name="generator">The function to run.</param>
 <returns>An asynchronous computation that runs <c>generator</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Combine``1(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Creates an asynchronous computation that first runs <c>computation1</c>
 and then runs <c>computation2</c>, returning the result of <c>computation2</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of expression sequencing in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <param name="computation1">The first part of the sequenced computation.</param>
 <param name="computation2">The second part of the sequenced computation.</param>
 <returns>An asynchronous computation that runs both of the computations sequentially.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Bind``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
 <summary>Creates an asynchronous computation that runs <c>computation</c>, and when 
 <c>computation</c> generates a result <c>T</c>, runs <c>binder res</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>let!</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <param name="computation">The computation to provide an unbound result.</param>
 <param name="binder">The function to bind the result of <c>computation</c>.</param>
 <returns>An asynchronous computation that performs a monadic bind on the result
 of <c>computation</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.#ctor">
<summary>
 Generate an object used to build asynchronous computations using F# computation expressions. The value
 &apos;async&apos; is a pre-defined instance of this type.

 A cancellation check is performed when the computation is executed.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsyncBuilder">
 <summary>The type of the <c>async</c> operator, used to build workflows for asynchronous computations.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncReplyChannel`1.Reply(`0)">
 <summary>Sends a reply to a PostAndReply message.</summary>
 <param name="value">The value to send.</param>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsyncReplyChannel`1">
 <summary>A handle to a capability to reply to a PostAndReply message.</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsync`1">
 <summary>A compositional asynchronous computation, which, when run, will eventually produce a value 
 of type T, or else raises an exception.</summary> 

 <remarks>Asynchronous computations are normally specified using an F# computation expression.

 When run, asynchronous computations have two modes: as a work item (executing synchronous 
 code), or as a wait item (waiting for an event or I/O completion). 

 When run, asynchronous computations can be governed by CancellationToken. This can usually 
 be specified when the async computation is started. The associated CancellationTokenSource 
 may be used to cancel the asynchronous computation. Asynchronous computations built using 
 computation expressions can check the cancellation condition regularly. Synchronous 
 computations within an asynchronous computation do not automatically check this condition.</remarks> 
</member>
<member name="P:Microsoft.FSharp.Control.FSharpDelegateEvent`1.Publish">
 <summary>Publishes the event as a first class event value.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpDelegateEvent`1.Trigger(System.Object[])">
 <summary>Triggers the event using the given parameters.</summary>
 <param name="args">The parameters for the event.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpDelegateEvent`1.#ctor">
 <summary>Creates an event object suitable for implementing an arbitrary type of delegate.</summary>
 <returns>The event object.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpDelegateEvent`1">
 <summary>Event implementations for an arbitrary type of delegate.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpEvent`1.Publish">
 <summary>Publishes an observation  as a first class value.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`1.Trigger(`0)">
 <summary>Triggers an observation using the given parameters.</summary>
 <param name="arg">The event parameters.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`1.#ctor">
 <summary>Creates an observable object.</summary>
 <returns>The created event.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpEvent`1">
 <summary>Event implementations for the IEvent&lt;_&gt; type.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpEvent`2.Publish">
 <summary>Publishes the event as a first class event value.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`2.Trigger(System.Object,`1)">
 <summary>Triggers the event using the given sender object and parameters. The sender object may be <c>null</c>.</summary>
 <param name="sender">The object triggering the event.</param>
 <param name="args">The parameters for the event.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`2.#ctor">
 <summary>Creates an event object suitable for delegate types following the standard .NET Framework convention of a first 'sender' argument.</summary>
 <returns>The created event.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpEvent`2">
 <summary>Event implementations for a delegate types following the standard .NET Framework convention of a first 'sender' argument.</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Control.FSharpHandler`1">
 <summary>A delegate type associated with the F# event type <c>IEvent&lt;_&gt;</c></summary>
 <param name="obj">The object that fired the event.</param>
 <param name="args">The event arguments.</param>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.RemoveHandler(`0)">
 <summary>Remove a listener delegate from an event listener store.</summary>
 <param name="handler">The delegate to be removed from the event listener store.</param>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.AddHandler(`0)">
 <summary>Connect a handler delegate object to the event. A handler can
 be later removed using RemoveHandler. The listener will
 be invoked when the event is fired.</summary>
 <param name="handler">A delegate to be invoked when the event is fired.</param>
</member>
<member name="T:Microsoft.FSharp.Control.IDelegateEvent`1">
 <summary>First class event values for arbitrary delegate types.</summary>

 <remarks>F# gives special status to member properties compatible with type IDelegateEvent and 
 tagged with the CLIEventAttribute. In this case the F# compiler generates approriate 
 CLI metadata to make the member appear to other CLI languages as a CLI event.</remarks>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`1">
 <summary>First-class listening points (i.e. objects that permit you to register a callback
 activated when the event is triggered). </summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`2">
 <summary>First class event values for CLI events conforming to CLI Framework standards.</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Lazy`1">
 <summary>The type of delayed computations.</summary>
 
 <remarks>Use the values in the <c>Lazy</c> module to manipulate 
 values of this type, and the notation <c>lazy expr</c> to create values
 of type <see cref="System.Lazy{T}" />.</remarks>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.DefaultTimeout(System.Int32)">
 <summary>Raises a timeout exception if a message not received in this amount of time. By default
 no timeout is used.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.remove_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
 <summary>Occurs when the execution of the agent results in an exception.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Error">
 <summary>Occurs when the execution of the agent results in an exception.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.DefaultTimeout">
 <summary>Raises a timeout exception if a message not received in this amount of time. By default
 no timeout is used.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.CurrentQueueLength">
 <summary>Returns the number of unprocessed messages in the message queue of the agent.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.add_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
 <summary>Occurs when the execution of the agent results in an exception.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryScan``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Scans for a message by looking through messages in arrival order until <c>scanner</c> 
 returns a Some value. Other messages remain in the queue.</summary>

 <remarks>This method is for use within the body of the agent. For each agent, at most 
 one concurrent reader may be active, so no more than one concurrent call to 
 Receive, TryReceive, Scan and/or TryScan may be active.</remarks>
 <param name="scanner">The function to return None if the message is to be skipped
 or Some if the message is to be processed and removed from the queue.</param>
 <param name="timeout">An optional timeout in milliseconds. Defaults to -1 which corresponds
 to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>An asynchronous computation that <c>scanner</c> built off the read message.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryReceive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Waits for a message. This will consume the first message in arrival order.</summary> 

 <remarks>This method is for use within the body of the agent. 

 Returns None if a timeout is given and the timeout is exceeded.

 This method is for use within the body of the agent. For each agent, at most 
 one concurrent reader may be active, so no more than one concurrent call to 
 Receive, TryReceive, Scan and/or TryScan may be active.</remarks>
 <param name="timeout">An optional timeout in milliseconds. Defaults to -1 which
 corresponds to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>An asynchronous computation that returns the received message or
 None if the timeout is exceeded.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryPostAndReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Like PostAndReply, but returns None if no reply within the timeout period.</summary>
 <param name="buildMessage">The function to incorporate the AsyncReplyChannel into
 the message to be sent.</param>
 <param name="timeout">An optional timeout parameter (in milliseconds) to wait for a reply message.
 Defaults to -1 which corresponds to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>The reply from the agent or None if the timeout expires.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Start">
 <summary>Starts the agent.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Start(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Creates and starts an agent. The <c>body</c> function is used to generate the asynchronous 
 computation executed by the agent.</summary>
 <param name="body">The function to produce an asynchronous computation that will be executed
 as the read loop for the MailboxProcessor when Start is called.</param>
 <param name="cancellationToken">An optional cancellation token for the <c>body</c>.
 Defaults to <c>Async.DefaultCancellationToken</c>.</param>
 <returns>The created MailboxProcessor.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Scan``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Scans for a message by looking through messages in arrival order until <c>scanner</c> 
 returns a Some value. Other messages remain in the queue.</summary>

 <remarks>Returns None if a timeout is given and the timeout is exceeded.

 This method is for use within the body of the agent. For each agent, at most 
 one concurrent reader may be active, so no more than one concurrent call to 
 Receive, TryReceive, Scan and/or TryScan may be active.</remarks>
 <param name="scanner">The function to return None if the message is to be skipped
 or Some if the message is to be processed and removed from the queue.</param>
 <param name="timeout">An optional timeout in milliseconds. Defaults to -1 which corresponds
 to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>An asynchronous computation that <c>scanner</c> built off the read message.</returns>
 <exception cref="System.TimeoutException">Thrown when the timeout is exceeded.</exception>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Receive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Waits for a message. This will consume the first message in arrival order.</summary> 

 <remarks>This method is for use within the body of the agent. 

 This method is for use within the body of the agent. For each agent, at most 
 one concurrent reader may be active, so no more than one concurrent call to 
 Receive, TryReceive, Scan and/or TryScan may be active.</remarks>
 <param name="timeout">An optional timeout in milliseconds. Defaults to -1 which corresponds
 to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>An asynchronous computation that returns the received message.</returns>
 <exception cref="System.TimeoutException">Thrown when the timeout is exceeded.</exception>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndTryAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Like AsyncPostAndReply, but returns None if no reply within the timeout period.</summary>
 <param name="buildMessage">The function to incorporate the AsyncReplyChannel into
 the message to be sent.</param>
 <param name="timeout">An optional timeout parameter (in milliseconds) to wait for a reply message.
 Defaults to -1 which corresponds to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>An asynchronous computation that will return the reply or None if the timeout expires.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Posts a message to an agent and await a reply on the channel, synchronously.</summary>

 <remarks>The message is generated by applying <c>buildMessage</c> to a new reply channel 
 to be incorporated into the message. The receiving agent must process this 
 message and invoke the Reply method on this reply channel precisely once.</remarks>
 <param name="buildMessage">The function to incorporate the AsyncReplyChannel into
 the message to be sent.</param>
 <param name="timeout">An optional timeout parameter (in milliseconds) to wait for a reply message.
 Defaults to -1 which corresponds to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>The reply from the agent.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Posts a message to an agent and await a reply on the channel, asynchronously.</summary> 

 <remarks>The message is generated by applying <c>buildMessage</c> to a new reply channel 
 to be incorporated into the message. The receiving agent must process this 
 message and invoke the Reply method on this reply channel precisely once.</remarks>
 <param name="buildMessage">The function to incorporate the AsyncReplyChannel into
 the message to be sent.</param>
 <param name="timeout">An optional timeout parameter (in milliseconds) to wait for a reply message.
 Defaults to -1 which corresponds to <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>An asychronous computation that will wait for the reply from the agent.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Post(`0)">
 <summary>Posts a message to the message queue of the MailboxProcessor, asynchronously.</summary>
 <param name="message">The message to post.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.#ctor(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Creates an agent. The <c>body</c> function is used to generate the asynchronous 
 computation executed by the agent. This function is not executed until 
 <c>Start</c> is called.</summary>
 <param name="body">The function to produce an asynchronous computation that will be executed
 as the read loop for the MailboxProcessor when Start is called.</param>
 <param name="cancellationToken">An optional cancellation token for the <c>body</c>.
 Defaults to <c>Async.DefaultCancellationToken</c>.</param>
 <returns>The created MailboxProcessor.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpMailboxProcessor`1">
 <summary>A message-processing agent which executes an asynchronous computation.</summary>

 <remarks>The agent encapsulates a message queue that supports multiple-writers and 
 a single reader agent. Writers send messages to the agent by using the Post 
 method and its variations.

 The agent may wait for messages using the Receive or TryReceive methods or
 scan through all available messages using the Scan or TryScan method.</remarks>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.SubscribeToObservable``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Connects a listener function to the observable. The listener will
 be invoked for each observation. The listener can be removed by
 calling Dispose on the returned IDisposable object.</summary>
 <param name="callback">The function to be called for each observation.</param>
 <returns>An object that will remove the listener if disposed.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AddToObservable``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Permanently connects a listener function to the observable. The listener will
 be invoked for each observation.</summary>
 <param name="callback">The function to be called for each observation.</param>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AsyncWrite(System.IO.Stream,System.Byte[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Returns an asynchronous computation that will write the given bytes to the stream.</summary>
 <param name="buffer">The buffer to write from.</param>
 <param name="offset">An optional offset as a number of bytes in the stream.</param>
 <param name="count">An optional number of bytes to write to the stream.</param>
 <returns>An asynchronous computation that will write the given bytes to the stream.</returns>
 <exception cref="System.ArgumentException">Thrown when the sum of offset and count is longer than
 the buffer length.</exception>
 <exception cref="System.ArgumentOutOfRangeException">Thrown when offset or count is negative.</exception>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AsyncReadBytes(System.IO.Stream,System.Int32)">
 <summary>Returns an asynchronous computation that will read the given number of bytes from the stream.</summary>
 <param name="count">The number of bytes to read.</param>
 <returns>An asynchronous computation that returns the read byte[] when run.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AsyncRead(System.IO.Stream,System.Byte[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Returns an asynchronous computation that will read from the stream into the given buffer.</summary>
 <param name="buffer">The buffer to read into.</param>
 <param name="offset">An optional offset as a number of bytes in the stream.</param>
 <param name="count">An optional number of bytes to read from the stream.</param>
 <returns>An asynchronous computation that will read from the stream into the given buffer.</returns>
 <exception cref="System.ArgumentException">Thrown when the sum of offset and count is longer than
 the buffer length.</exception>
 <exception cref="System.ArgumentOutOfRangeException">Thrown when offset or count is negative.</exception>
</member>
<member name="T:Microsoft.FSharp.Control.CommonExtensions">
 <summary>A module of extension members providing asynchronous operations for some basic CLI types related to concurrency and I/O.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Pairwise``2(Microsoft.FSharp.Control.IEvent{``0,``1})">
 <summary>Returns a new event that triggers on the second and subsequent triggerings of the input event.
 The Nth triggering of the input event passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
 Nth triggering occurs.</summary>
 <param name="sourceEvent">The input event.</param>
 <returns>An event that triggers on pairs of consecutive values passed from the source event.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Add``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.IEvent{``1,``0})">
 <summary>Runs the given function each time the given event is triggered.</summary>
 <param name="callback">The function to call when the event is triggered.</param>
 <param name="sourceEvent">The input event.</param>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Scan``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Control.IEvent{``2,``1})">
 <summary>Returns a new event consisting of the results of applying the given accumulating function
 to successive values triggered on the input event.  An item of internal state
 records the current value of the state parameter.  The internal state is not locked during the
 execution of the accumulation function, so care should be taken that the 
 input IEvent not triggered by multiple threads simultaneously.</summary>
 <param name="collector">The function to update the state with each event value.</param>
 <param name="state">The initial state.</param>
 <param name="sourceEvent">The input event.</param>
 <returns>An event that fires on the updated state values.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Control.IEvent{``2,``0})">
 <summary>Returns a new event which fires on a selection of messages from the original event.
 The selection function takes an original message to an optional new message.</summary>
 <param name="chooser">The function to select and transform event values to pass on.</param>
 <param name="sourceEvent">The input event.</param>
 <returns>An event that fires only when the chooser returns Some.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Split``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Control.IEvent{``3,``0})">
 <summary>Returns a new event that listens to the original event and triggers the 
 first resulting event if the application of the function to the event arguments
 returned a Choice1Of2, and the second event if it returns a Choice2Of2.</summary>
 <param name="splitter">The function to transform event values into one of two types.</param>
 <param name="sourceEvent">The input event.</param>
 <returns>A tuple of events.  The first fires whenever <c>splitter</c> evaluates to Choice1of1 and
 the second fires whenever <c>splitter</c> evaluates to Choice2of2.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})">
 <summary>Returns a new event that listens to the original event and triggers the 
 first resulting event if the application of the predicate to the event arguments
 returned true, and the second event if it returned false.</summary>
 <param name="predicate">The function to determine which output event to trigger.</param>
 <param name="sourceEvent">The input event.</param>
 <returns>A tuple of events.  The first is triggered when the predicate evaluates to true
 and the second when the predicate evaluates to false.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})">
 <summary>Returns a new event that listens to the original event and triggers the resulting
 event only when the argument to the event passes the given function.</summary>
 <param name="predicate">The function to determine which triggers from the event to propagate.</param>
 <param name="sourceEvent">The input event.</param>
 <returns>An event that only passes values that pass the predicate.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``0})">
 <summary>Returns a new event that passes values transformed by the given function.</summary>
 <param name="map">The function to transform event values.</param>
 <param name="sourceEvent">The input event.</param>
 <returns>An event that passes the transformed values.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Merge``3(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``1})">
 <summary>Fires the output event when either of the input events fire.</summary>
 <param name="event1">The first input event.</param>
 <param name="event2">The second input event.</param>
 <returns>An event that fires when either of the input events fire.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.EventModule">

</member>
<member name="M:Microsoft.FSharp.Control.LazyExtensions.Force``1(System.Lazy{``0})">
 <summary>Forces the execution of this value and return its result. Same as Value. Mutual exclusion is used to 
 prevent other threads also computing the value.</summary>
 <returns>The value of the Lazy object.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.LazyExtensions.CreateFromValue``1(``0)">
 <summary>Creates a lazy computation that evaluates to the given value when forced.</summary>
 <param name="value">The input value.</param>
 <returns>The created Lazy object.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.LazyExtensions.Create``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0})">
 <summary>Creates a lazy computation that evaluates to the result of the given function when forced.</summary>
 <param name="creator">The function to provide the value when needed.</param>
 <returns>The created Lazy object.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.LazyExtensions">
 <summary>Extensions related to Lazy values.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Pairwise``1(System.IObservable{``0})">
 <summary>Returns a new observable that triggers on the second and subsequent triggerings of the input observable.
 The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
 Nth triggering occurs.</summary>

 <remarks>For each observer, the registered intermediate observing object is not thread safe.
 That is, observations arising from the source must not be triggered concurrently 
 on different threads.</remarks>
 <param name="source">The input Observable.</param>
 <returns>An Observable that triggers on successive pairs of observations from the input Observable.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Subscribe``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
 <summary>Creates an observer which subscribes to the given observable and which calls
 the given function for each observation.</summary>
 <param name="callback">The function to be called on each observation.</param>
 <param name="source">The input Observable.</param>
 <returns>An object that will remove the callback if disposed.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Add``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
 <summary>Creates an observer which permanently subscribes to the given observable and which calls
 the given function for each observation.</summary>
 <param name="callback">The function to be called on each observation.</param>
 <param name="source">The input Observable.</param>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,System.IObservable{``1})">
 <summary>Returns an observable which, for each observer, allocates an item of state
 and applies the given accumulating function to successive values arising from
 the input. The returned object will trigger observations for each computed 
 state value, excluding the initial value. The returned object propagates 
 all errors arising from the source and completes when the source completes.</summary>

 <remarks>For each observer, the registered intermediate observing object is not thread safe.
 That is, observations arising from the source must not be triggered concurrently 
 on different threads.</remarks>
 <param name="collector">The function to update the state with each observation.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input Observable.</param>
 <returns>An Observable that triggers on the updated state values.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.IObservable{``0})">
 <summary>Returns an observable which chooses a projection of observations from the source 
 using the given function. The returned object will trigger observations <c>x</c>
 for which the splitter returns <c>Some x</c>. The returned object also propagates 
 all errors arising from the source and completes when the source completes.</summary>
 <param name="chooser">The function that returns Some for observations to be propagated
 and None for observations to ignore.</param>
 <param name="source">The input Observable.</param>
 <returns>An Observable that only propagates some of the observations from the source.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Split``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},System.IObservable{``0})">
 <summary>Returns two observables which split the observations of the source by the 
 given function. The first will trigger observations <c>x</c> for which the 
 splitter returns <c>Choice1Of2 x</c>. The second will trigger observations 
 <c>y</c> for which the splitter returns <c>Choice2Of2 y</c> The splitter is 
 executed once for each subscribed observer. Both also propagate error 
 observations arising from the source and each completes when the source 
 completes.</summary>
 <param name="splitter">The function that takes an observation an transforms
 it into one of the two output Choice types.</param>
 <param name="source">The input Observable.</param>
 <returns>A tuple of Observables.  The first triggers when <c>splitter</c> returns Choice1of2
 and the second triggers when <c>splitter</c> returns Choice2of2.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.IObservable{``0})">
 <summary>Returns two observables which partition the observations of the source by 
 the given function. The first will trigger observations for those values 
 for which the predicate returns true. The second will trigger observations 
 for those values where the predicate returns false. The predicate is 
 executed once for each subscribed observer. Both also propagate all error 
 observations arising from the source and each completes when the source 
 completes.</summary>
 <param name="predicate">The function to determine which output Observable will trigger
 a particular observation.</param>
 <param name="source">The input Observable.</param>
 <returns>A tuple of Observables.  The first triggers when the predicate returns true, and
 the second triggers when the predicate returns false.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.IObservable{``0})">
 <summary>Returns an observable which filters the observations of the source 
 by the given function. The observable will see only those observations
 for which the predicate returns true. The predicate is executed once for 
 each subscribed observer. The returned object also propagates error 
 observations arising from the source and completes when the source completes.</summary>
 <param name="filter">The function to apply to observations to determine if it should
 be kept.</param>
 <param name="source">The input Observable.</param>
 <returns>An Observable that filters observations based on <c>filter</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.IObservable{``0})">
 <summary>Returns an observable which transforms the observations of the source by the 
 given function. The transformation function is executed once for each 
 subscribed observer. The returned object also propagates error observations 
 arising from the source and completes when the source completes.</summary>
 <param name="mapping">The function applied to observations from the source.</param>
 <param name="source">The input Observable.</param>
 <returns>An Observable of the type specified by <c>mapping</c>.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Merge``1(System.IObservable{``0},System.IObservable{``0})">
 <summary>Returns an observable for the merged observations from the sources. 
 The returned object propagates success and error values arising 
 from either source and completes when both the sources have completed.</summary>

 <remarks>For each observer, the registered intermediate observing object is not 
 thread safe. That is, observations arising from the sources must not 
 be triggered concurrently on different threads.</remarks>
 <param name="source1">The first Observable.</param>
 <param name="source2">The second Observable.</param>
 <returns>An Observable that propagates information from both sources.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.ObservableModule">
 <summary>Basic operations on first class event and other observable objects.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebExtensions.AsyncDownloadString(System.Net.WebClient,System.Uri)">
 <summary>Returns an asynchronous computation that, when run, will wait for the download of the given URI.</summary>
 <param name="address">The URI to retrieve.</param>
 <returns>An asynchronous computation that will wait for the download of the URI.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.WebExtensions.AsyncGetResponse(System.Net.WebRequest)">
 <summary>Returns an asynchronous computation that, when run, will wait for a response to the given WebRequest.</summary>
 <returns>An asynchronous computation that waits for response to the <c>WebRequest</c>.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.WebExtensions">
 <summary>A module of extension members providing asynchronous operations for some basic Web operations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AbstractClassAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>AbstractClassAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AbstractClassAttribute">
 <summary>Adding this attribute to class definition makes it abstract, which means it need not
 implement all its methods. Instances of abstract classes may not be constructed directly.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AllowNullLiteralAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>AllowNullLiteralAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AllowNullLiteralAttribute">
 <summary>Adding this attribute to a type lets the 'null' literal be used for the type 
 within F# code. This attribute may only be added to F#-defined class or 
 interface types.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.AutoOpenAttribute.Path">
 <summary>Indicates the namespace or module to be automatically opened when an assembly is referenced
 or an enclosing module opened.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute.#ctor(System.String)">
 <summary>Creates an attribute used to mark a namespace or module path to be 'automatically opened' when an assembly is referenced</summary>
 <param name="path">The namespace or module to be automatically opened when an assembly is referenced
 or an enclosing module opened.</param>
 <returns>AutoOpenAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute.#ctor">
 <summary>Creates an attribute used to mark a module as 'automatically opened' when the enclosing namespace is opened</summary>
 <returns>AutoOpenAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AutoOpenAttribute">
 <summary>This attribute is used for two purposes. When applied to an assembly, it must be given a string
 argument, and this argument must indicate a valid module or namespace in that assembly. Source
 code files compiled with a reference to this assembly are processed in an environment
 where the given path is automatically oepned.</summary>

 <remarks>When applied to a module within an assembly, then the attribute must not be given any arguments.
 When the enclosing namespace is opened in user source code, the module is also implicitly opened.</remarks>
</member>
<member name="P:Microsoft.FSharp.Core.AutoSerializableAttribute.Value">
 <summary>The value of the attribute, indicating whether the type is automatically marked serializable or not</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoSerializableAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute</summary>
 <param name="value">Indicates whether the type should be serializable by default.</param>
 <returns>AutoSerializableAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AutoSerializableAttribute">
 <summary>Adding this attribute to a type with value 'false' disables the behaviour where F# makes the
 type Serializable by default.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CLIEventAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>CLIEventAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CLIEventAttribute">
 <summary>Adding this attribute to a property with event type causes it to be compiled with as a CLI
 metadata event, through a syntactic translation to a pair of 'add_EventName' and 
 'remove_EventName' methods.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2.Choice2Of2">
 <summary>Choice 2 of 2 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2.Choice1Of2">
 <summary>Choice 1 of 2 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2">
 <summary>Helper types for active patterns with 2 choices.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3.Choice3Of3">
 <summary>Choice 3 of 3 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3.Choice2Of3">
 <summary>Choice 2 of 3 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3.Choice1Of3">
 <summary>Choice 1 of 3 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3">
 <summary>Helper types for active patterns with 3 choices.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice4Of4">
 <summary>Choice 4 of 4 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice3Of4">
 <summary>Choice 3 of 4 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice2Of4">
 <summary>Choice 2 of 4 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice1Of4">
 <summary>Choice 1 of 4 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4">
 <summary>Helper types for active patterns with 4 choices.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice5Of5">
 <summary>Choice 5 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice4Of5">
 <summary>Choice 4 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice3Of5">
 <summary>Choice 3 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice2Of5">
 <summary>Choice 2 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice1Of5">
 <summary>Choice 1 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5">
 <summary>Helper types for active patterns with 5 choices.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice6Of6">
 <summary>Choice 6 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice5Of6">
 <summary>Choice 5 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice4Of6">
 <summary>Choice 4 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice3Of6">
 <summary>Choice 3 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice2Of6">
 <summary>Choice 2 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice1Of6">
 <summary>Choice 1 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6">
 <summary>Helper types for active patterns with 6 choices.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice7Of7">
 <summary>Choice 7 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice6Of7">
 <summary>Choice 6 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice5Of7">
 <summary>Choice 5 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice4Of7">
 <summary>Choice 4 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice3Of7">
 <summary>Choice 3 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice2Of7">
 <summary>Choice 2 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice1Of7">
 <summary>Choice 1 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7">
 <summary>Helper types for active patterns with 7 choices.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ClassAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>ClassAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ClassAttribute">
 <summary>Adding this attribute to a type causes it to be represented using a CLI class.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ComparisonConditionalOnAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>ComparisonConditionalOnAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ComparisonConditionalOnAttribute">
 <summary>This attribute is used to indicate a generic container type satisfies the F# 'comparison' 
 constraint only if a generic argument also satisfies this constraint. For example, adding 
 this attribute to parameter 'T on a type definition C&lt;'T&gt; means that a type C&lt;X&gt; only supports 
 comparison if the type X also supports comparison and all other conditions for C&lt;X&gt; to support 
 comparison are also met. The type C&lt;'T&gt; can still be used with other type arguments, but a type such 
 as C&lt;(int -> int)&gt; will not support comparison because the type (int -> int) is an F# function type 
 and does not support comparison.</summary>

 <remarks>This attribute will be ignored if it is used on the generic parameters of functions or methods.</remarks>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute.Counts">
 <summary>Indicates the number of arguments in each argument group </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute.#ctor(System.Int32[])">
 <summary>Creates an instance of the attribute</summary>
 <param name="counts">Indicates the number of arguments in each argument group.</param>
 <returns>CompilationArgumentCountsAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute">
 <summary>This attribute is generated automatically by the F# compiler to tag functions and members 
 that accept a partial application of some of their arguments and return a residual function</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.VariantNumber">
 <summary>Indicates the variant number of the entity, if any, in a linear sequence of elements with F# source code</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SourceConstructFlags">
 <summary>Indicates the relationship between the compiled entity and F# source code</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SequenceNumber">
 <summary>Indicates the sequence number of the entity, if any, in a linear sequence of elements with F# source code</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32,System.Int32)">
 <summary>Creates an instance of the attribute</summary>
 <param name="sourceConstructFlags">Indicates the type of source construct.</param>
 <returns>CompilationMappingAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32)">
 <summary>Creates an instance of the attribute</summary>
 <param name="sourceConstructFlags">Indicates the type of source construct.</param>
 <returns>CompilationMappingAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(Microsoft.FSharp.Core.SourceConstructFlags)">
 <summary>Creates an instance of the attribute</summary>
 <param name="sourceConstructFlags">Indicates the type of source construct.</param>
 <returns>CompilationMappingAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationMappingAttribute">
 <summary>This attribute is inserted automatically by the F# compiler to tag types 
 and methods in the generated CLI code with flags indicating the correspondence 
 with original source constructs. It is used by the functions in the 
 Microsoft.FSharp.Reflection namespace to reverse-map compiled constructs to 
 their original forms. It is not intended for use from user code.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationRepresentationAttribute.Flags">
 <summary>Indicates one or more adjustments to the compiled representation of an F# type or member</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationRepresentationAttribute.#ctor(Microsoft.FSharp.Core.CompilationRepresentationFlags)">
 <summary>Creates an instance of the attribute</summary>
 <param name="flags">Indicates adjustments to the compiled representation of the type or member.</param>
 <returns>CompilationRepresentationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationAttribute">
 <summary>This attribute is used to adjust the runtime representation for a type. 
 For example, it may be used to note that the <c>null</c> representation
 may be used for a type. This affects how some constructs are compiled.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.CompilationRepresentationFlags.Event">
 <summary>Compile a property as a CLI event.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.CompilationRepresentationFlags.UseNullAsTrueValue">
 <summary>Permit the use of <c>null</c> as a representation for nullary discriminators in a discriminated union.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix">
 <summary>append 'Module' to the end of a module whose name clashes with a type name in the same namespace.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.CompilationRepresentationFlags.Instance">
 <summary>Compile a member as 'instance' even if <c>null</c> is used as a representation for this type.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.CompilationRepresentationFlags.Static">
 <summary>Compile an instance member as 'static' .</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.CompilationRepresentationFlags.None">
 <summary>No special compilation representation.</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationFlags">
 <summary>Indicates one or more adjustments to the compiled representation of an F# type or member.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationSourceNameAttribute.SourceName">
 <summary>Indicates the name of the entity in F# source code</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationSourceNameAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>
 <param name="sourceName">The name of the method in source.</param>
 <returns>CompilationSourceNameAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationSourceNameAttribute">
 <summary>This attribute is inserted automatically by the F# compiler to tag 
 methods which are given the 'CompiledName' attribute. It is not intended 
 for use from user code.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompiledNameAttribute.CompiledName">
 <summary>The name of the value as it appears in compiled code</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompiledNameAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>
 <param name="compiledName">The name to use in compiled code.</param>
 <returns>CompiledNameAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompiledNameAttribute">
 <summary>Adding this attribute to a value or function definition in an F# module changes the name used
 for the value in compiled CLI code.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsHidden(System.Boolean)">
 <summary>Indicates if the construct should always be hidden in an editing environment.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsError(System.Boolean)">
 <summary>Indicates if the message should indicate a compiler error. Error numbers less than
 10000 are considered reserved for use by the F# compiler and libraries.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.MessageNumber">
 <summary>Indicates the number associated with the message.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.Message">
 <summary>Indicates the warning message to be emitted when F# source code uses this construct</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsHidden">
 <summary>Indicates if the construct should always be hidden in an editing environment.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsError">
 <summary>Indicates if the message should indicate a compiler error. Error numbers less than
 10000 are considered reserved for use by the F# compiler and libraries.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerMessageAttribute.#ctor(System.String,System.Int32)">
 <summary>Creates an instance of the attribute.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerMessageAttribute">
 <summary>Indicates that a message should be emitted when F# source code uses this construct.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CustomComparisonAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>CustomComparisonAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CustomComparisonAttribute">
 <summary>Adding this attribute to a type indicates it is a type with a user-defined implementation of comparison.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CustomEqualityAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>CustomEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CustomEqualityAttribute">
 <summary>Adding this attribute to a type indicates it is a type with a user-defined implementation of equality.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultAugmentationAttribute.Value">
 <summary>The value of the attribute, indicating whether the type has a default augmentation or not</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultAugmentationAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute</summary>
 <param name="value">Indicates whether to generate helper members on the CLI class representing a discriminated
 union.</param>
 <returns>DefaultAugmentationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultAugmentationAttribute">
 <summary>Adding this attribute to a discriminated union with value false
 turns off the generation of standard helper member tester, constructor 
 and accessor members for the generated CLI class for that type.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultValueAttribute.Check">
 <summary>Indicates if a constraint is asserted that the field type supports 'null'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute</summary>
 <param name="check">Indicates whether to assert that the field type supports <c>null</c>.</param>
 <returns>DefaultValueAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>DefaultValueAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultValueAttribute">
 <summary>Adding this attribute to a field declaration means that the field is 
 not initialized. During type checking a constraint is asserted that the field type supports 'null'. 
 If the 'check' value is false then the constraint is not asserted. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.EntryPointAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>EntryPointAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.EntryPointAttribute">
 <summary>Adding this attribute to a function indicates it is the entrypoint for an application.
 If this absent is not speficied for an EXE then the initialization implicit in the
 module bindings in the last file in the compilation sequence are used as the entrypoint.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.EqualityConditionalOnAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>EqualityConditionalOnAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.EqualityConditionalOnAttribute">
 <summary>This attribute is used to indicate a generic container type satisfies the F# 'equality' 
 constraint only if a generic argument also satisfies this constraint. For example, adding 
 this attribute to parameter 'T on a type definition C&lt;'T&gt; means that a type C&lt;X&gt; only supports 
 equality if the type X also supports equality and all other conditions for C&lt;X&gt; to support 
 equality are also met. The type C&lt;'T&gt; can still be used with other type arguments, but a type such 
 as C&lt;(int -> int)&gt; will not support equality because the type (int -> int) is an F# function type 
 and does not support equality.</summary>

 <remarks>This attribute will be ignored if it is used on the generic parameters of functions or methods.</remarks>
</member>
<member name="P:Microsoft.FSharp.Core.ExperimentalAttribute.Message">
 <summary>Indicates the warning message to be emitted when F# source code uses this construct</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExperimentalAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>
 <param name="message">The warning message to be emitted when code uses this construct.</param>
 <returns>ExperimentalAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ExperimentalAttribute">
 <summary>This attribute is used to tag values that are part of an experimental library
 feature.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.op_Implicit(System.Converter{`0,`1})">
 <summary>Convert an value of type <c>System.Converter</c> to a F# first class function value </summary>
 <param name="converter">The input System.Converter.</param>
 <returns>An F# function of the same type.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.op_Implicit(Microsoft.FSharp.Core.FSharpFunc`2{`0,`1})">
 <summary>Convert an F# first class function value to a value of type <c>System.Converter</c></summary>
 <param name="func">The input function.</param>
 <returns>A System.Converter of the function type.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.ToConverter(Microsoft.FSharp.Core.FSharpFunc`2{`0,`1})">
 <summary>Convert an F# first class function value to a value of type <c>System.Converter</c></summary>
 <param name="func">The input function.</param>
 <returns>System.Converter&lt;'T,'U&gt;</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,``0}},`0,`1)">
 <summary>Invoke an F# first class function value with two curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.</summary>
 <param name="func">The input function.</param>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}}},`0,`1,``0)">
 <summary>Invoke an F# first class function value with three curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.</summary>
 <param name="func">The input function.</param>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``3(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}}},`0,`1,``0,``1)">
 <summary>Invoke an F# first class function value with four curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.</summary>
 <param name="func">The input function.</param>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <param name="arg4">The fourth arg.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``4(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}}}}},`0,`1,``0,``1,``2)">
 <summary>Invoke an F# first class function value with five curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.</summary>
 <param name="func">The input function.</param>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <param name="arg4">The fourth arg.</param>
 <param name="arg5">The fifth arg.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.Invoke(`0)">
 <summary>Invoke an F# first class function value with one argument</summary>
 <param name="func"></param>
 <returns>'U</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.FromConverter(System.Converter{`0,`1})">
 <summary>Convert an value of type <c>System.Converter</c> to a F# first class function value </summary>
 <param name="converter">The input System.Converter.</param>
 <returns>An F# function of the same type.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.#ctor">
 <summary>Construct an instance of an F# first class function value </summary>
 <returns>The created F# function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpFunc`2">
 <summary>The CLI type used to represent F# function values. This type is not
 typically used directly, though may be used from other CLI languages.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Release">
 <summary>The release number of the F# version associated with the attribute</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Minor">
 <summary>The minor version number of the F# version associated with the attribute</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Major">
 <summary>The major version number of the F# version associated with the attribute</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.#ctor(System.Int32,System.Int32,System.Int32)">
 <summary>Creates an instance of the attribute</summary>
 <param name="major">The major version number.</param>
 <param name="minor">The minor version number.</param>
 <param name="release">The release number.</param>
 <returns>FSharpInterfaceDataVersionAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute">
 <summary>This attribute is added to generated assemblies to indicate the 
 version of the data schema used to encode additional F#
 specific information in the resource attached to compiled F# libraries.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpTypeFunc.Specialize``1">
 <summary>Specialize the type function at a given type</summary>
 <returns>The specialized type.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpTypeFunc.#ctor">
 <summary>Construct an instance of an F# first class type function value </summary>
 <returns>FSharpTypeFunc</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpTypeFunc">
 <summary>The CLI type used to represent F# first-class type function values. This type is for use
 by compiled F# code.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Format`4">
 <summary>Type of a formatting expression.</summary>
 <typeparam name="Printer">Function type generated by printf.</typeparam>
 <typeparam name="State">Type argument passed to %a formatters</typeparam>
 <typeparam name="Residue">Value generated by the overall printf action (e.g. sprint generates a string)</typeparam>
 <typeparam name="Result">Value generated after post processing (e.g. failwithf generates a string internally then raises an exception)</typeparam>
</member>
<member name="T:Microsoft.FSharp.Core.Format`5">
 <summary>Type of a formatting expression.</summary>
 <typeparam name="Printer">Function type generated by printf.</typeparam>
 <typeparam name="State">Type argument passed to %a formatters</typeparam>
 <typeparam name="Residue">Value generated by the overall printf action (e.g. sprint generates a string)</typeparam>
 <typeparam name="Result">Value generated after post processing (e.g. failwithf generates a string internally then raises an exception)</typeparam>
 <typeparam name="Tuple">Tuple of values generated by scan or match.</typeparam>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFSharpFunc``2(System.Converter{``0,``1})">
 <summary>Convert the given Converter delegate object to an F# function value</summary>
 <param name="converter">The input Converter.</param>
 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFSharpFunc``1(System.Action{``0})">
 <summary>Convert the given Action delegate object to an F# function value</summary>
 <param name="action">The input action.</param>
 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``6(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`5{``0,``1,``2,``3,``4},``5})">
 <summary>A utility function to convert function values from tupled to curried form</summary>
 <param name="func">The input tupled function.</param>
 <returns>The output curried function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``5(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`4{``0,``1,``2,``3},``4})">
 <summary>A utility function to convert function values from tupled to curried form</summary>
 <param name="func">The input tupled function.</param>
 <returns>The output curried function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``4(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{``0,``1,``2},``3})">
 <summary>A utility function to convert function values from tupled to curried form</summary>
 <param name="func">The input tupled function.</param>
 <returns>The output curried function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``3(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{``0,``1},``2})">
 <summary>A utility function to convert function values from tupled to curried form</summary>
 <param name="func">The input tupled function.</param>
 <returns>The output curried function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FuncConvert">
 <summary>Helper functions for converting F# first class function values to and from CLI representaions
 of functions using delegates.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.GeneralizableValueAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>GeneralizableValueAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.GeneralizableValueAttribute">
 <summary>Adding this attribute to a non-function value with generic parameters indicates that 
 uses of the construct can give rise to generic code through type inference. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.InterfaceAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>InterfaceAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.InterfaceAttribute">
 <summary>Adding this attribute to a type causes it to be represented using a CLI interface.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LiteralAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>LiteralAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.LiteralAttribute">
 <summary>Adding this attribute to a value causes it to be compiled as a CLI constant literal.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>MeasureAnnotatedAbbreviationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute">
 <summary>Adding this attribute to a type causes it to be interpreted as a refined type, currently limited to measure-parameterized types.
 This may only be used under very limited conditions.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>MeasureAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAttribute">
 <summary>Adding this attribute to a type causes it to be interpreted as a unit of measure.
 This may only be used under very limited conditions.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoComparisonAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>NoComparisonAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoComparisonAttribute">
 <summary>Adding this attribute to a type indicates it is a type where comparison is an abnormal operation.
 This means that the type does not satisfy the F# 'comparison' constraint. Within the bounds of the 
 F# type system, this helps ensure that the F# generic comparison function is not instantiated directly
 at this type. The attribute and checking does not constrain the use of comparison with base or child 
 types of this type.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoDynamicInvocationAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>NoDynamicInvocationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoDynamicInvocationAttribute">
 <summary>This attribute is used to tag values that may not be dynamically invoked at runtime. This is
 typically added to inlined functions whose implementations include unverifiable code. It
 causes the method body emitted for the inlined function to raise an exception if 
 dynamically invoked, rather than including the unverifiable code in the generated
 assembly.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoEqualityAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>NoEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoEqualityAttribute">
 <summary>Adding this attribute to a type indicates it is a type where equality is an abnormal operation.
 This means that the type does not satisfy the F# 'equality' constraint. Within the bounds of the 
 F# type system, this helps ensure that the F# generic equality function is not instantiated directly
 at this type. The attribute and checking does not constrain the use of comparison with base or child 
 types of this type.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1.Some">
 <summary>The representation of "Value of type 'T"</summary>
 <param name="Value">The input value.</param>
 <returns>An option representing the value.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1.None">
 <summary>The representation of "No value"</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.Value">
 <summary>Get the value of a 'Some' option. A NullReferenceException is raised if the option is 'None'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.None">
 <summary>Create an option value that is a 'None' value.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.IsSome">
 <summary>Return 'true' if the option is a 'Some' value.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.IsNone">
 <summary>Return 'true' if the option is a 'None' value.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpOption`1.Some(`0)">
 <summary>Create an option value that is a 'Some' value.</summary>
 <param name="value">The input value</param>
 <returns>An option representing the value.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1">
 <summary>The type of optional values. When used from other CLI languages the
 empty option is the <c>null</c> value. </summary>

 <remarks>Use the constructors <c>Some</c> and <c>None</c> to create values of this type.
 Use the values in the <c>Option</c> module to manipulate values of this type,
 or pattern match against the values directly.

 <c>None</c> values will appear as the value <c>null</c> to other CLI languages.
 Instance methods on this type will appear as static methods to other CLI languages
 due to the use of <c>null</c> as a value representation.</remarks>
</member>
<member name="M:Microsoft.FSharp.Core.OptionalArgumentAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>OptionalArgumentAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptionalArgumentAttribute">
 <summary>This attribute is added automatically for all optional arguments.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.PrintfFormat`4.Value">
 <summary>The raw text of the format string.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`4.#ctor(System.String)">
 <summary>Construct a format string </summary>
 <param name="value">The input string.</param>
 <returns>The PrintfFormat containing the formatted result.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfFormat`4">
 <summary>Type of a formatting expression.</summary>
 <typeparam name="Printer">Function type generated by printf.</typeparam>
 <typeparam name="State">Type argument passed to %a formatters</typeparam>
 <typeparam name="Residue">Value generated by the overall printf action (e.g. sprint generates a string)</typeparam>
 <typeparam name="Result">Value generated after post processing (e.g. failwithf generates a string internally then raises an exception)</typeparam>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`5.#ctor(System.String)">
 <summary>Construct a format string</summary>
 <param name="value">The input string.</param>
 <returns>The created format string.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfFormat`5">
 <summary>Type of a formatting expression.</summary>
 <typeparam name="Printer">Function type generated by printf.</typeparam>
 <typeparam name="State">Type argument passed to %a formatters</typeparam>
 <typeparam name="Residue">Value generated by the overall printf action (e.g. sprint generates a string)</typeparam>
 <typeparam name="Result">Value generated after post processing (e.g. failwithf generates a string internally then raises an exception)</typeparam>
 <typeparam name="Tuple">Tuple of values generated by scan or match.</typeparam>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.FSharpRef`1.contents">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpRef`1.Value(`0)">
 <summary>The current value of the reference cell</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpRef`1.Value">
 <summary>The current value of the reference cell</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpRef`1">
 <summary>The type of mutable references. Use the functions [:=] and [!] to get and
 set values of this type.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReferenceEqualityAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>ReferenceEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ReferenceEqualityAttribute">
 <summary>Adding this attribute to a record or union type disables the automatic generation
 of overrides for 'System.Object.Equals(obj)', 'System.Object.GetHashCode()' 
 and 'System.IComparable' for the type. The type will by default use reference equality.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReflectedDefinitionAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>ReflectedDefinitionAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ReflectedDefinitionAttribute">
 <summary>Adding this attribute to the let-binding for the definition of a top-level 
 value makes the quotation expression that implements the value available
 for use at runtime.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>RequireQualifiedAccessAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute">
 <summary>This attribute is used to indicate that references to a the elements of a module, record or union 
 type require explicit qualified access.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>RequiresExplicitTypeArgumentsAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute">
 <summary>Adding this attribute to a type, value or member requires that 
 uses of the construct must explicitly instantiate any generic type parameters.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SealedAttribute.Value">
 <summary>The value of the attribute, indicating whether the type is sealed or not.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute</summary>
 <param name="value">Indicates whether the class is sealed.</param>
 <returns>SealedAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute.#ctor">
 <summary>Creates an instance of the attribute.</summary>
 <returns>The created attribute.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.SealedAttribute">
 <summary>Adding this attribute to class definition makes it sealed, which means it may not
 be extended or implemented.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.NonPublicRepresentation">
 <summary>Indicates that the compiled entity had private or internal representation in F# source code.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.KindMask">
 <summary>The mask of values related to the kind of the compiled entity.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.Value">
 <summary>Indicates that the compiled entity is part of the representation of an F# value declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.UnionCase">
 <summary>Indicates that the compiled entity is part of the representation of an F# union case declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.Module">
 <summary>Indicates that the compiled entity is part of the representation of an F# module declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.Closure">
 <summary>Indicates that the compiled entity is part of the representation of an F# closure.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.Exception">
 <summary>Indicates that the compiled entity is part of the representation of an F# exception declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.Field">
 <summary>Indicates that the compiled entity is part of the representation of an F# record or union case field declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.ObjectType">
 <summary>Indicates that the compiled entity is part of the representation of an F# class or other object type declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.RecordType">
 <summary>Indicates that the compiled entity is part of the representation of an F# record type declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.SumType">
 <summary>Indicates that the compiled entity is part of the representation of an F# union type declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.SourceConstructFlags.None">
 <summary>Indicates that the compiled entity has no relationship to an element in F# source code.</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.SourceConstructFlags">
 <summary>Indicates the relationship between a compiled entity in a CLI binary and an element in F# source code.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>StructAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructAttribute">
 <summary>Adding this attribute to a type causes it to be represented using a CLI struct.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralComparisonAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>StructuralComparisonAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralComparisonAttribute">
 <summary>Adding this attribute to a record, union, exception, or struct type confirms the 
 automatic generation of implementations for 'System.IComparable' for the type.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralEqualityAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>StructuralEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralEqualityAttribute">
 <summary>Adding this attribute to a record, union or struct type confirms the automatic 
 generation of overrides for 'System.Object.Equals(obj)' and 
 'System.Object.GetHashCode()' for the type. </summary>
</member>
<member name="P:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute.Value">
 <summary>Indicates the text to display by default when objects of this type are displayed 
 using '%A' printf formatting patterns and other two-dimensional text-based display 
 layouts. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>
 <param name="value">Indicates the text to display when using the '%A' printf formatting.</param>
 <returns>StructuredFormatDisplayAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute">
 <summary>This attribute is used to mark how a type is displayed by default when using 
 '%A' printf formatting patterns and other two-dimensional text-based display layouts. 
 In this version of F# the only valid values are of the form <c>PreText {PropertyName} PostText</c>.
 The property name indicates a property to evaluate and to display instead of the object itself. </summary>
</member>
<member name="T:Microsoft.FSharp.Core.Unit">
 <summary>The type 'unit', which has only one value "()". This value is special and
 always uses the representation 'null'.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.UnverifiableAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>UnverifiableAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.UnverifiableAttribute">
 <summary>This attribute is used to tag values whose use will result in the generation
 of unverifiable code. These values are inevitably marked 'inline' to ensure that
 the unverifiable constructs are not present in the actual code for the F# library,
 but are rather copied to the source code of the caller.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.VolatileFieldAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>VolatileFieldAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.VolatileFieldAttribute">
 <summary>Adding this attribute to an F# mutable binding causes the "volatile"
 prefix to be used for all accesses to the field.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,,]`1">
 <summary>Four dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <remarks>Use the values in the <c>Array4D</c> module
 to manipulate values of this type, or the notation <c>arr.[x1,x2,x3,x4]</c> to get and set array
 values.</remarks>  
</member>
<member name="T:Microsoft.FSharp.Core.[,,]`1">
 <summary>Three dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <remarks>Use the values in the <c>Array3D</c> module
 to manipulate values of this type, or the notation <c>arr.[x1,x2,x3]</c> to get and set array
 values.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.[,]`1">
 <summary>Two dimensional arrays, typically zero-based.</summary> 

 <remarks>Use the values in the <c>Array2D</c> module
 to manipulate values of this type, or the notation <c>arr.[x,y]</c> to get/set array
 values.   

 Non-zero-based arrays can also be created using methods on the System.Array type.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.[]`1">
 <summary>Single dimensional, zero-based arrays, written <c>int[]</c>, <c>string[]</c> etc.</summary>
 <remarks>Use the values in the <c>Array</c> module to manipulate values 
 of this type, or the notation <c>arr.[x]</c> to get/set array
 values.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.array`1">
 <summary>Single dimensional, zero-based arrays, written <c>int[]</c>, <c>string[]</c> etc.</summary>
 
 <remarks>Use the values in the <c>Array</c> module to manipulate values 
 of this type, or the notation <c>arr.[x]</c> to get/set array
 values.</remarks>   
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.bool">
 <summary>An abbreviation for the CLI type <c>System.Boolean</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byref`1">
 <summary>Represents a managed pointer in F# code.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byte">
 <summary>An abbreviation for the CLI type <c>System.Byte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.char">
 <summary>An abbreviation for the CLI type <c>System.Char</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.decimal">
 <summary>An abbreviation for the CLI type <c>System.Decimal</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.decimal`1">
 <summary>The type of decimal numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Decimal</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.double">
 <summary>An abbreviation for the CLI type <c>System.Double</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.exn">
 <summary>An abbreviation for the CLI type <c>System.Exception</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float">
 <summary>An abbreviation for the CLI type <c>System.Double</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float32">
 <summary>An abbreviation for the CLI type <c>System.Single</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float32`1">
 <summary>The type of floating point numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Single</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float`1">
 <summary>The type of floating point numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Double</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ilsigptr`1">
 <summary>This type is for internal use by the F# code generator.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int">
 <summary>An abbreviation for the CLI type <c>System.Int32</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int16">
 <summary>An abbreviation for the CLI type <c>System.Int16</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int16`1">
 <summary>The type of 16-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Int16</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int32">
 <summary>An abbreviation for the CLI type <c>System.Int32</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int64">
 <summary>An abbreviation for the CLI type <c>System.Int64</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int64`1">
 <summary>The type of 64-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Int64</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int8">
 <summary>An abbreviation for the CLI type <c>System.SByte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int`1">
 <summary>The type of 32-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.Int32</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.nativeint">
 <summary>An abbreviation for the CLI type <c>System.IntPtr</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.nativeptr`1">
 <summary>Represents an unmanaged pointer in F# code.</summary>

 <remarks>This type should only be used when writing F# code that interoperates
 with native code.  Use of this type in F# code may result in
 unverifiable code being generated.  Conversions to and from the 
 <c>nativeint</c> type may be required. Values of this type can be generated
 by the functions in the <c>NativeInterop.NativePtr</c> module.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.obj">
 <summary>An abbreviation for the CLI type <c>System.Object</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.option`1">
 <summary>The type of optional values. When used from other CLI languages the
 empty option is the <c>null</c> value. </summary>

 <remarks>Use the constructors <c>Some</c> and <c>None</c> to create values of this type.
 Use the values in the <c>Option</c> module to manipulate values of this type,
 or pattern match against the values directly.

 'None' values will appear as the value <c>null</c> to other CLI languages.
 Instance methods on this type will appear as static methods to other CLI languages
 due to the use of <c>null</c> as a value representation.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.ref`1">
 <summary>The type of mutable references. Use the functions [:=] and [!] to get and
 set values of this type.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte">
 <summary>An abbreviation for the CLI type <c>System.SByte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte`1">
 <summary>The type of 8-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <c>System.SByte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.single">
 <summary>An abbreviation for the CLI type <c>System.Single</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.string">
 <summary>An abbreviation for the CLI type <c>System.String</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint16">
 <summary>An abbreviation for the CLI type <c>System.UInt16</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint32">
 <summary>An abbreviation for the CLI type <c>System.UInt32</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint64">
 <summary>An abbreviation for the CLI type <c>System.UInt64</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint8">
 <summary>An abbreviation for the CLI type <c>System.Byte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.unativeint">
 <summary>An abbreviation for the CLI type <c>System.UIntPtr</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.unit">
 <summary>The type 'unit', which has only one value "()". This value is special and
 always uses the representation 'null'.</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.MatchFailureException">
 <summary>Non-exhaustive match failures will raise the MatchFailureException exception</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.LastGenerated">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.CheckClose">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.GetFreshEnumerator">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>

 <returns>A new enumerator for the sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.GenerateNext(System.Collections.Generic.IEnumerable{`0}@)">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>

 <param name="result">A reference to the sequence.</param>

 <returns>A 0, 1, and 2 respectively indicate Stop, Yield, and Goto conditions for the sequence generator.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.Close">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.#ctor">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>

 <returns>A new sequence generator for the expression.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.CreateEvent``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Object,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},``0})">
 <summary>Creates an anonymous event with the given handlers.</summary>

 <param name="addHandler">A function to handle adding a delegate for the event to trigger.</param>
 <param name="removeHandler">A function to handle removing a delegate that the event triggers.</param>
 <param name="createHandler">A function to produce the delegate type the event can trigger.</param>

 <returns>The initialized event.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateUsing``3(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
 <summary>The F# compiler emits calls to this function to implement the <c>use</c> operator for F# sequence
 expressions.</summary>

 <param name="resource">The resource to be used and disposed.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateFromFunctions``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
 <summary>The F# compiler emits calls to this function to implement the compiler-intrinsic
 conversions from untyped System.Collections.IEnumerable sequences to typed sequences.</summary>

 <param name="create">An initializer function.</param>
 <param name="moveNext">A function to iterate and test if end of sequence is reached.</param>
 <param name="current">A function to retrieve the current element.</param>

 <returns>The resulting typed sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateThenFinally``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>The F# compiler emits calls to this function to 
 implement the <c>try/finally</c> operator for F# sequence expressions.</summary>

 <param name="source">The input sequence.</param>
 <param name="compensation">A computation to be included in an enumerator's Dispose method.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateWhile``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>The F# compiler emits calls to this function to 
 implement the <c>while</c> operator for F# sequence expressions.</summary>

 <param name="guard">A function that indicates whether iteration should continue.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers">
 <summary>A group of functions used as part of the compiled representation of F# sequence expressions.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.LazyPattern``1(System.Lazy{``0})">
 <summary>An active pattern to force the execution of values of type <c>Lazy&lt;_&gt;</c>.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.SpliceUntypedExpression``1(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Special prefix operator for splicing untyped expressions into quotation holes.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.SpliceExpression``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
 <summary>Special prefix operator for splicing typed expressions into quotation holes.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateArray2D``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a 2D array from a sequence of sequences of elements.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary``2(System.Collections.Generic.IEnumerable{System.Tuple`2{``0,``1}})">
 <summary>Builds a read-only lookup table from a sequence of key/value pairs. The key objects are indexed using generic hashing and equality.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToSByte``1(``0)">
 <summary>Converts the argument to signed byte.</summary>
 <remarks>This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>SByte.Parse()</c>  with InvariantCulture settings.
 Otherwise the operation requires and invokes a <c>ToSByte</c> method on the input type.</remarks>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToByte``1(``0)">
 <summary>Converts the argument to byte.</summary>
 <remarks>This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Byte.Parse()</c> on strings and otherwise requires a <c>ToByte</c> method on the input type.</remarks>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToDouble``1(``0)">
 <summary>Converts the argument to 64-bit float.</summary>
 <remarks>This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToDouble</c> method on the input type.</remarks>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToSingle``1(``0)">
 <summary>Converts the argument to 32-bit float.</summary>
 <remarks>This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToSingle</c> method on the input type.</remarks>
</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.DefaultAsyncBuilder">
 <summary>Builds an aysnchronous workflow using computation expression syntax.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateSet``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a set from a sequence of objects. The objects are indexed using generic comparison.</summary>
 <param name="elements">The input sequence of elements.</param>
 <returns>The created set.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLineToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a file using the given format, and add a newline.</summary>
 <param name="textWriter">The file TextWriter.</param>
 <param name="format">The formatter.</param>
 <returns>The formatted result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a file using the given format.</summary>
 <param name="textWriter">The file TextWriter.</param>
 <param name="format">The formatter.</param>
 <returns>The formatted result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToStringThenFail``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
 <summary>Print to a string buffer and raise an exception with the given
 result.   Helper printers must return strings.</summary>
 <param name="format">The formatter.</param>
 <returns>The formatted result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToString``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
 <summary>Print to a string using the given format.</summary>
 <param name="format">The formatter.</param>
 <returns>The formatted result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLineToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to <c>stderr</c> using the given format, and add a newline.</summary>
 <param name="format">The formatter.</param>
 <returns>The formatted result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to <c>stderr</c> using the given format.</summary>
 <param name="format">The formatter.</param>
 <returns>The formatted result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to <c>stdout</c> using the given format, and add a newline.</summary>
 <param name="format">The formatter.</param>
 <returns>The formatted result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormat``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to <c>stdout</c> using the given format.</summary>
 <param name="format">The formatter.</param>
 <returns>The formatted result.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ExtraTopLevelOperators">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByInt``1(``0,System.Int32)">
 <summary>Divides a value by an integer.</summary>
 <param name="x">The input value.</param>
 <param name="y">The input int.</param>
 <returns>The division result.</returns>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOne``1">
 <summary>Resolves to the one value for any primitive numeric type or any type with a static member called 'One'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZero``1">
 <summary>Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByIntDynamic``1(``0,System.Int32)">
 <summary>A compiler intrinsic that implements dynamic invocations for the DivideByInt primitive.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedMultiplyDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the checked '+' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.MultiplyDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '+' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedAdditionDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the checked '+' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.AdditionDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '+' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOneDynamic``1">
 <summary>Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZeroDynamic``1">
 <summary>Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt64(System.String)">
 <summary>Parse an uint64 according to the rules used by the overloaded 'uint64' conversion operator when applied to strings</summary>
 <param name="s">The input string.</param>
 <returns>The parsed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt64(System.String)">
 <summary>Parse an int64 according to the rules used by the overloaded 'int64' conversion operator when applied to strings</summary>
 <param name="s">The input string.</param>
 <returns>The parsed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt32(System.String)">
 <summary>Parse an uint32 according to the rules used by the overloaded 'uint32' conversion operator when applied to strings</summary>
 <param name="s">The input string.</param>
 <returns>The parsed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt32(System.String)">
 <summary>Parse an int32 according to the rules used by the overloaded 'int32' conversion operator when applied to strings</summary>
 <param name="s">The input string.</param>
 <returns>The parsed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.SByteWithMeasure``1(System.SByte)">
 <summary>Creates an sbyte value with units-of-measure</summary>
 <param name="sbyte">The input sbyte.</param>
 <returns>The sbyte with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Int16WithMeasure``1(System.Int16)">
 <summary>Creates an int16 value with units-of-measure</summary>
 <param name="int16">The input int16.</param>
 <returns>The int16 with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Int64WithMeasure``1(System.Int64)">
 <summary>Creates an int64 value with units-of-measure</summary>
 <param name="int64">The input int64.</param>
 <returns>The int64 with units of measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Int32WithMeasure``1(System.Int32)">
 <summary>Creates an int32 value with units-of-measure</summary>
 <param name="int">The input int.</param>
 <returns>The int with units of measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DecimalWithMeasure``1(System.Decimal)">
 <summary>Creates a decimal value with units-of-measure</summary>
 <param name="decimal">The input decimal.</param>
 <returns>The decimal with units of measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Float32WithMeasure``1(System.Single)">
 <summary>Creates a float32 value with units-of-measure</summary>
 <param name="float32">The input float.</param>
 <returns>The float with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FloatWithMeasure``1(System.Double)">
 <summary>Creates a float value with units-of-measure</summary>
 <param name="float">The input float.</param>
 <returns>The float with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumToValue``2(``0)">
 <summary>Get the underlying value for an enum value</summary>
 <param name="enum">The input enum.</param>
 <returns>The enumeration as a value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumOfValue``2(``0)">
 <summary>Build an enum value from an underlying value</summary>
 <param name="value">The input value.</param>
 <returns>The value as an enumeration.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHashWithComparer``1(System.Collections.IEqualityComparer,``0)">
 <summary>Recursively hash a part of a value according to its structure. </summary>
 <param name="comparer">The comparison function.</param>
 <param name="obj">The input object.</param>
 <returns>The hashed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLimitedHash``1(System.Int32,``0)">
 <summary>Hash a value according to its structure. Use the given limit to restrict the hash when hashing F#
 records, lists and union types.</summary>
 <param name="limit">The limit on the number of nodes.</param>
 <param name="obj">The input object.</param>
 <returns>The hashed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHash``1(``0)">
 <summary>Hash a value according to its structure. This hash is not limited by an overall node count when hashing F#
 records, lists and union types.</summary>
 <param name="obj">The input object.</param>
 <returns>The hashed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastLimitedGenericEqualityComparer``1(System.Int32)">
 <summary>Make an F# hash/equality object for the given type using node-limited hashing when hashing F#
 records, lists and union types.</summary>
 <param name="limit">The input limit on the number of nodes.</param>
 <returns>System.Collections.Generic.IEqualityComparer&lt;'T&gt;</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericEqualityComparer``1">
 <summary>Make an F# hash/equality object for the given type</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparerCanBeNull``1">
 <summary>Make an F# comparer object for the given type, where it can be null if System.Collections.Generic.Comparer&lt;'T&gt;.Default</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparer``1">
 <summary>Make an F# comparer object for the given type</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparer">
 <summary>A static F# comparer object</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityERComparer">
 <summary>Return an F# comparer object suitable for hashing and equality. This hashing behaviour
 of the returned comparer is not limited by an overall node count when hashing F#
 records, lists and union types. This equality comparer has equivalence 
 relation semantics ([nan] = [nan]).</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityComparer">
 <summary>Return an F# comparer object suitable for hashing and equality. This hashing behaviour
 of the returned comparer is not limited by an overall node count when hashing F#
 records, lists and union types.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalHash``1(``0)">
 <summary>The physical hash. Hashes on the object identity, except for value types,
 where we hash on the contents.</summary>
 <param name="obj">The input object.</param>
 <returns>The hashed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalEquality``1(``0,``0)">
 <summary>Reference/physical equality. 
 True if boxed versions of the inputs are reference-equal, OR if
 both are primitive numeric types and the implementation of Object.Equals for the type
 of the first argument returns true on the boxed versions of the inputs. </summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMaximum``1(``0,``0)">
 <summary>Take the maximum of two values structurally according to the order given by GenericComparison</summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The maximum value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMinimum``1(``0,``0)">
 <summary>Take the minimum of two values structurally according to the order given by GenericComparison</summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The minimum value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterOrEqual``1(``0,``0)">
 <summary>Compare two values   </summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessOrEqual``1(``0,``0)">
 <summary>Compare two values   </summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterThan``1(``0,``0)">
 <summary>Compare two values   </summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessThan``1(``0,``0)">
 <summary>Compare two values   </summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparisonWithComparer``1(System.Collections.IComparer,``0,``0)">
 <summary>Compare two values. May be called as a recursive case from an implementation of System.IComparable to
 ensure consistent NaN comparison semantics.</summary>
 <param name="comp">The function to compare the values.</param>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparison``1(``0,``0)">
 <summary>Compare two values </summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityWithComparer``1(System.Collections.IEqualityComparer,``0,``0)">
 <summary>Compare two values for equality</summary>
 <param name="comp"></param>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityER``1(``0,``0)">
 <summary>Compare two values for equality using equivalence relation semantics ([nan] = [nan])</summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEquality``1(``0,``0)">
 <summary>Compare two values for equality using partial equivalence relation semantics ([nan] &lt;&gt; [nan])</summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple5``5(System.Collections.IComparer,System.Tuple`5{``0,``1,``2,``3,``4},System.Tuple`5{``0,``1,``2,``3,``4})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple4``4(System.Collections.IComparer,System.Tuple`4{``0,``1,``2,``3},System.Tuple`4{``0,``1,``2,``3})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple3``3(System.Collections.IComparer,System.Tuple`3{``0,``1,``2},System.Tuple`3{``0,``1,``2})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple2``2(System.Collections.IComparer,System.Tuple`2{``0,``1},System.Tuple`2{``0,``1})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple5``5(System.Collections.IEqualityComparer,System.Tuple`5{``0,``1,``2,``3,``4},System.Tuple`5{``0,``1,``2,``3,``4})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple4``4(System.Collections.IEqualityComparer,System.Tuple`4{``0,``1,``2,``3},System.Tuple`4{``0,``1,``2,``3})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple3``3(System.Collections.IEqualityComparer,System.Tuple`3{``0,``1,``2},System.Tuple`3{``0,``1,``2})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple2``2(System.Collections.IEqualityComparer,System.Tuple`2{``0,``1},System.Tuple`2{``0,``1})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple5``5(System.Collections.IEqualityComparer,System.Tuple`5{``0,``1,``2,``3,``4})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple4``4(System.Collections.IEqualityComparer,System.Tuple`4{``0,``1,``2,``3})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple3``3(System.Collections.IEqualityComparer,System.Tuple`3{``0,``1,``2})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple2``2(System.Collections.IEqualityComparer,System.Tuple`2{``0,``1})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessOrEqualIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterOrEqualIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterThanIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessThanIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityERIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonWithComparerIntrinsic``1(System.Collections.IComparer,``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.LimitedGenericHashIntrinsic``1(System.Int32,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashIntrinsic``1(``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalEqualityIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalHashIntrinsic``1(``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare">
 <summary>The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray4D``1(``0[0:,0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 The standard overloaded associative (4-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray3D``1(``0[0:,0:,0:],System.Int32,System.Int32,System.Int32,``0)">
 <summary>The standard overloaded associative (3-indexed) mutation operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray2D``1(``0[0:,0:],System.Int32,System.Int32,``0)">
 <summary>The standard overloaded associative (2-indexed) mutation operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray``1(``0[],System.Int32,``0)">
 <summary>The standard overloaded associative (indexed) mutation operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray4D``1(``0[0:,0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>The standard overloaded associative (4-indexed) lookup operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray3D``1(``0[0:,0:,0:],System.Int32,System.Int32,System.Int32)">
 <summary>The standard overloaded associative (3-indexed) lookup operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray2D``1(``0[0:,0:],System.Int32,System.Int32)">
 <summary>The standard overloaded associative (2-indexed) lookup operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray``1(``0[],System.Int32)">
 <summary>The standard overloaded associative (indexed) lookup operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CheckThis``1(``0)">
 <summary>A compiler intrinsic for checking initialization soundness of recursive bindings</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.FailStaticInit">
 <summary>A compiler intrinsic for checking initialization soundness of recursive static bindings</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.FailInit">
 <summary>A compiler intrinsic for checking initialization soundness of recursive bindings</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.Dispose``1(``0)">
 <summary>A compiler intrinsic for the efficient compilation of sequence expressions</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.MakeDecimal(System.Int32,System.Int32,System.Int32,System.Boolean,System.Byte)">
 <summary>This function implements parsing of decimal constants</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CreateInstance``1">
 <summary>This function implements calls to default constructors
 acccessed by 'new' constraints.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetString(System.String,System.Int32)">
 <summary>Primitive used by pattern match compilation</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestFast``1(System.Object)">
 <summary>A compiler intrinsic that implements the ':?' operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestGeneric``1(System.Object)">
 <summary>A compiler intrinsic that implements the ':?' operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxFast``1(System.Object)">
 <summary>A compiler intrinsic that implements the ':?>' operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric``1(System.Object)">
 <summary>A compiler intrinsic that implements the ':?>' operator</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions">
 <summary>The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_IntegerAddressOf``1(``0)">
 <summary>Address-of. Uses of this value may result in the generation of unverifiable code.</summary>
 <param name="obj">The input object.</param>
 <returns>The unmanaged pointer.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_AddressOf``1(``0)">
 <summary>Address-of. Uses of this value may result in the generation of unverifiable code.</summary>
 <param name="obj">The input object.</param>
 <returns>The managed pointer.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanOr(System.Boolean,System.Boolean)">
 <summary>Binary 'or'. When used as a binary operator the right hand value is evaluated only on demand</summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.Or(System.Boolean,System.Boolean)">
 <summary>Binary 'or'. When used as a binary operator the right hand value is evaluated only on demand.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanAnd(System.Boolean,System.Boolean)">
 <summary>Binary 'and'. When used as a binary operator the right hand value is evaluated only on demand</summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_Amp(System.Boolean,System.Boolean)">
 <summary>Binary 'and'. When used as a binary operator the right hand value is evaluated only on demand.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators">
 <summary>The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.ErrorStrings">
 <summary>For internal use only</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives">
 <summary>Language primitives associated with the F# language</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromStringDynamic(System.String)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt64Dynamic(System.Int64)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromString``1(System.String)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt64``1(System.Int64)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt32``1(System.Int32)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromOne``1">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromZero``1">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.KeyValuePattern``2(System.Collections.Generic.KeyValuePair{``0,``1})">
 <summary>An active pattern to match values of type <c>System.Collections.Generic.KeyValuePair</c></summary>
 <param name="keyValuePair">The input key/value pair.</param>
 <returns>A tuple containing the key and value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToChar``1(``0)">
 <summary>Converts the argument to character. Numeric inputs are converted according to the UTF-16 
 encoding for characters. String inputs must be exactly one character long. For other
 input types the operation requires an appropriate static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted char.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToDecimal``1(``0)">
 <summary>Converts the argument to System.Decimal using a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted decimal.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToString``1(``0)">
 <summary>Converts the argument to a string using <c>ToString</c>.</summary>

 <remarks>For standard integer and floating point values the <c>ToString</c> conversion 
 uses <c>CultureInfo.InvariantCulture</c>. </remarks>
 <param name="value">The input value.</param>
 <returns>The converted string.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUIntPtr``1(``0)">
 <summary>Converts the argument to unsigned native integer using a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted unativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToIntPtr``1(``0)">
 <summary>Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted nativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToDouble``1(``0)">
 <summary>Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted float</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToSingle``1(``0)">
 <summary>Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted float32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt64``1(``0)">
 <summary>Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted uint64</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt64``1(``0)">
 <summary>Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int64.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted int64</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt32``1(``0)">
 <summary>Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted uint32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt32``1(``0)">
 <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted int32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToEnum``1(System.Int32)">
 <summary>Converts the argument to a particular enum type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted enum type.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt``1(``0)">
 <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted int</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt16``1(``0)">
 <summary>Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt16.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted uint16</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt16``1(``0)">
 <summary>Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int16.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted int16</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToSByte``1(``0)">
 <summary>Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>SByte.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted sbyte</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToByte``1(``0)">
 <summary>Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Byte.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted byte</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.PowInteger``1(``0,System.Int32)">
 <summary>Overloaded power operator. If <c>n > 0</c> then equivalent to <c>x*...*x</c> for <c>n</c> occurrences of <c>x</c>. </summary>
 <param name="x">The input base.</param>
 <param name="n">The input exponent.</param>
 <returns>The base raised to the exponent.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Exponentiation``2(``0,``1)">
 <summary>Overloaded power operator.</summary>
 <param name="x">The input base.</param>
 <param name="y">The input exponent.</param>
 <returns>The base raised to the exponent.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Truncate``1(``0)">
 <summary>Overloaded truncate operator.</summary>
 <param name="value">The input value.</param>
 <returns>The truncated value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Tanh``1(``0)">
 <summary>Hyperbolic tangent of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The hyperbolic tangent of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Tan``1(``0)">
 <summary>Tangent of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The tangent of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sinh``1(``0)">
 <summary>Hyperbolic sine of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The hyperbolic sine of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sin``1(``0)">
 <summary>Sine of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The sine of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Cosh``1(``0)">
 <summary>Hyperbolic cosine  of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The hyperbolic cosine of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Cos``1(``0)">
 <summary>Cosine of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The cosine of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sqrt``2(``0)">
 <summary>Square root of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The square root of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Log10``1(``0)">
 <summary>Logarithm to base 10 of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The logarithm to base 10 of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Log``1(``0)">
 <summary>Natural logarithm of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The natural logarithm of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Round``1(``0)">
 <summary>Round the given number</summary>
 <param name="value">The input value.</param>
 <returns>The nearest integer to the input value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sign``1(``0)">
 <summary>Sign of the given number</summary>
 <param name="value">The input value.</param>
 <returns>-1, 0, or 1 depending on the sign of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Floor``1(``0)">
 <summary>Floor of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The floor of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Exp``1(``0)">
 <summary>Exponential of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The exponential of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ceiling``1(``0)">
 <summary>Ceiling of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The ceiling of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Atan2``2(``0,``0)">
 <summary>Inverse tangent of <c>x/y</c> where <c>x</c> and <c>y</c> are specified separately</summary>
 <param name="y">The y input value.</param>
 <param name="x">The x input value.</param>
 <returns>The inverse tangent of the input ratio.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Atan``1(``0)">
 <summary>Inverse tangent of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The inverse tangent of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Asin``1(``0)">
 <summary>Inverse sine of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The inverse sine of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Acos``1(``0)">
 <summary>Inverse cosine of the given number</summary>
 <param name="value">The input value.</param>
 <returns>The inverse cosine of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Abs``1(``0)">
 <summary>Absolute value of the given number.</summary>
 <param name="value">The input value.</param>
 <returns>The absolute value of the input.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.limitedHash``1(System.Int32,``0)">
 <summary>A generic hash function. This function has the same behaviour as 'hash', 
 however the default structural hashing for F# union, record and tuple 
 types stops when the given limit of nodes is reached. The exact behaviour of 
 the function can be adjusted on a type-by-type basis by implementing 
 GetHashCode for each type.</summary>
 <param name="limit">The limit of nodes.</param>
 <param name="obj">The input object.</param>
 <returns>The computed hash.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Hash``1(``0)">
 <summary>A generic hash function, designed to return equal hash values for items that are 
 equal according to the "=" operator. By default it will use structural hashing
 for F# union, record and tuple types, hashing the complete contents of the 
 type. The exact behaviour of the function can be adjusted on a 
 type-by-type basis by implementing GetHashCode for each type.</summary>
 <param name="obj">The input object.</param>
 <returns>The computed hash.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.SizeOf``1">
 <summary>Returns the internal size of a type in bytes. For example, <c>sizeof&lt;int&gt;</c> returns 4.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.TypeDefOf``1">
 <summary>Generate a System.Type representation for a type definition. If the
 input type is a generic type instantiation then return the 
 generic type definition associated with all such instantiations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.TypeOf``1">
 <summary>Generate a System.Type runtime representation of a static type.
 The static type is still maintained on the value returned.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
 <summary>Clean up resources associated with the input object after the completion of the given function.
 Cleanup occurs even when an exception is raised by the protected
 code. </summary>
 <param name="resource">The resource to be disposed after action is called.</param>
 <param name="action">The action that accepts the resource.</param>
 <returns>The resulting value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Lock``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``1})">
 <summary>Execute the function as a mutual-exclusion region using the input value as a lock. </summary>
 <param name="lockObject">The object to be locked.</param>
 <param name="action">The action to perform during the lock.</param>
 <returns>The resulting value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RangeStep``2(``0,``1,``0)">
 <summary>The standard overloaded skip range operator, e.g. <c>[n..skip..m]</c> for lists, <c>seq {n..skip..m}</c> for sequences</summary>
 <param name="start">The start value of the range.</param>
 <param name="step">The step value of the range.</param>
 <param name="finish">The end value of the range.</param>
 <returns>The sequence spanning the range using the specified step size.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Range``1(``0,``0)">
 <summary>The standard overloaded range operator, e.g. <c>[n..m]</c> for lists, <c>seq {n..m}</c> for sequences</summary>
 <param name="start">The start value of the range.</param>
 <param name="finish">The end value of the range.</param>
 <returns>The sequence spanning the range.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleOut``1">
 <summary>Reads the value of the property <c>System.Console.Out</c>.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleError``1">
 <summary>Reads the value of the property <c>System.Console.Error</c>. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleIn``1">
 <summary>Reads the value of the property <c>System.Console.In</c>. </summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.NaNSingle">
 <summary>Equivalent to <c>System.Single.NaN</c></summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.InfinitySingle">
 <summary>Equivalent to <c>System.Single.PositiveInfinity</c></summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.NaN">
 <summary>Equivalent to <c>System.Double.NaN</c></summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.Infinity">
 <summary>Equivalent to <c>System.Double.PositiveInfinity</c></summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Exit``1(System.Int32)">
 <summary>Exit the current hardware isolated process, if security settings permit,
 otherwise raise an exception. Calls <c>System.Environment.Exit</c>.</summary>
 <param name="exitcode">The exit code to use.</param>
 <returns>The result value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.CreateSequence``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a sequence using sequence expression syntax</summary>
 <param name="sequence">The input sequence.</param>
 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Not(System.Boolean)">
 <summary>Negate a logical value. <c>not true</c> equals <c>false</c> and <c>not false</c> equals <c>true</c></summary>
 <param name="value">The value to negate.</param>
 <returns>The result of the negation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Concatenate two lists.</summary>
 <param name="list1">The first list.</param>
 <param name="list2">The second list.</param>
 <returns>The concatenation of the lists.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Increment(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
 <summary>Increment a mutable reference cell containing an integer</summary>
 <param name="cell">The reference cell.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Decrement(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
 <summary>Decrement a mutable reference cell containing an integer</summary>
 <param name="cell">The reference cell.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Dereference``1(Microsoft.FSharp.Core.FSharpRef{``0})">
 <summary>Dereference a mutable reference cell</summary>
 <param name="cell">The cell to dereference.</param>
 <returns>The value contained in the cell.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ColonEquals``1(Microsoft.FSharp.Core.FSharpRef{``0},``0)">
 <summary>Assign to a mutable reference cell</summary>
 <param name="cell">The cell to mutate.</param>
 <param name="value">The value to set inside the cell.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ref``1(``0)">
 <summary>Create a mutable reference cell</summary>
 <param name="value">The value to contain in the cell.</param>
 <returns>The created reference cell.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Identity``1(``0)">
 <summary>The identity function</summary>
 <param name="x">The input value.</param>
 <returns>The same value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidOp``1(System.String)">
 <summary>Throw an <c>System.InvalidOperationException</c> exception</summary>
 <param name="message">The exception message.</param>
 <returns>The result value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NullArg``1(System.String)">
 <summary>Throw an <c>System.ArgumentNullException</c> exception</summary>
 <param name="argumentName">The argument name.</param>
 <returns>The result value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidArg``1(System.String,System.String)">
 <summary>Throw an <c>System.ArgumentException</c> exception</summary>
 <param name="argumentName">The argument name.</param>
 <param name="message">The exception message.</param>
 <returns>The result value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.FailWith``1(System.String)">
 <summary>Throw a <c>System.Exception</c> exception</summary>
 <param name="message">The exception message.</param>
 <returns>The result value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Box``1(``0)">
 <summary>Boxes a strongly typed value.</summary>
 <param name="value">The value to box.</param>
 <returns>The boxed object.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unbox``1(System.Object)">
 <summary>Unboxes a strongly typed value. This is the inverse of <c>box</c>, unbox&lt;t&gt;(box&lt;t&gt; a) equals a.</summary>
 <param name="value">The boxed value.</param>
 <returns>The unboxed result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ignore``1(``0)">
 <summary>Ignore the passed value. This is often used to throw away results of a computation.</summary>
 <param name="value">The value to ignore.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Min``1(``0,``0)">
 <summary>Minimum based on generic comparison</summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The minimum value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Max``1(``0,``0)">
 <summary>Maximum based on generic comparison</summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The maximum value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Compare``1(``0,``0)">
 <summary>Generic comparison.</summary>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Snd``2(System.Tuple`2{``0,``1})">
 <summary>Return the second element of a tuple, <c>snd (a,b) = b</c>.</summary>
 <param name="tuple">The input tuple.</param>
 <returns>The second value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Fst``2(System.Tuple`2{``0,``1})">
 <summary>Return the first element of a tuple, <c>fst (a,b) = a</c>.</summary>
 <param name="tuple">The input tuple.</param>
 <returns>The first value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.FailurePattern(System.Exception)">
 <summary>Matches <c>System.Exception</c> objects whose runtime type is precisely <c>System.Exception</c></summary>
 <param name="error">The input exception.</param>
 <returns>A string option.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Failure(System.String)">
 <summary>Builds a <c>System.Exception</c> object.</summary>
 <param name="message">The message for the Exception.</param>
 <returns>A System.Exception.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Reraise``1">
 <summary>Rethrows an exception. This should only be used when handling an exception</summary>
 <returns>The result value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Rethrow``1">
 <summary>Rethrows an exception. This should only be used when handling an exception</summary>
 <returns>The result value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Raise``1(System.Exception)">
 <summary>Raises an exception</summary>
 <param name="exn">The exception to raise.</param>
 <returns>The result value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Concatenate(System.String,System.String)">
 <summary>Concatenate two strings. The operator '+' may also be used.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.DefaultArg``1(Microsoft.FSharp.Core.FSharpOption{``0},``0)">
 <summary>Used to specify a default value for an optional argument in the implementation of a function</summary>
 <param name="arg">An option representing the argument.</param>
 <param name="defaultValue">The default value of the argument.</param>
 <returns>The argument value. If it is None, the defaultValue is returned.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft3``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}}},``0,``1,``2)">
 <summary>Apply a function to three values, the values being a triple on the right, the function on the left</summary>
 <param name="func">The function.</param>
 <param name="arg1">The first argument.</param>
 <param name="arg2">The second argument.</param>
 <param name="arg3">The third argument.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},``0,``1)">
 <summary>Apply a function to two values, the values being a pair on the right, the function on the left</summary>
 <param name="func">The function.</param>
 <param name="arg1">The first argument.</param>
 <param name="arg2">The second argument.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0)">
 <summary>Apply a function to a value, the value being on the right, the function on the left</summary>
 <param name="func">The function.</param>
 <param name="arg1">The argument.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight3``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}}})">
 <summary>Apply a function to three values, the values being a triple on the left, the function on the right</summary>
 <param name="arg1">The first argument.</param>
 <param name="arg2">The second argument.</param>
 <param name="arg3">The third argument.</param>
 <param name="func">The function.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight2``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
 <summary>Apply a function to two values, the values being a pair on the left, the function on the right</summary>
 <param name="arg1">The first argument.</param>
 <param name="arg2">The second argument.</param>
 <param name="func">The function.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
 <summary>Apply a function to a value, the value being on the left, the function on the right</summary>
 <param name="arg">The argument.</param>
 <param name="func">The function.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeLeft``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``0})">
 <summary>Compose two functions, the function on the right being applied first</summary>
 <param name="func2">The second function to apply.</param>
 <param name="func1">The first function to apply.</param>
 <returns>The composition of the input functions.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeRight``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``2})">
 <summary>Compose two functions, the function on the left being applied first</summary>
 <param name="func1">The first function to apply.</param>
 <param name="func2">The second function to apply.</param>
 <returns>The composition of the input functions.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Inequality``1(``0,``0)">
 <summary>Structural inequality</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Equality``1(``0,``0)">
 <summary>Structural equality</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThanOrEqual``1(``0,``0)">
 <summary>Structural less-than-or-equal comparison</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThanOrEqual``1(``0,``0)">
 <summary>Structural greater-than-or-equal</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThan``1(``0,``0)">
 <summary>Structural greater-than</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThan``1(``0,``0)">
 <summary>Structural less-than comparison</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryPlus``1(``0)">
 <summary>Overloaded prefix=plus operator</summary>
 <param name="value">The input value.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LogicalNot``1(``0)">
 <summary>Overloaded logical-NOT operator</summary>
 <param name="value">The input value.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RightShift``1(``0,System.Int32)">
 <summary>Overloaded byte-shift right operator by a specified number of bits</summary>
 <param name="value">The input value.</param>
 <param name="shift">The amount to shift.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LeftShift``1(``0,System.Int32)">
 <summary>Overloaded byte-shift left operator by a specified number of bits</summary>
 <param name="value">The input value.</param>
 <param name="shift">The amount to shift.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ExclusiveOr``1(``0,``0)">
 <summary>Overloaded logical-XOR operator</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseOr``1(``0,``0)">
 <summary>Overloaded logical-OR operator</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseAnd``1(``0,``0)">
 <summary>Overloaded logical-AND operator</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Modulus``3(``0,``1)">
 <summary>Overloaded modulo operator</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Division``3(``0,``1)">
 <summary>Overloaded division operator</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Multiply``3(``0,``1)">
 <summary>Overloaded multiplication operator</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Subtraction``3(``0,``1)">
 <summary>Overloaded subtraction operator</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Addition``3(``0,``1)">
 <summary>Overloaded addition operator</summary>
 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryNegation``1(``0)">
 <summary>Overloaded unary negation.</summary>
 <param name="n">The value to negate.</param>
 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToChar``1(``0)">
 <summary>Converts the argument to <c>char</c>. Numeric inputs are converted using a checked 
 conversion according to the UTF-16 encoding for characters. String inputs must 
 be exactly one character long. For other input types the operation requires an 
 appropriate static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted char</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUIntPtr``1(``0)">
 <summary>Converts the argument to <c>unativeint</c>. This is a direct, checked conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted unativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToIntPtr``1(``0)">
 <summary>Converts the argument to <c>nativeint</c>. This is a direct, checked conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted nativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt64``1(``0)">
 <summary>Converts the argument to <c>uint64</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>System.UInt64.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted uint64</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt64``1(``0)">
 <summary>Converts the argument to <c>int64</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>System.Int64.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted int64</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt32``1(``0)">
 <summary>Converts the argument to <c>uint32</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>System.UInt32.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted uint32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt32``1(``0)">
 <summary>Converts the argument to <c>int32</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>System.Int32.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted int32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt``1(``0)">
 <summary>Converts the argument to <c>int</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>System.Int32.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted int</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt16``1(``0)">
 <summary>Converts the argument to <c>uint16</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>System.UInt16.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted uint16</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt16``1(``0)">
 <summary>Converts the argument to <c>int16</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>System.Int16.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted int16</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToSByte``1(``0)">
 <summary>Converts the argument to <c>sbyte</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>System.SByte.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted sbyte</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToByte``1(``0)">
 <summary>Converts the argument to <c>byte</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>System.Byte.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
 <param name="value">The input value.</param>
 <returns>The converted byte</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Multiply``3(``0,``1)">
 <summary>Overloaded multiplication operator (checks for overflow)</summary>
 <param name="x">The first value.</param>
 <param name="y">The second value.</param>
 <returns>The product of the two input values.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Addition``3(``0,``1)">
 <summary>Overloaded addition operator (checks for overflow)</summary>
 <param name="x">The first value.</param>
 <param name="y">The second value.</param>
 <returns>The sum of the two input values.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Subtraction``3(``0,``1)">
 <summary>Overloaded subtraction operator (checks for overflow)</summary>
 <param name="x">The first value.</param>
 <param name="y">The second value.</param>
 <returns>The first value minus the second value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_UnaryNegation``1(``0)">
 <summary>Overloaded unary negation (checks for overflow)</summary>
 <param name="value">The input value.</param>
 <returns>The negated value.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Checked">
 <summary>This module contains the basic arithmetic operations with overflow checks.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Hash``1(``0)">
 <summary>Perform generic hashing on a value where the type of the value is not 
 statically required to satisfy the 'equality' constraint. </summary>
 <returns>The computed hash value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Equals``1(``0,``0)">
 <summary>Perform generic equality on two values where the type of the values is not 
 statically required to satisfy the 'equality' constraint. </summary>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Compare``1(``0,``0)">
 <summary>Perform generic comparison on two values where the type of the values is not 
 statically required to have the 'comparison' constraint. </summary>
 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.DefaultOf``1">
 <summary>Generate a default value for any type. This is null for reference types, 
 For structs, this is struct value where all fields have the default value. 
 This function is unsafe in the sense that some F# values do not have proper <c>null</c> values.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Unchecked">
 <summary>This module contains basic operations which do not apply runtime and/or static checks</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowGeneric``1(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDecimal(System.Decimal,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'decimal'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDouble(System.Double,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'float'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSingle(System.Single,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'float32'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUIntPtr(System.UIntPtr,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'unativeint'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowIntPtr(System.IntPtr,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'nativeint'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt64(System.UInt64,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint64'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt64(System.Int64,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int64'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt32(System.UInt32,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint32'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt32(System.Int32,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int32'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt16(System.UInt16,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint16'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt16(System.Int16,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int16'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSByte(System.SByte,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'sbyte'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowByte(System.Byte,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'byte'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDynamic``2(``0,``1)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanhDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinhDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CoshDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CosDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SqrtDynamic``2(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Log10Dynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.LogDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SignDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RoundDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TruncateDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.FloorDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.ExpDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CeilingDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Atan2Dynamic``2(``0,``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AtanDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AsinDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AcosDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AbsDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeStepGeneric``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,``0,``1)">
 <summary>Generate a range of values using the given zero, add, start, step and stop values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeGeneric``1(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0,``0)">
 <summary>Generate a range of values using the given zero, add, start, step and stop values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeChar(System.Char,System.Char)">
 <summary>Generate a range of char values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeByte(System.Byte,System.Byte,System.Byte)">
 <summary>Generate a range of byte values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSByte(System.SByte,System.SByte,System.SByte)">
 <summary>Generate a range of sbyte values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt16(System.UInt16,System.UInt16,System.UInt16)">
 <summary>Generate a range of uint16 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt16(System.Int16,System.Int16,System.Int16)">
 <summary>Generate a range of int16 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUIntPtr(System.UIntPtr,System.UIntPtr,System.UIntPtr)">
 <summary>Generate a range of unativeint values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeIntPtr(System.IntPtr,System.IntPtr,System.IntPtr)">
 <summary>Generate a range of nativeint values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt32(System.UInt32,System.UInt32,System.UInt32)">
 <summary>Generate a range of uint32 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt64(System.UInt64,System.UInt64,System.UInt64)">
 <summary>Generate a range of uint64 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt64(System.Int64,System.Int64,System.Int64)">
 <summary>Generate a range of int64 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSingle(System.Single,System.Single,System.Single)">
 <summary>Generate a range of float32 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeDouble(System.Double,System.Double,System.Double)">
 <summary>Generate a range of float values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt32(System.Int32,System.Int32,System.Int32)">
 <summary>Generate a range of integers</summary>  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetStringSlice(System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice from a string</summary>
 <param name="source">The source string.</param>
 <param name="start">The index of the first character of the slice.</param>
 <param name="finish">The index of the last character of the slice.</param>
 <returns>The substring from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4D``1(``0[0:,0:,0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:,0:,0:,0:])">
 <summary>Sets a slice of an array</summary>
 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4D``1(``0[0:,0:,0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice of an array</summary>
 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <returns>The four dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3D``1(``0[0:,0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:,0:,0:])">
 <summary>Sets a slice of an array</summary>
 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3D``1(``0[0:,0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice of an array</summary>
 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <returns>The three dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice2D``1(``0[0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:,0:])">
 <summary>Sets a slice of an array</summary>
 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice2D``1(``0[0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice of an array</summary>
 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <returns>The two dimensional sub array from the input indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice``1(``0[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[])">
 <summary>Sets a slice of an array</summary>
 <param name="target">The target array.</param>
 <param name="start">The start index.</param>
 <param name="finish">The end index.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice``1(``0[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice of an array</summary>
 <param name="source">The input array.</param>
 <param name="start">The start index.</param>
 <param name="finish">The end index.</param>
 <returns>The sub array from the input indices.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.OperatorIntrinsics">
 <summary>A module of compiler intrinsic functions for efficient implementations of F# integer ranges
 and dynamic invocations of other F# operators</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators">
 <summary>Basic F# Operators. This module is automatically opened in all F# code.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.Invoke(`0,`1,`2,`3,`4)">
 <summary>Invoke an F# first class function value that accepts five curried arguments 
 without intervening execution</summary>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <param name="arg4">The fourth arg.</param>
 <param name="arg5">The fifth arg.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.Adapt(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{`2,Microsoft.FSharp.Core.FSharpFunc`2{`3,Microsoft.FSharp.Core.FSharpFunc`2{`4,`5}}}}})">
 <summary>Adapt an F# first class function value to be an optimized function value that can 
 accept five curried arguments without intervening execution. </summary>
 <param name="func">The input function.</param>
 <returns>The optimized function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.#ctor">
 <summary>Construct an optimized function value that can accept five curried 
 arguments without intervening execution.</summary>
 <returns>The optimized function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6">
 <summary>The CLI type used to represent F# function values that accept five curried arguments 
 without intervening execution. This type should not typically used directly from 
 either F# code or from other CLI languages.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.Invoke(`0,`1,`2,`3)">
 <summary>Invoke an F# first class function value that accepts four curried arguments 
 without intervening execution</summary>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <param name="arg4">The fourth arg.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.Adapt(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{`2,Microsoft.FSharp.Core.FSharpFunc`2{`3,`4}}}})">
 <summary>Adapt an F# first class function value to be an optimized function value that can 
 accept four curried arguments without intervening execution. </summary>
 <param name="func">The input function.</param>
 <returns>The optimized function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.#ctor">
 <summary>Construct an optimized function value that can accept four curried 
 arguments without intervening execution.</summary>
 <returns>The optimized function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5">
 <summary>The CLI type used to represent F# function values that accept four curried arguments 
 without intervening execution. This type should not typically used directly from 
 either F# code or from other CLI languages.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.Invoke(`0,`1,`2)">
 <summary>Invoke an F# first class function value that accepts three curried arguments 
 without intervening execution</summary>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.Adapt(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{`2,`3}}})">
 <summary>Adapt an F# first class function value to be an optimized function value that can 
 accept three curried arguments without intervening execution. </summary>
 <param name="func">The input function.</param>
 <returns>The adapted function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.#ctor">
 <summary>Construct an optimized function value that can accept three curried 
 arguments without intervening execution.</summary>
 <returns>The optimized function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4">
 <summary>The CLI type used to represent F# function values that accept
 three iterated (curried) arguments without intervening execution. This type should not
 typically used directly from either F# code or from other CLI languages.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.Invoke(`0,`1)">
 <summary>Invoke the optimized function value with two curried arguments </summary>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.Adapt(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,`2}})">
 <summary>Adapt an F# first class function value to be an optimized function value that can 
 accept two curried arguments without intervening execution. </summary>
 <param name="func">The input function.</param>
 <returns>The adapted function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.#ctor">
 <summary>Construct an optimized function value that can accept two curried 
 arguments without intervening execution.</summary>
 <returns>The optimized function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3">
 <summary>The CLI type used to represent F# function values that accept
 two iterated (curried) arguments without intervening execution. This type should not
 typically used directly from either F# code or from other CLI languages.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures">
 <summary>An implementation module used to hold some private implementations of function
 value invocation.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToList``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert the option to a list of length 0 or 1.</summary>
 <param name="option">The input option.</param>
 <returns>The result list.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToArray``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert the option to an array of length 0 or 1.</summary>
 <param name="option">The input option.</param>
 <returns>The result array.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Bind``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>bind f inp</c> evaluates to <c>match inp with None -> None | Some x -> f x</c></summary>
 <param name="binder">A function that takes the value of type T from an option and transforms it into
 an option containing a value of type U.</param>
 <param name="option">The input option.</param>
 <returns>An option of the output type of the binder.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>map f inp</c> evaluates to <c>match inp with None -> None | Some x -> Some (f x)</c>.</summary>
 <param name="mapping">A function to apply to the option value.</param>
 <param name="option">The input option.</param>
 <returns>An option of the input value after applying the mapping function, or None if the input is None.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>iter f inp</c> executes <c>match inp with None -> () | Some x -> f x</c>.</summary>
 <param name="action">A function to apply to the option value.</param>
 <param name="option">The input option.</param>
 <returns>Unit if the option is None, otherwise it returns the result of applying the predicate
 to the option value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>forall p inp" evaluates to "match inp with None -> true | Some x -> p x</c>.</summary>
 <param name="predicate">A function that evaluates to a boolean when given a value from the option type.</param>
 <param name="option">The input option.</param>
 <returns>True if the option is None, otherwise it returns the result of applying the predicate
 to the option value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>exists p inp</c> evaluates to <c>match inp with None -> false | Some x -> p x</c>.</summary>
 <param name="predicate">A function that evaluates to a boolean when given a value from the option type.</param>
 <param name="option">The input option.</param>
 <returns>False if the option is None, otherwise it returns the result of applying the predicate
 to the option value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},Microsoft.FSharp.Core.FSharpOption{``0},``1)">
 <summary><c>fold f inp s</c> evaluates to <c>match inp with None -> s | Some x -> f x s</c>.</summary>
 <param name="folder">A function to update the state data when given a value from an option.</param>
 <param name="option">The input option.</param>
 <param name="state">The initial state.</param>
 <returns>The original state if the option is None, otherwise it returns the updated state with the folder
 and the option value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>fold f s inp</c> evaluates to <c>match inp with None -> s | Some x -> f s x</c>.</summary>
 <param name="folder">A function to update the state data when given a value from an option.</param>
 <param name="state">The initial state.</param>
 <param name="option">The input option.</param>
 <returns>The original state if the option is None, otherwise it returns the updated state with the folder
 and the option value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Count``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>count inp</c> evaluates to <c>match inp with None -> 0 | Some _ -> 1</c>.</summary>
 <param name="option">The input option.</param>
 <returns>A zero if the option is None, a one otherwise.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.GetValue``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Gets the value associated with the option.</summary>
 <param name="option">The input option.</param>
 <returns>The value within the option.</returns>
 <exception href="System.ArgumentException">Thrown when the option is None.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.IsNone``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Returns true if the option is None.</summary>
 <param name="option">The input option.</param>
 <returns>True if the option is None.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.IsSome``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Returns true if the option is not None.</summary>
 <param name="option">The input option.</param>
 <returns>True if the option is not None.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptionModule">
 <summary>Basic operations on options.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.TextWriterFormat`1">
 <summary>Represents a statically-analyzed format associated with writing to a <c>System.IO.TextWriter</c>. The type parameter indicates the
 arguments and return type of the format operation.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.StringFormat`1">
 <summary>Represents a statically-analyzed format when formatting builds a string. The type parameter indicates the
 arguments and return type of the format operation.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.BuilderFormat`1">
 <summary>Represents a statically-analyzed format associated with writing to a <c>System.Text.StringBuilder</c>. The type parameter indicates the
 arguments and return type of the format operation.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.TextWriterFormat`2">
 <summary>Represents a statically-analyzed format associated with writing to a <c>System.IO.TextWriter</c>. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.StringFormat`2">
 <summary>Represents a statically-analyzed format when formatting builds a string. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.BuilderFormat`2">
 <summary>Represents a statically-analyzed format associated with writing to a <c>System.Text.StringBuilder</c>. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThenFail``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
 <summary>Print to a string buffer and raise an exception with the given
 result. Helper printers must return strings.</summary>
 <param name="format">The input formatter.</param>
 <returns>The arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThen``2(Microsoft.FSharp.Core.FSharpFunc`2{System.String,``0},Microsoft.FSharp.Core.PrintfFormat{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
 <summary>sprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.</summary>
 <param name="continutation">The function called to generate a result from the formatted string.</param>
 <param name="format">The input formatter.</param>
 <returns>The arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatThen``2(Microsoft.FSharp.Core.FSharpFunc`2{System.String,``0},Microsoft.FSharp.Core.PrintfFormat{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
 <summary>printf, but call the given 'final' function to generate the result.
 For example, these let the printing force a flush after all output has 
 been entered onto the channel, but not before. </summary>
 <param name="continutation">The function called after formatting to generate the format result.</param>
 <param name="format">The input formatter.</param>
 <returns>The arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToTextWriterThen``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0},System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
 <summary>fprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.</summary>
 <param name="continutation">The function called after formatting to generate the format result.</param>
 <param name="textWriter">The input TextWriter.</param>
 <param name="format">The input formatter.</param>
 <returns>The arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringBuilderThen``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0},System.Text.StringBuilder,Microsoft.FSharp.Core.PrintfFormat{``1,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,``0})">
 <summary>bprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.</summary>
 <param name="continutation">The function called after formatting to generate the format result.</param>
 <param name="builder">The input StringBuilder.</param>
 <param name="format">The input formatter.</param>
 <returns>The arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThen``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
 <summary>Print to a string via an internal string buffer and return 
 the result as a string. Helper printers must return strings.</summary>
 <param name="format">The input formatter.</param>
 <returns>The formatted string.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLine``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Formatted printing to stdout, adding a newline.</summary>
 <param name="format">The input formatter.</param>
 <returns>The return type and arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormat``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Formatted printing to stdout</summary>
 <param name="format">The input formatter.</param>
 <returns>The return type and arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Formatted printing to stderr, adding a newline </summary>
 <param name="format">The input formatter.</param>
 <returns>The return type and arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Formatted printing to stderr</summary>
 <param name="format">The input formatter.</param>
 <returns>The return type and arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a text writer, adding a newline</summary>
 <param name="textWriter">The TextWriter to print to.</param>
 <param name="format">The input formatter.</param>
 <returns>The return type and arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a text writer.</summary>
 <param name="textWriter">The TextWriter to print to.</param>
 <param name="format">The input formatter.</param>
 <returns>The return type and arguments of the formatter.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringBuilder``1(System.Text.StringBuilder,Microsoft.FSharp.Core.PrintfFormat{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a <c>System.Text.StringBuilder</c></summary>
 <param name="builder">The StringBuilder to print to.</param>
 <param name="format">The input formatter.</param>
 <returns>The return type and arguments of the formatter.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule">
 <summary>Extensible printf-style formatting for numbers and other datatypes</summary>

 <remarks>Format specifications are strings with "%" markers indicating format 
 placeholders. Format placeholders consist of:
  <c>
    %[flags][width][.precision][type]
  </c>
 where the type is interpreted as follows:
  <c>
     %b:         bool, formatted as "true" or "false"
     %s:         string, formatted as its unescaped contents
     %d, %i:     any basic integer type formatted as a decimal integer, signed if the basic integer type is signed.
     %u:         any basic integer type formatted as an unsigned decimal integer
     %x, %X, %o: any basic integer type formatted as an unsigned hexadecimal 
                 (a-f)/Hexadecimal (A-F)/Octal integer
 
     %e, %E, %f, %F, %g, %G: 
                 any basic floating point type (float,float32) formatted
                 using a C-style floating point format specifications, i.e
 
     %e, %E: Signed value having the form [-]d.dddde[sign]ddd where 
                 d is a single decimal digit, dddd is one or more decimal
                 digits, ddd is exactly three decimal digits, and sign 
                 is + or -
 
     %f:     Signed value having the form [-]dddd.dddd, where dddd is one
                 or more decimal digits. The number of digits before the 
                 decimal point depends on the magnitude of the number, and 
                 the number of digits after the decimal point depends on 
                 the requested precision.
 
     %g, %G: Signed value printed in f or e format, whichever is 
                 more compact for the given value and precision.
 
 
    %M:      System.Decimal value
 
    %O:      Any value, printed by boxing the object and using it's ToString method(s)
 
    %A:      Any value, printed with the default layout settings 
 
    %a:      A general format specifier, requires two arguments:
                 (1) a function which accepts two arguments:
                     (a) a context parameter of the appropriate type for the
                         given formatting function (e.g. an #System.IO.TextWriter)
                     (b) a value to print
                         and which either outputs or returns appropriate text.
 
                 (2) the particular value to print
 
 
    %t:      A general format specifier, requires one argument:
                 (1) a function which accepts a context parameter of the
                     appropriate type for the given formatting function (e.g. 
                     an System.IO.TextWriter)and which either outputs or returns 
                     appropriate text.

  Basic integer types are:
     byte,sbyte,int16,uint16,int32,uint32,int64,uint64,nativeint,unativeint
  Basic floating point types are:
     float, float32
 </c>
 The optional width is an integer indicating the minimal width of the
 result. For instance, %6d prints an integer, prefixing it with spaces
 to fill at least 6 characters. If width is '*', then an extra integer
 argument is taken to specify the corresponding width.
 <c>
     any number
     '*': 
 </c>
 Valid flags are:
 <c>
     0: add zeros instead of spaces to make up the required width
     '-': left justify the result within the width specified
     '+': add a '+' character if the number is positive (to match a '-' sign 
          for negatives)
     ' ': add an extra space if the number is positive (to match a '-' 
              sign for negatives)
 </c>
 The printf '#' flag is invalid and a compile-time error will be reported if it is used.</remarks>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.SR">

</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Length(System.String)">
 <summary>Returns the length of the string.</summary>
 <param name="str">The input string.</param>
 <returns>The number of characters in the string.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input string is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Replicate(System.Int32,System.String)">
 <summary>Returns a string by concatenating <c>count</c> instances of <c>str</c>.</summary>
 <param name="count">The number of copies of the input string will be copied.</param>
 <param name="str">The input string.</param>
 <returns>The concatenated string.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input string is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Exists(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
 <summary>Tests if any character of the string satisfies the given predicate.</summary>
 <param name="predicate">The function to test each character of the string.</param>
 <param name="str">The input string.</param>
 <returns>True if any character returns true for the predicate and false otherwise.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input string is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.ForAll(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
 <summary>Tests if all characters in the string satisfy the given predicate.</summary>
 <param name="predicate">The function to test each character of the string.</param>
 <param name="str">The input string.</param>
 <returns>True if all characters return true for the predicate and false otherwise.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input string is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Initialize(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.String})">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each index from <c>0</c> to <c>count-1</c> and concatenating the resulting
 strings.</summary>
 <param name="count">The number of strings to initialize.</param>
 <param name="initializer">The function to take an index and produce a string to
 be concatenated with the others.</param>
 <returns>The constructed string.</returns>
 <exception cref="System.ArgumentException">Thrown when <c>count</c> is negative.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Collect(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.String},System.String)">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each of the characters of the input string and concatenating the resulting
 strings.</summary>
 <param name="mapping">The function to produce a string from each character of the input string.</param>
 <param name="str">The input string.</param>
 <returns>The concatenated string.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input string is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.MapIndexed(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Char}},System.String)">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each character and index of the input string.</summary>
 <param name="mapping">The function to apply to each character and index of the string.</param>
 <param name="str">The input string.</param>
 <returns>The resulting string.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input string is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Map(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Char},System.String)">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each of the characters of the input string.</summary>
 <param name="mapping">The function to apply to the characters of the string.</param>
 <param name="str">The input string.</param>
 <returns>The resulting string.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input string is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.IterateIndexed(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,Microsoft.FSharp.Core.Unit}},System.String)">
 <summary>Applies the function <c>action</c> to the index of each character in the string and the
 character itself.</summary>
 <param name="action">The function to apply to each character and index of the string.</param>
 <param name="str">The input string.</param>
 <exception cref="System.ArgumentNullException">Thrown when the input string is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Iterate(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,Microsoft.FSharp.Core.Unit},System.String)">
 <summary>Applies the function <c>action</c> to each character in the string.</summary>
 <param name="action">The function to be applied to each character of the string.</param>
 <param name="str">The input string.</param>
 <exception cref="System.ArgumentNullException">Thrown when the input string is null.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Concat(System.String,System.Collections.Generic.IEnumerable{System.String})">
 <summary>Returns a new string made by concatenating the given strings
 with separator <c>sep</c>, that is <c>a1 + sep + ... + sep + aN</c>.</summary>
 <param name="sep">The separator string to be inserted between the strings
 of the input sequence.</param>
 <param name="strings">The sequence of strings to be concatenated.</param>
 <returns>A new string consisting of the concatenated strings separated by
 the separation string.</returns>
 <exception cref="System.ArgumentNullException">Thrown when strings is null.</exception>
</member>
<member name="T:Microsoft.FSharp.Core.StringModule">
 <summary>Functional programming operators for string processing.  Further string operations
 are available via the member functions on strings and other functionality in
  <a href="http://msdn2.microsoft.com/en-us/library/system.string.aspx">System.String</a> 
 and <a href="http://msdn2.microsoft.com/library/system.text.regularexpressions.aspx">System.Text.RegularExpressions</a> types.</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.StackAllocate``1(System.Int32)">
 <summary>Allocates a region of memory on the stack.</summary>
 <param name="count">The number of objects of type T to allocate.</param>
 <returns>A typed pointer to the allocated memory.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.SetPointerInlined``1(``0*,System.Int32,``0)">
 <summary>Assigns the <c>value</c> into the memory location referenced by the typed native 
 pointer computed by adding index * sizeof&lt;'T&gt; to the given input pointer.</summary>
 <param name="address">The input pointer.</param>
 <param name="index">The index by which to offset the pointer.</param>
 <param name="value">The value to assign.</param>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.WritePointerInlined``1(``0*,``0)">
 <summary>Assigns the <c>value</c> into the memory location referenced by the given typed native pointer.</summary>
 <param name="address">The input pointer.</param>
 <param name="value">The value to assign.</param>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ReadPointerInlined``1(``0*)">
 <summary>Dereferences the given typed native pointer.</summary>
 <param name="address">The input pointer.</param>
 <returns>The value at the pointer address.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.GetPointerInlined``1(``0*,System.Int32)">
 <summary>Dereferences the typed native pointer computed by adding index * sizeof&lt;'T&gt; to the 
 given input pointer.</summary>
 <param name="address">The input pointer.</param>
 <param name="index">The index by which to offset the pointer.</param>
 <returns>The value at the pointer address.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.AddPointerInlined``1(``0*,System.Int32)">
 <summary>Returns a typed native pointer by adding index * sizeof&lt;'T&gt; to the 
 given input pointer.</summary>
 <param name="address">The input pointer.</param>
 <param name="index">The index by which to offset the pointer.</param>
 <returns>A typed pointer.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ToNativeIntInlined``1(``0*)">
 <summary>Returns a machine address for a given typed native pointer.</summary>
 <param name="address">The input pointer.</param>
 <returns>The machine address.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.OfNativeIntInlined``1(System.IntPtr)">
 <summary>Returns a typed native pointer for a given machine address.</summary>
 <param name="address">The pointer address.</param>
 <returns>A typed pointer.</returns>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativePtrModule">
 <summary>Contains operations on native pointers. Use of these operators may
 result in the generation of unverifiable code.</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.Array">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.List">

</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr`1.Raw">
 <summary>Gets the raw expression associated with this type-carrying expression</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpExpr`1">
 <summary>Type-carrying quoted expressions. Expressions are generated either
 by quotations in source text or programatically</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr.Type">
 <summary>Returns type of an expression.</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr.CustomAttributes">
 <summary>Returns the custom attributes of an expression.</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.WhileLoop(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a while loop</summary>
 <param name="guard">The predicate to control the loop iteration.</param>
 <param name="body">The body of the while loop.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.VarSet(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents setting a mutable variable</summary>
 <param name="variable">The input variable.</param>
 <param name="value">The value to set.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Var(Microsoft.FSharp.Quotations.FSharpVar)">
 <summary>Builds an expression that represents a variable</summary>
 <param name="variable">The input variable.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Value``1(``0)">
 <summary>Builds an expression that represents a constant value </summary>
 <param name="value">The typed value.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Value(System.Object,System.Type)">
 <summary>Builds an expression that represents a constant value of a particular type</summary>
 <param name="value">The untyped object.</param>
 <param name="expressionType">The type of the object.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.UnionCaseTest(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Reflection.UnionCaseInfo)">
 <summary>Builds an expression that represents a test of a value is of a particular union case</summary>
 <param name="source">The expression to test.</param>
 <param name="unionCase">The description of the union case.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TypeTest(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)">
 <summary>Builds an expression that represents a type test.</summary>
 <param name="source">The expression to test.</param>
 <param name="target">The target type.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TupleGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Int32)">
 <summary>Builds an expression that represents getting a field of a tuple</summary>
 <param name="tuple">The input tuple.</param>
 <param name="index">The index of the tuple element to get.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryWith(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a try/with construct for exception filtering and catching.</summary>
 <param name="body">The body of the try expression.</param>
 <param name="filterVar"></param>
 <param name="filterBody"></param>
 <param name="catchVar">The variable to bind to a caught exception.</param>
 <param name="catchBody">The expression evaluated when an exception is caught.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryGetReflectedDefinition(System.Reflection.MethodBase)">
 <summary>Try and find a stored reflection definition for the given method. Stored reflection
 definitions are added to an F# assembly through the use of the [&lt;ReflectedDefinition&gt;] attribute.</summary>
 <param name="methodBase">The description of the method to find.</param>
 <returns>The reflection definition or None if a match could not be found.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryFinally(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a try/finally construct </summary>
 <param name="body">The body of the try expression.</param>
 <param name="compensation">The final part of the expression to be evaluated.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Substitute(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Substitutes through the given expression using the given functions
 to map variables to new values. The functions must give consistent results
 at each application. Variable renaming may occur on the target expression
 if variable capture occurs.</summary>
 <param name="substitution">The function to map variables into expressions.</param>
 <returns>The expression with the given substitutions.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Sequential(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents the sequential execution of one expression followed by another</summary>
 <param name="first">The first expression.</param>
 <param name="second">The second expression.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.RegisterReflectedDefinitions(System.Reflection.Assembly,System.String,System.Byte[])">
 <summary>Permits interactive environments such as F# Interactive
 to explicitly register new pickled resources that represent persisted 
 top level definitions. The string indicates a unique name for the resources
 being added. The format for the bytes is the encoding generated by the F# compiler.</summary>
 <param name="assembly">The assembly associated with the resource.</param>
 <param name="resource">The unique name for the resources being added.</param>
 <param name="serializedValue">The serialized resource to register with the environment.</param>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Quote(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a nested quotation literal</summary>
 <param name="inner">The expression being quoted.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents writing to a static property </summary>
 <param name="property">The description of the property.</param>
 <param name="value">The value to set.</param>
 <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents writing to a property of an object</summary>
 <param name="obj">The input object.</param>
 <param name="property">The description of the property.</param>
 <param name="value">The value to set.</param>
 <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents reading a static property </summary>
 <param name="property">The description of the property.</param>
 <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents reading a property of an object</summary>
 <param name="obj">The input object.</param>
 <param name="property">The description of the property.</param>
 <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewUnionCase(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents the creation of a union case value</summary>
 <param name="unionCase">The description of the union case.</param>
 <param name="arguments">The list of arguments for the case.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewTuple(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents the creation of an F# tuple value</summary>
 <param name="elements">The list of elements of the tuple.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewRecord(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds record-construction expressions </summary>
 <param name="recordType">The type of record.</param>
 <param name="elements">The list of elements of the record.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewObject(System.Reflection.ConstructorInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents the invocation of an object constructor</summary>
 <param name="constructorInfo">The description of the constructor.</param>
 <param name="arguments">The list of arguments to the constructor.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewDelegate(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpVar},Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents the creation of a delegate value for the given type</summary>
 <param name="delegateType">The type of delegate.</param>
 <param name="parameters">The parameters for the delegate.</param>
 <param name="body">The body of the function.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewArray(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents the creation of an array value initialized with the given elements</summary>
 <param name="elementType">The type for the elements of the array.</param>
 <param name="elements">The list of elements of the array.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.LetRecursive(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr}},Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds recursives expressions associated with 'let rec' constructs</summary>
 <param name="bindings">The list of bindings for the let expression.</param>
 <param name="body">The sub-expression where the bindings are in scope.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Let(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds expressions associated with 'let' constructs</summary>
 <param name="letVariable">The variable in the let expression.</param>
 <param name="letExpr">The expression bound to the variable.</param>
 <param name="body">The sub-expression where the binding is in scope.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Lambda(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents the constrution of an F# function value</summary>
 <param name="parameter">The parameter to the function.</param>
 <param name="body">The body of the function.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.IfThenElse(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds 'if ... then ... else' expressions.</summary>
 <param name="guard">The condition expression.</param>
 <param name="thenExpr">The <c>then</c> sub-expression.</param>
 <param name="elseExpr">The <c>else</c> sub-expression.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.GlobalVar``1(System.String)">
 <summary>Fetches or creates a new variable with the given name and type from a global pool of shared variables
 indexed by name and type. The type is given by the expicit or inferred type parameter</summary>
 <param name="name">The variable name.</param>
 <returns>The created of fetched typed global variable.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.GetFreeVars">
 <summary>Gets the free expression variables of an expression as a list.</summary>
 <returns>A sequence of the free variables in the expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.ForIntegerRangeLoop(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds a 'for i = ... to ... do ...' expression that represent loops over integer ranges</summary>
 <param name="loopVariable">The sub-expression declaring the loop variable.</param>
 <param name="start">The sub-expression setting the initial value of the loop variable.</param>
 <param name="endExpr">The sub-expression declaring the final value of the loop variable.</param>
 <param name="body">The sub-expression representing the body of the loop.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents writing to a field of an object</summary>
 <param name="obj">The input object.</param>
 <param name="fieldInfo">The description of the field to write to.</param>
 <param name="value">The value to set to the field.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents writing to a static field </summary>
 <param name="fieldInfo">The description of the field to write to.</param>
 <param name="value">The value to the set to the field.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo)">
 <summary>Builds an expression that represents the access of a field of an object</summary>
 <param name="obj">The input object.</param>
 <param name="fieldInfo">The description of the field to access.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(System.Reflection.FieldInfo)">
 <summary>Builds an expression that represents the access of a static field</summary>
 <param name="fieldInfo">The description of the field to access.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Deserialize(System.Type,Microsoft.FSharp.Collections.FSharpList{System.Type},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},System.Byte[])">
 <summary>This function is called automatically when quotation syntax (&lt;@ @&gt;) and related typed-expression
 quotations are used. The bytes are a pickled binary representation of an unlinked form of the quoted expression,
 and the System.Type argument is any type in the assembly where the quoted
 expression occurs, i.e. it helps scope the interpretation of the cross-assembly
 references in the bytes.</summary>
 <param name="qualifyingType">A type in the assembly where the quotation occurs.</param>
 <param name="spliceTypes">The list of spliced types.</param>
 <param name="spliceExprs">The list of spliced expressions.</param>
 <param name="bytes">The serialized form of the quoted expression.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.DefaultValue(System.Type)">
 <summary>Builds an expression that represents the invocation of a default object constructor</summary>
 <param name="expressionType">The type on which the constructor is invoked.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Coerce(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)">
 <summary>Builds an expression that represents the coercion of an expression to a type</summary>
 <param name="source">The expression to coerce.</param>
 <param name="target">The target type.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Cast``1(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Returns a new typed expression given an underlying runtime-typed expression.
 A type annotation is usually required to use this function, and 
 using an incorrect type annotation may result in a later runtime exception.</summary>
 <param name="source">The expression to cast.</param>
 <returns>The resulting typed expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents a call to an instance method associated with an object</summary>
 <param name="obj">The input object.</param>
 <param name="methodInfo">The description of the method to call.</param>
 <param name="arguments">The list of arguments to the method.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents a call to an static method or module-bound function</summary>
 <param name="methodInfo">The MethodInfo describing the method to call.</param>
 <param name="arguments">The list of arguments to the method.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Applications(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents the application of a first class function value to multiple arguments</summary>
 <param name="functionExpr">The function to apply.</param>
 <param name="arguments">The list of lists of arguments to the function.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Application(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents the application of a first class function value to a single argument.</summary>
 <param name="functionExpr">The function to apply.</param>
 <param name="argument">The argument to the function.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressSet(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents setting the value held at a particular address.</summary>
 <param name="target">The target expression.</param>
 <param name="value">The value to set at the address.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressOf(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents getting the address of a value.</summary>
 <param name="target">The target expression.</param>
 <returns>The resulting expression.</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpExpr">
 <summary>Quoted expressions annotated with System.Type values. </summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Type">
 <summary>The type associated with the variable</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Name">
 <summary>The declared name of the variable</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.IsMutable">
 <summary>Indicates if the variable represents a mutable storage location</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar.Global(System.String,System.Type)">
 <summary>Fetches or create a new variable with the given name and type from a global pool of shared variables
 indexed by name and type</summary>
 <param name="name">The name of the variable.</param>
 <param name="typ">The type associated with the variable.</param>
 <returns>The retrieved or created variable.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar.#ctor(System.String,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Creates a new variable with the given name, type and mutability</summary>
 <param name="name">The declared name of the variable.</param>
 <param name="typ">The type associated with the variable.</param>
 <param name="isMutable">Indicates if the variable represents a mutable storage location. Default is false.</param>
 <returns>The created variable.</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpVar">
 <summary>Information at the binding site of a variable</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.RebuildShapeCombination(System.Object,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Re-build combination expressions. The first parameter should be an object
 returned by the <c>ShapeCombination</c> case of the active pattern in this module.</summary>
 <param name="shape">The input shape.</param>
 <param name="arguments">The list of arguments.</param>
 <returns>The rebuilt expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.ShapePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern that performs a complete decomposition viewing the expression tree as a binding structure</summary>
 <param name="input">The input expression.</param>
 <returns>The decomposed Var, Lambda, or ConstApp.</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.ExprShapeModule">
 <summary>Active patterns for traversing, visiting, rebuilding and tranforming expressions in a generic way</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertySetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
 <summary>An active pattern to recognize property setters that have an associated ReflectedDefinition</summary>
 <param name="propertyInfo">The description of the property.</param>
 <returns>The expression of the method definition if found, or None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertyGetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
 <summary>An active pattern to recognize property getters or values in modules that have an associated ReflectedDefinition</summary>
 <param name="propertyInfo">The description of the property.</param>
 <returns>The expression of the method definition if found, or None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.MethodWithReflectedDefinitionPattern(System.Reflection.MethodBase)">
 <summary>An active pattern to recognize methods that have an associated ReflectedDefinition</summary>
 <param name="methodBase">The description of the method.</param>
 <returns>The expression of the method definition if found, or None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SpecificCallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>A parameterized active pattern to recognize calls to a specified function or method.
 The returned elements are the optional target object (present if the target is an 
 instance method), the generic type instantation (non-empty if the target is a generic
 instantiation), and the arguments to the function or method.</summary>
 <param name="templateParameter">The input template expression to specify the method to call.</param>
 <returns>The optional target object (present if the target is an 
 instance method), the generic type instantation (non-empty if the target is a generic
 instantiation), and the arguments to the function or method.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unsigned int64 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>uint64 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant int64 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>int64 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unsigned int32 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>uint32 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant int32 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>int32 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unsigned int16 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>uint16 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant int16 expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>int16 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant byte expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>byte option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SBytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant signed byte expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>sbyte option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.CharPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unicode character expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>char  option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.DoublePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant 64-bit floating point number expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>float option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SinglePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant 32-bit floating point number expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>float32 option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.StringPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant string expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>string option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BoolPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant boolean expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>bool option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UnitPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize <c>()</c> constant expressions</summary>
 <param name="input">The input expression to match against.</param>
 <returns>unit option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.OrElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions of the form <c>a || b</c> </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.AndAlsoPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions of the form <c>a &amp;&amp; b</c> </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.ApplicationsPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent the application of a (possibly curried or tupled) first class function value</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr list list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.LambdasPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a (possibly curried or tupled) first class function value</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var list list * Expr) option</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.DerivedPatternsModule">
 <summary>Contains a set of derived F# active patterns to analyze F# expression objects</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting a mutable variable</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a variable</summary>
 <param name="input">The input expression to match against.</param>
 <returns>Var option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a constant value</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(obj * Type) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.UnionCaseTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a test if a value is of a particular union case</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * UnionCaseInfo) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TypeTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a dynamic type test</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Type) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TupleGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent getting a tuple field</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * int) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryFinallyPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a try/finally construct </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryWithPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a try/with construct for exception filtering and catching </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Var * Expr * Var * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.SequentialPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent sequential exeuction of one expression followed by another</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.QuotePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a nested quotation literal</summary>
 <param name="input">The input expression to match against.</param>
 <returns>Expr option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertySetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting a static or instance property, or a non-function value declared in a module</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * PropertyInfo * Expr list * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertyGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent the read of a static or instance property, or a non-function value declared in a module</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * PropertyInfo * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewTuplePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of tuple values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewUnionCasePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of particular union case values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(UnionCaseInfo * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewRecordPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of record values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Type * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewObjectPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent invocation of object constructors</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(ConstructorInfo * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewDelegatePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of delegate values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Type * Var list * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.DefaultValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent invocations of a default constructor of a struct</summary>
 <param name="input">The input expression to match against.</param>
 <returns>Type option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewArrayPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent the construction of arrays </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Type * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetRecursivePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent recursive let bindings of one or more variables</summary>
 <param name="input">The input expression to match against.</param>
 <returns>((Var * Expr) list * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent let bindings</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var * Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LambdaPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent first class function values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.IfThenElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent conditionals</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.WhileLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent while loops </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ForIntegerRangeLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent loops over integer ranges</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Var * Expr * Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting a static or instance field </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * FieldInfo * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent getting a static or instance field </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * FieldInfo) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CoercePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent coercions from one type to another</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Type) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent calls to static and instance methods, and functions defined in modules</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr option * MethodInfo * Expr list) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ApplicationPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent applications of first class function values</summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting the value held at an address </summary>
 <param name="input">The input expression to match against.</param>
 <returns>(Expr * Expr) option</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressOfPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent getting the address of a value</summary>
 <param name="input">The input expression to match against.</param>
 <returns>Expr option</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.PatternsModule">
 <summary>Contains a set of primitive F# active patterns to analyze F# expression objects</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeTupleType(System.Type[])">
 <summary>Returns a <c>System.Type</c> representing an F# tuple type with the given element types</summary>
 <param name="types">An array of types for the tuple elements.</param>
 <returns>The type representing the tuple containing the input elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeFunctionType(System.Type,System.Type)">
 <summary>Returns a <c>System.Type</c> representing the F# function type with the given domain and range</summary>
 <param name="domain">The input type of the function.</param>
 <param name="range">The output type of the function.</param>
 <returns>The function type with the given domain and range.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsUnion(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Returns true if the <c>typ</c> is a representation of an F# union type or the runtime type of a value of that type</summary>
 <param name="typ">The type to check.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsTuple(System.Type)">
 <summary>Return true if the <c>typ</c> is a representation of an F# tuple type </summary>
 <param name="typ">The type to check.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsRecord(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Return true if the <c>typ</c> is a representation of an F# record type </summary>
 <param name="typ">The type to check.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsModule(System.Type)">
 <summary>Return true if the <c>typ</c> is a <c>System.Type</c> value corresponding to the compiled form of an F# module </summary>
 <param name="typ">The type to check.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsFunction(System.Type)">
 <summary>Return true if the <c>typ</c> is a representation of an F# function type or the runtime type of a closure implementing an F# function type</summary>
 <param name="typ">The type to check.</param>
 <returns>True if the type check succeeds.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsExceptionRepresentation(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Returns true if the <c>typ</c> is a representation of an F# exception declaration</summary>
 <param name="exceptionType">The type to check.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>True if the type check is an F# exception.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetUnionCases(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Gets the cases of a union type.</summary>

 <remarks>Assumes the given type is a union type. If not, ArgumentException is raised during pre-computation.</remarks>
 <param name="unionType">The input union type.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a union type.</exception>
 <returns>An array of descriptions of the cases of the given union type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetTupleElements(System.Type)">
 <summary>Gets the tuple elements from the representation of an F# tuple type.</summary>
 <param name="tupleType">The input tuple type.</param>
 <returns>An array of the types contained in the given tuple type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetRecordFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from a record value, in declaration order</summary>

 <remarks>Assumes the given input is a record value. If not, ArgumentException is raised.</remarks>
 <param name="recordType">The input record type.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>An array of descriptions of the properties of the record type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetFunctionElements(System.Type)">
 <summary>Gets the domain and range types from an F# function type  or from the runtime type of a closure implementing an F# type</summary>
 <param name="functionType">The input function type.</param>
 <returns>A tuple of the domain and range types of the input function.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetExceptionFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from an F# exception declaration, in declaration order</summary>

 <remarks>Assumes <c>exceptionType</c> is an exception representation type. If not, ArgumentException is raised.</remarks>
 <param name="exceptionType">The exception type to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown if the given type is not an exception.</exception>
 <returns>An array containing the PropertyInfo of each field in the exception.</returns>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpType">
 <summary>Contains operations associated with constructing and analyzing F# types such as records, unions and tuples</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Assumes the given type is a union type. 
 If not, ArgumentException is raised during pre-computation.</summary>

 <remarks>Using the computed function is more efficient than calling GetUnionCase
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>
 <param name="unionType">The type of union to optimize reading.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>An optimized function to read the tags of the given union type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagMemberInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a property or static method for reading an integer representing the case tag of a union type.</summary>
 <param name="unionType">The type of union to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>The description of the union case reader.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionReader(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precomputes a function for reading all the fields for a particular discriminator case of a union type</summary>

 <remarks>Using the computed function will typically be faster than executing a corresponding call to GetFields</remarks>
 <param name="unionCase">The description of the union case to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>A function to for reading the fields of the given union case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructorInfo(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>A method that constructs objects of the given case</summary>
 <param name="unionCase">The description of the union case.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>The description of the constructor of the given union case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructor(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precomputes a function for constructing a discriminated union value for a particular union case. </summary>
 <param name="unionCase">The description of the union case.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>A function for constructing values of the given union case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleReader(System.Type)">
 <summary>Precomputes a function for reading the values of a particular tuple type</summary>

 <remarks>Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.</remarks>
 <param name="tupleType">The tuple type to read.</param>
 <exception cref="System.ArgumentException">Thrown when the given type is not a tuple type.</exception>
 <returns>A function to read values of the given tuple type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTuplePropertyInfo(System.Type,System.Int32)">
 <summary>Gets information that indicates how to read a field of a tuple</summary>
 <param name="tupleType">The input tuple type.</param>
 <param name="index">The index of the tuple element to describe.</param>
 <returns>The description of the tuple element and an optional type and index if the tuple is big.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructorInfo(System.Type)">
 <summary>Gets a method that constructs objects of the given tuple type. 
 For small tuples, no additional type will be returned.</summary>
 
 <remarks>For large tuples, an additional type is returned indicating that
 a nested encoding has been used for the tuple type. In this case
 the suffix portion of the tuple type has the given type and an
 object of this type must be created and passed as the last argument 
 to the ConstructorInfo. A recursive call to PreComputeTupleConstructorInfo 
 can be used to determine the constructor for that the suffix type.</remarks>
 <param name="tupleType">The input tuple type.</param>
 <returns>The description of the tuple type constructor and an optional extra type
 for large tuples.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructor(System.Type)">
 <summary>Precomputes a function for reading the values of a particular tuple type</summary>

 <remarks>Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.</remarks>
 <param name="tupleType">The type of tuple to read.</param>
 <exception cref="System.ArgumentException">Thrown when the given type is not a tuple type.</exception>
 <returns>A function to read a particular tuple type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.</summary>

 <remarks>Assumes the given type is a RecordType. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>
 <param name="recordType">The type of record to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>An optimized reader for the given record type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordFieldReader(System.Reflection.PropertyInfo)">
 <summary>Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name. 
 If not, ArgumentException is raised during pre-computation.</summary>

 <remarks>Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>
 <param name="info">The PropertyInfo of the field to read.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>A function to read the specified field from the record.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructorInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Get a ConstructorInfo for a record type</summary>
 <param name="recordType">The record type.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>A ConstructorInfo for the given record type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructor(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a function for constructing a record value. </summary>

 <remarks>Assumes the given type is a RecordType.
 If not, ArgumentException is raised during pre-computation.</remarks>
 <param name="recordType">The type of record to construct.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>A function to construct records of the given type.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeUnion(Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Create a union case value.</summary>
 <param name="unionCase">The description of the union case to create.</param>
 <param name="args">The array of arguments to construct the given case.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <returns>The constructed union case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(System.Object[],System.Type)">
 <summary>Creates an instance of a tuple type</summary>

 <remarks>Assumes at least one element is given. If not, ArgumentException is raised.</remarks>
 <param name="tupleElements">The array of tuple fields.</param>
 <param name="tupleType">The tuple type to create.</param>
 <exception cref="System.ArgumentException">Thrown if no elements are given.</exception>
 <returns>An instance of the tuple type with the given elements.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeRecord(System.Type,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Creates an instance of a record type.</summary>

 <remarks>Assumes the given input is a record type.</remarks>
 <param name="recordType">The type of record to make.</param>
 <param name="values">The array of values to initialize the record.</param>
 <param name="bindingFlags">Optional binding flags for the record.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>The created record.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeFunction(System.Type,Microsoft.FSharp.Core.FSharpFunc`2{System.Object,System.Object})">
 <summary>Builds a typed function from object from a dynamic function implementation</summary>
 <param name="functionType">The function type of the implementation.</param>
 <param name="implementation">The untyped lambda of the function implementation.</param>
 <returns>A typed function from the given dynamic implementation.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetUnionFields(System.Object,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Identify the union case and its fields for an object</summary>

 <remarks>Assumes the given input is a union case value. If not, ArgumentException is raised.

 If the type is not given, then the runtime type of the input object is used to identify the
 relevant union type. The type should always be given if the input object may be null. For example, 
 option values may be represented using the 'null'.</remarks>
 <param name="value">The input union case.</param>
 <param name="unionType">The union type containing the value.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a union case value.</exception>
 <returns>The description of the union case and its fields.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleFields(System.Object)">
 <summary>Reads all fields from a tuple.</summary>

 <remarks>Assumes the given input is a tuple value. If not, ArgumentException is raised.</remarks>
 <param name="tuple">The input tuple.</param>
 <exception cref="System.ArgumentException">Thrown when the input is not a tuple value.</exception>
 <returns>An array of the fields from the given tuple.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleField(System.Object,System.Int32)">
 <summary>Reads a field from a tuple value.</summary>

 <remarks>Assumes the given input is a tuple value. If not, ArgumentException is raised.</remarks>
 <param name="tuple">The input tuple.</param>
 <param name="index">The index of the field to read.</param>
 <returns>The value of the field.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from a record value.</summary>

 <remarks>Assumes the given input is a record value. If not, ArgumentException is raised.</remarks>
 <param name="record">The record object.</param>
 <param name="bindingFlags">Optional binding flags for the record.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>The array of fields from the record.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordField(System.Object,System.Reflection.PropertyInfo)">
 <summary>Reads a field from a record value.</summary>

 <remarks>Assumes the given input is a record value. If not, ArgumentException is raised.</remarks>
 <param name="record">The record object.</param>
 <param name="info">The PropertyInfo describing the field to read.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
 <returns>The field from the record.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetExceptionFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from a value built using an instance of an F# exception declaration</summary>

 <remarks>Assumes the given input is an F# exception value. If not, ArgumentException is raised.</remarks>
 <param name="exn">The exception instance.</param>
 <param name="bindingFlags">Optional binding flags.</param>
 <exception cref="System.ArgumentException">Thrown when the input type is not an F# exception.</exception>
 <returns>The fields from the given exception.</returns>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpValue">
 <summary>Contains operations associated with constructing and analyzing values associated with F# types
 such as records, unions and tuples.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Tag">
 <summary>The integer tag for the case.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Name">
 <summary>The name of the case.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.DeclaringType">
 <summary>The type in which the case occurs.</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetFields">
 <summary>The fields associated with the case, represented by a PropertyInfo.</summary>
 <returns>The fields associated with the case.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes(System.Type)">
 <summary>Returns the custom attributes associated with the case matching the given attribute type.</summary>
 <param name="attributeType">The type of attributes to return.</param>
 <returns>An array of custom attributes.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes">
 <summary>Returns the custom attributes associated with the case.</summary>
 <returns>An array of custom attributes.</returns>
</member>
<member name="T:Microsoft.FSharp.Reflection.UnionCaseInfo">
 <summary>Represents a case of a discriminated union type</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the &apos;fsi&apos;
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 &lt;example&gt;
 From F# Interactive the default settings can be adjusted using, for example, 
 &lt;pre&gt;
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 &lt;/pre&gt;
 &lt;/example&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Layout">
<summary>
 Data representing structured layouts of terms.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.layout_to_string(Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the &quot;[1;2]&quot; notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Display">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple`2{``0,``1}}},``1,System.Int32)">
<summary>
 For limitting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.String,System.String}},Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.listL``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Layout like an F# list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.optionL``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Layout list vertically.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tupleL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Form tuple of layouts.            
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.braceL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap braces around layout.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.squareBracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap square brackets around layout.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.bracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepListL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.semiListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.spaceListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a space separated list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.commaListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=1 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAt(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_PlusPlus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_HatHat(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, unbreakable. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.leftL(System.String)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.rightL(System.String)">
<summary>
 An string which is right parenthesis (no space on the left).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepL(System.String)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.wordL(System.String)">
<summary>
 An string leaf 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.isEmptyL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
</members>
</doc>
