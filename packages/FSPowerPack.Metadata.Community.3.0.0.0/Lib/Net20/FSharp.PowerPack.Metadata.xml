<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.PowerPack.Metadata</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSComp.SR.valueIsNotAccessible(System.String)">
<summary>
 The value &apos;%s&apos; is not accessible from this code location
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:970)
</summary>
</member>
<member name="M:FSComp.SR.unionCasesAreNotAccessible(System.String)">
<summary>
 The union cases or fields of the type &apos;%s&apos; are not accessible from this code location
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:969)
</summary>
</member>
<member name="M:FSComp.SR.unionCaseIsNotAccessible(System.String)">
<summary>
 The union case &apos;%s&apos; is not accessible from this code location
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:971)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueOfConstructor(System.String)">
<summary>
 The value or constructor &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:6)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueNamespaceTypeOrModule(System.String)">
<summary>
 The value, namespace, type or module &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:7)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueConstructorNamespaceOrType(System.String)">
<summary>
 The value, constructor, namespace or type &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:5)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameTypeParameter(System.String)">
<summary>
 The type parameter &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:12)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameType(System.String)">
<summary>
 The type &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:9)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameRecordLabelOrNamespace(System.String)">
<summary>
 The record label or namespace &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:10)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameRecordLabel(System.String)">
<summary>
 The record label &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:11)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNamePatternDiscriminator(System.String)">
<summary>
 The pattern discriminator &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:13)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameNamespaceOrModule(System.String)">
<summary>
 The namespace or module &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:3)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameNamespace(System.String)">
<summary>
 The namespace &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:2)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameFieldConstructorOrMember(System.String)">
<summary>
 The field, constructor or member &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:4)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameConstructorModuleOrNamespace(System.String)">
<summary>
 The constructor, module or namespace &apos;%s&apos; is not defined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:8)
</summary>
</member>
<member name="M:FSComp.SR.typrelTypeImplementsIComparableShouldOverrideObjectEquals(System.String)">
<summary>
 The type &apos;%s&apos; implements &apos;System.IComparable&apos;. Consider also adding an explicit override for &apos;Object.Equals&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:179)
</summary>
</member>
<member name="M:FSComp.SR.typrelTypeImplementsIComparableDefaultObjectEqualsProvided(System.String)">
<summary>
 The type &apos;%s&apos; implements &apos;System.IComparable&apos; explicitly but provides no corresponding override for &apos;Object.Equals&apos;. An implementation of &apos;Object.Equals&apos; has been automatically provided, implemented via &apos;System.IComparable&apos;. Consider implementing the override &apos;Object.Equals&apos; explicitly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:180)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleParamCountsDiffer">
<summary>
 The signature and implementation are not compatible because the respective type parameter counts differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:175)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleConstraintsDifferRemove(System.String,System.String)">
<summary>
 The signature and implementation are not compatible because the type parameter &apos;%s&apos; has a constraint of the form %s but the implementation does not. Either remove this constraint from the signature or add it to the implementation.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:178)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleConstraintsDiffer(System.String,System.String)">
<summary>
 The signature and implementation are not compatible because the declaration of the type parameter &apos;%s&apos; requires a constraint of the form %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:177)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
<summary>
 The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:176)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverrideWasAmbiguous(System.String)">
<summary>
 The override for &apos;%s&apos; was ambiguous
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:195)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverrideImplementsMoreThenOneSlot(System.String,System.String,System.String)">
<summary>
 The override &apos;%s&apos; implements more than one abstract slot, e.g. &apos;%s&apos; and &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:198)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverloadNotFound(System.String,System.String)">
<summary>
 No implementations of &apos;%s&apos; had the correct number of arguments and type parameters. The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:194)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenWithSuggestion(System.String)">
<summary>
 No implementation was given for &apos;%s&apos;. Note that all interface members must be implemented and listed under an appropriate &apos;interface&apos; declaration, e.g. &apos;interface ... with member ...&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:203)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGiven(System.String)">
<summary>
 No implementation was given for &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:202)
</summary>
</member>
<member name="M:FSComp.SR.typrelNeedExplicitImplementation(System.String)">
<summary>
 The interface &apos;%s&apos; is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:200)
</summary>
</member>
<member name="M:FSComp.SR.typrelNamedArgumentHasBeenAssignedMoreThenOnce">
<summary>
 A named argument has been assigned more than one value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:201)
</summary>
</member>
<member name="M:FSComp.SR.typrelMoreThenOneOverride(System.String)">
<summary>
 More than one override implements &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:196)
</summary>
</member>
<member name="M:FSComp.SR.typrelModuleNamespaceAttributesDifferInSigAndImpl">
<summary>
 The namespace or module attributes differ between signature and implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:192)
</summary>
</member>
<member name="M:FSComp.SR.typrelMethodIsSealed(System.String)">
<summary>
 The method &apos;%s&apos; is sealed and cannot be overridden
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:197)
</summary>
</member>
<member name="M:FSComp.SR.typrelMethodIsOverconstrained">
<summary>
 This method is over-constrained in its type parameters
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:193)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectNumberOfTypeParameters(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct number of method type parameters. The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:205)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectNumberOfArguments(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct number of arguments. The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:204)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectKindsOfGenericParameters(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct kinds of generic parameters. The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:206)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberCannotImplement(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; cannot be used to implement &apos;%s&apos;. The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:207)
</summary>
</member>
<member name="M:FSComp.SR.typrelInvalidValue">
<summary>
 Invalid value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:174)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfGetHashCodeOrEquals(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.GetHashCode&apos; or &apos;Object.Equals&apos;. You must apply the &apos;CustomEquality&apos; attribute to the type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:181)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfGetHashCode(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.GetHashCode&apos;. Consider implementing a matching override for &apos;Object.Equals(obj)&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:182)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfEquals(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.Equals&apos;. Consider implementing a matching override for &apos;Object.GetHashCode()&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:183)
</summary>
</member>
<member name="M:FSComp.SR.typrelDuplicateInterface">
<summary>
 Duplicate or redundant interface
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:199)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveImplicitGenericInstantiation(System.String,System.String)">
<summary>
 The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. &apos;%s&apos; and &apos;%s&apos;. Consider using type annotations to resolve the ambiguity
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:169)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInUnmanaged">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with an &apos;unmanaged&apos; constraint at or near this position
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1108)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInPrintf">
<summary>
 Could not resolve the ambiguity inherent in the use of a &apos;printf&apos;-style format string
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:171)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInOverloadedOperator(System.String)">
<summary>
 Could not resolve the ambiguity inherent in the use of the operator &apos;%s&apos; at or near this program point. Consider using type annotations to resolve the ambiguity.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:170)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInEnum">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with an &apos;enum&apos; constraint at or near this position
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:172)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInDelegate">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with a &apos;delegate&apos; constraint at or near this position
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:173)
</summary>
</member>
<member name="M:FSComp.SR.typeIsNotAccessible(System.String)">
<summary>
 The type &apos;%s&apos; is not accessible from this code location
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:968)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoUnionCase">
<summary>
 union case
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:945)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoType">
<summary>
 type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:941)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoProperty">
<summary>
 property
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:950)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoPatternVariable">
<summary>
 patvar
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:952)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoOtherOverloads(System.Int32)">
<summary>
 and %d other overloads
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:944)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoNamespaceOrModule">
<summary>
 namespace/module
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:955)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoNamespace">
<summary>
 namespace
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:953)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoModule">
<summary>
 module
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:954)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoInherits">
<summary>
 inherits
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:942)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoImplements">
<summary>
 implements
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:943)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFullName">
<summary>
 Full name
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:940)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFromNext(System.String)">
<summary>
 also from %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:957)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFromFirst(System.String)">
<summary>
 from %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:956)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoField">
<summary>
 field
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:948)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoEvent">
<summary>
 event
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:949)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoArgument">
<summary>
 argument
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:951)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoActiveRecognizer">
<summary>
 active recognizer
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:947)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoActivePatternResult">
<summary>
 active pattern result
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:946)
</summary>
</member>
<member name="M:FSComp.SR.tlrUnexpectedTExpr">
<summary>
 Unexpected TExpr_tchoose
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:981)
</summary>
</member>
<member name="M:FSComp.SR.tlrLambdaLiftingOptimizationsNotApplied">
<summary>
 Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:982)
</summary>
</member>
<member name="M:FSComp.SR.tcVolatileOnlyOnClassLetBindings">
<summary>
 The &apos;VolatileField&apos; attribute may only be used on &apos;let&apos; bindings in classes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:689)
</summary>
</member>
<member name="M:FSComp.SR.tcVolatileFieldsMustBeMutable">
<summary>
 Volatile fields must be marked &apos;mutable&apos; and cannot be thread-static
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:746)
</summary>
</member>
<member name="M:FSComp.SR.tcValueInSignatureRequiresLiteralAttribute">
<summary>
 A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:744)
</summary>
</member>
<member name="M:FSComp.SR.tcUseYieldBangForMultipleResults">
<summary>
 In sequence expressions, multiple results are generated using &apos;yield!&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:663)
</summary>
</member>
<member name="M:FSComp.SR.tcUseWhenPatternGuard">
<summary>
 Character range matches have been removed in F#. Consider using a &apos;when&apos; pattern guard instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:596)
</summary>
</member>
<member name="M:FSComp.SR.tcUseTypeOf">
<summary>
 Use &apos;typeof&lt;_&gt;&apos; instead
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:610)
</summary>
</member>
<member name="M:FSComp.SR.tcUseForInSequenceExpression">
<summary>
 The use of &apos;let! x = coll&apos; in sequence expressions is no longer permitted. Use &apos;for x in coll&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:661)
</summary>
</member>
<member name="M:FSComp.SR.tcUnsupportedAttribute">
<summary>
 This attribute cannot be used in this version of F#
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:716)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedAttributeTarget">
<summary>
 Unrecognized attribute target. Valid attribute targets are &apos;assembly&apos;, &apos;module&apos;, &apos;type&apos;, &apos;method&apos;, &apos;property&apos;, &apos;return&apos;, &apos;param&apos;, &apos;field&apos;, &apos;event&apos;, &apos;constructor&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:706)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedAccessibilitySpec">
<summary>
 Unrecognized accessibility specification
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:508)
</summary>
</member>
<member name="M:FSComp.SR.tcUnnamedArgumentsDoNotFormPrefix">
<summary>
 The unnamed arguments do not form a prefix of the arguments of the method called
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:683)
</summary>
</member>
<member name="M:FSComp.SR.tcUnknownUnion">
<summary>
 Unknown union case
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:534)
</summary>
</member>
<member name="M:FSComp.SR.tcUnitsOfMeasureInvalidInTypeConstructor">
<summary>
 Unit-of-measure cannot be used in type constructor application
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:572)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseRequiresOneArgument">
<summary>
 This union case takes one argument
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:590)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseExpectsTupledArguments(System.Int32)">
<summary>
 This union case expects %d arguments in tupled form
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:591)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseDoesNotTakeArguments">
<summary>
 This union case does not take arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:589)
</summary>
</member>
<member name="M:FSComp.SR.tcUninitializedValFieldsMustBeMutable">
<summary>
 Uninitialized &apos;val&apos; fields in implicit construction types must be mutable and marked with the &apos;[&lt;DefaultValue&gt;]&apos; attribute. Consider using a &apos;let&apos; binding instead of a &apos;val&apos; field.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:747)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedTypeArguments">
<summary>
 Unexpected type arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:581)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedTypeApplication">
<summary>
 Unexpected type application
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:664)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedSymbolInTypeExpression(System.String)">
<summary>
 Unexpected %s in type expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:575)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedSlashInType">
<summary>
 Unexpected / in type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:580)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedPropertySpec">
<summary>
 Unexpected source-level property specification
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:545)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedPropertyInSyntaxTree">
<summary>
 Unexpected source-level property specification in syntax tree
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:539)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedMeasureAnon">
<summary>
 Unexpected Measure_Anon
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:494)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedExprAtRecInfPoint">
<summary>
 Unexpected expression at recursive inference point
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:524)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstraintsOrParametersOnModule">
<summary>
 Unexpected constraints or parameters on module specification
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:787)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstraintOrTypeDef">
<summary>
 Unexpected constraint or type definition
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:788)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstUint16Array">
<summary>
 Unexpected Const_uint16array
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:499)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstByteArray">
<summary>
 Unexpected Const_bytearray
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:500)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConditionInImportedAssembly">
<summary>
 Unexpected condition in imported assembly: failed to decode AttributeUsage attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:705)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedBigRationalConstant">
<summary>
 Unexpected big rational constant
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:497)
</summary>
</member>
<member name="M:FSComp.SR.tcUndefinedField(System.String,System.String)">
<summary>
 The field &apos;%s&apos; has been given a value, but is not present in the type &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:629)
</summary>
</member>
<member name="M:FSComp.SR.tcUnableToParseFormatString(System.String)">
<summary>
 Unable to parse format string &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:606)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesCannotInheritFromMultipleConcreteTypes">
<summary>
 Types cannot inherit from multiple concrete types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:797)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesCannotContainNestedTypes">
<summary>
 Types cannot contain nested type definitions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:776)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedStruct">
<summary>
 Struct types are always sealed
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:809)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedRecord">
<summary>
 Record types are always sealed
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:807)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedEnum">
<summary>
 Enum types are always sealed
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:811)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedDelegate">
<summary>
 Delegate types are always sealed
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:810)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedDU">
<summary>
 Discriminated union types are always sealed
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:806)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedAssemblyCode">
<summary>
 Assembly code types are always sealed
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:808)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; is used in an invalid way. A value prior to &apos;%s&apos; has an inferred type involving &apos;%s&apos;, which is an invalid forward reference.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:834)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeRequiresDefinition">
<summary>
 This type requires a definition
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:794)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParametersInferredAreNotStable">
<summary>
 The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;&apos;a&gt; = int or\n\ttype swap&lt;&apos;a,&apos;b&gt; = &apos;b * &apos;a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;&apos;a,&apos;b&gt; ((x,y) : swap&lt;&apos;b,&apos;a&gt;) : swap&lt;&apos;a,&apos;b&gt; = (y,x).
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:529)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterInvalidAsTypeConstructor">
<summary>
 Type parameter cannot be used as type constructor
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:576)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterHasBeenConstrained(System.String)">
<summary>
 This type parameter has been used in a way that constrains it to always be &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:528)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterArityMismatch(System.Int32,System.Int32)">
<summary>
 This value, type or method expects %d type parameter(s) but was given %d
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:551)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeOrModule">
<summary>
 type or module
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:778)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotInterfaceType1(System.String)">
<summary>
 The type &apos;%s&apos; is not an interface type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:754)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotInterfaceType0">
<summary>
 This type is not an interface type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:771)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotARecordTypeNeedConstructor">
<summary>
 This type is not a record type. Values of class and struct types must be created using calls to object constructors.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:656)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotARecordType">
<summary>
 This type is not a record type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:657)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsInaccessible">
<summary>
 This type is not accessible from this code location
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:704)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeHasNoNestedTypes">
<summary>
 This type has no nested types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:574)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeHasNoAccessibleConstructor">
<summary>
 This type has no accessible object constructors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:667)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeFunctionFieldsCannotBeMutated">
<summary>
 Fields which are type functions cannot be mutated
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:492)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeExceptionOrModule">
<summary>
 type, exception or module
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:777)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
<summary>
 Type definitions using implicit construction may only have one &apos;inherit&apos; specification and it must be the first declaration
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:827)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
<summary>
 Type definitions using implicit construction must have local let/do-bindings preceding member and interface definitions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:828)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionIsCyclicThroughInheritance">
<summary>
 This type definition involves an immediate cyclic reference through a struct field or inheritance relation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:823)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionIsCyclic">
<summary>
 This type definition involves an immediate cyclic reference through an abbreviation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:822)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeCannotBeEnumerated(System.String)">
<summary>
 The type &apos;%s&apos; is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:558)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsMayNotHaveMembers">
<summary>
 Type abbreviations cannot have members
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:761)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
<summary>
 Type abbreviations cannot have interface declarations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:769)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCannotHaveAugmentations">
<summary>
 Type abbreviations cannot have augmentations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:832)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationHasTypeParametersMissingOnType">
<summary>
 This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as &apos;type C&lt;&apos;a&gt; = C of ...&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:795)
</summary>
</member>
<member name="M:FSComp.SR.tcTryIllegalInSequenceExpression">
<summary>
 &apos;try&apos;/&apos;with&apos; cannot be used within sequence expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:662)
</summary>
</member>
<member name="M:FSComp.SR.tcThreadStaticAndContextStaticMustBeStatic">
<summary>
 Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:745)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
<summary>
 The syntax &apos;expr.id&apos; may only be used with record labels, properties and fields
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:678)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxErrorUnexpectedQMark">
<summary>
 Syntax error - unexpected &apos;?&apos; symbol
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:598)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxCanOnlyBeUsedToCreateObjectTypes(System.String)">
<summary>
 &apos;%s&apos; may only be used to construct object types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:627)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralEqualityNotSatisfied2(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralEquality&apos; attribute but the component type &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1085)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralEqualityNotSatisfied1(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralEquality&apos; attribute but the type parameter &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;equality&apos; constraint to the type parameter
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1084)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralComparisonNotSatisfied2(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralComparison&apos; attribute but the component type &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1079)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralComparisonNotSatisfied1(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralComparison&apos; attribute but the type parameter &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;comparison&apos; constraint to the type parameter
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1078)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
<summary>
 Each argument of the primary constructor for a struct must be given a type, for example &apos;type S(x1:int, x2: int) = ...&apos;. These arguments determine the fields of the struct.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1086)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMayNotContainLetBindings">
<summary>
 Structs cannot contain &apos;let&apos; bindings because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:765)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMayNotContainDoBindings">
<summary>
 Structs cannot contain &apos;do&apos; bindings because the default constructor for structs would not execute these bindings
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:764)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
<summary>
 Structs, interfaces, enums and delegates cannot inherit from other types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:796)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsCannotHaveConstructorWithNoArguments">
<summary>
 Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:737)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsCanOnlyBindThisAtMemberDeclaration">
<summary>
 Structs may only bind a &apos;this&apos; parameter at member declarations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:523)
</summary>
</member>
<member name="M:FSComp.SR.tcStructTypesCannotContainAbstractMembers">
<summary>
 Struct types cannot contain abstract members
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:816)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticValFieldsMustBeMutableAndPrivate">
<summary>
 Static &apos;val&apos; fields in types must be mutable, private and marked with the &apos;[&lt;DefaultValue&gt;]&apos; attribute. They are initialized to the &apos;null&apos; or &apos;zero&apos; value for their type. Consider also using a &apos;static let mutable&apos; binding in a class type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:748)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
<summary>
 Static optimization conditionals are only for use within the F# library
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:684)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticMemberShouldNotHaveThis">
<summary>
 This static member should not have a &apos;this&apos; parameter. Consider using the notation &apos;member Member(args) = ...&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:542)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticLetBindingsRequireClassesWithImplicitConstructors">
<summary>
 Static &apos;let&apos; bindings may only be defined in class types with implicit constructors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:766)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticInitializersIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of static initializers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:732)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticInitializerRequiresArgument">
<summary>
 A static initializer requires an argument
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:540)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticFieldUsedWhenInstanceFieldExpected">
<summary>
 A static field was used where an instance field is expected
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:490)
</summary>
</member>
<member name="M:FSComp.SR.tcSimpleMethodNameRequired">
<summary>
 A simple method name is required here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:636)
</summary>
</member>
<member name="M:FSComp.SR.tcSeqResultsUseYield">
<summary>
 In sequence expressions, results are generated using &apos;yield&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:496)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnValuesCannotHaveNames">
<summary>
 Return values cannot have names
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:502)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnTypesForUnionMustBeSameAsType">
<summary>
 Return types of union cases must be identical to the type being defined, up to abbreviations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:752)
</summary>
</member>
<member name="M:FSComp.SR.tcReservedSyntaxForAugmentation">
<summary>
 The syntax &apos;type X with ...&apos; is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using &apos;type X = ...&apos;. You may also need to add the &apos;[&lt;Sealed&gt;] attribute to the type declaration in the signature
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:824)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireVarConstRecogOrLiteral">
<summary>
 This is not a variable, constant, active recognizer or literal
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:594)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireBuilderMethod(System.String)">
<summary>
 This control construct may only be used if the computation expression builder defines a &apos;%s&apos; method
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:573)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireActivePatternWithOneResult">
<summary>
 Only active patterns returning exactly one result may accept arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:586)
</summary>
</member>
<member name="M:FSComp.SR.tcRepresentationOfTypeHiddenBySignature">
<summary>
 The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:802)
</summary>
</member>
<member name="M:FSComp.SR.tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
<summary>
 Recursive bindings that include member specifications can only occur as a direct augmentation of a type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:739)
</summary>
</member>
<member name="M:FSComp.SR.tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
<summary>
 Records, union, abbreviations and struct types cannot have the &apos;AllowNullLiteral&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:798)
</summary>
</member>
<member name="M:FSComp.SR.tcRecordFieldInconsistentTypes">
<summary>
 This record contains fields from inconsistent types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:521)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyRequiresExplicitTypeParameters">
<summary>
 A property cannot have explicit type parameters. Consider using a method instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:536)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyOrFieldNotFoundInAttribute">
<summary>
 This property or field was not found on this custom attribute type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:711)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsStatic(System.String)">
<summary>
 Property &apos;%s&apos; is static
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:675)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsNotStatic(System.String)">
<summary>
 Property &apos;%s&apos; is not static
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:672)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsNotReadable(System.String)">
<summary>
 Property &apos;%s&apos; is not readable
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:673)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyImplementedIsAmbiguous">
<summary>
 The property implemented by this default is ambiguous
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:729)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyCannotBeSet1(System.String)">
<summary>
 Property &apos;%s&apos; cannot be set
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:676)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyCannotBeSet0">
<summary>
 This property cannot be set
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:710)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyAlreadyHasDefaultImplementation">
<summary>
 This property already has a default implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:728)
</summary>
</member>
<member name="M:FSComp.SR.tcPredefinedTypeCannotBeUsedAsSuperType">
<summary>
 The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:637)
</summary>
</member>
<member name="M:FSComp.SR.tcParameterRequiresName">
<summary>
 A parameter with attributes must also be given a name, e.g. &apos;[&lt;Attribute&gt;] paramName : paramType&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:501)
</summary>
</member>
<member name="M:FSComp.SR.tcParameterInferredByref(System.String)">
<summary>
 The parameter &apos;%s&apos; was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. &apos;x1: byref&lt;int&gt;&apos;. When used, a byref parameter is implicitly dereferenced.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1103)
</summary>
</member>
<member name="M:FSComp.SR.tcOverridingMethodRequiresAllOrNoTypeParameters">
<summary>
 You must explicitly declare either all or no type parameters when overriding a generic abstract method
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:531)
</summary>
</member>
<member name="M:FSComp.SR.tcOverridesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on overrides or interface implementations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:805)
</summary>
</member>
<member name="M:FSComp.SR.tcOverrideArityMismatch">
<summary>
 This override takes a different number of arguments to the corresponding abstract member
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:722)
</summary>
</member>
<member name="M:FSComp.SR.tcOverloadsCannotHaveCurriedArguments">
<summary>
 One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:682)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgumentsCannotBeUsedInCustomAttribute">
<summary>
 Optional arguments cannot be used in custom attributes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:709)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgsOnlyOnMembers">
<summary>
 Optional arguments are only permitted on type members
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:582)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgsMustComeAfterNonOptionalArgs">
<summary>
 Optional arguments must come at the end of the argument list, after any non-optional arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1122)
</summary>
</member>
<member name="M:FSComp.SR.tcOpenUsedWithPartiallyQualifiedPath(System.String)">
<summary>
 This declaration opens the namespace or module &apos;%s&apos; through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:759)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
<summary>
 Only types representing units-of-measure may be given the &apos;Measure&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:804)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyStructsCanHaveStructLayout">
<summary>
 Only structs and classes without implicit constructors may be given the &apos;StructLayout&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:801)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlySimplePatternsInLetRec">
<summary>
 Only simple variable patterns can be bound in &apos;let rec&apos; constructs
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:740)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
<summary>
 Only simple bindings of the form &apos;id = expr&apos; can be used in construction expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:643)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
<summary>
 Only record fields and simple &apos;let&apos; bindings may be marked mutable
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:741)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyFunctionsCanBeInline">
<summary>
 Only functions may be marked &apos;inline&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:698)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyClassesCanHaveAbstract">
<summary>
 Only classes may be given the &apos;AbstractClass&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:803)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectsMustBeInitializedWithObjectExpression">
<summary>
 Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:644)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
<summary>
 The operator &apos;expr.[idx]&apos; has been used an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:618)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
<summary>
 Only overrides of abstract and virtual members may be specified in object expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:632)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectExpressionFormDeprecated">
<summary>
 This form of object expression is not used in F#. Use &apos;member this.MemberName ... = ...&apos; to define member implementations in object expressions.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:546)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorsOnTypeParametersCannotTakeArguments">
<summary>
 Calls to object constructors on type parameters cannot be given arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:620)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorsIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of object constructors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:733)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorRequiresArgument">
<summary>
 An object constructor requires an argument
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:541)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
<summary>
 Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use &apos;new ObjectType(args)&apos; to construct instances of object model types outside of constructors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:654)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructionCanOnlyBeUsedInClassTypes">
<summary>
 Object construction expressions may only be used to implement constructors in class types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:642)
</summary>
</member>
<member name="M:FSComp.SR.tcNumericLiteralRequiresModule(System.String)">
<summary>
 This numeric literal requires that a module &apos;%s&apos; defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:650)
</summary>
</member>
<member name="M:FSComp.SR.tcNotValidEnumCaseName">
<summary>
 This is not a valid name for an enumeration case
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:611)
</summary>
</member>
<member name="M:FSComp.SR.tcNotSufficientlyGenericBecauseOfScope(System.String)">
<summary>
 This code is not sufficiently generic. The type variable %s could not be generalized because it would escape its scope.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:535)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAnException">
<summary>
 Not an exception
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:786)
</summary>
</member>
<member name="M:FSComp.SR.tcNonZeroConstantCannotHaveGenericUnit">
<summary>
 Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:495)
</summary>
</member>
<member name="M:FSComp.SR.tcNonUniformMemberUse(System.String)">
<summary>
 The generic member &apos;%s&apos; has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1104)
</summary>
</member>
<member name="M:FSComp.SR.tcNonLiteralCannotBeUsedInPattern">
<summary>
 This value is not a literal and cannot be used in a pattern
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:554)
</summary>
</member>
<member name="M:FSComp.SR.tcNoPropertyFoundForOverride">
<summary>
 No abstract property was found that corresponds to this override
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:725)
</summary>
</member>
<member name="M:FSComp.SR.tcNoMemberFoundForOverride">
<summary>
 No abstract or interface member was found that corresponds to this override
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:721)
</summary>
</member>
<member name="M:FSComp.SR.tcNoInterfaceImplementationForConstructionExpression">
<summary>
 Interface implementations cannot be given on construction expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:641)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEqualityNeeded2(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; does not support structural equality because the type &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;NoEquality&apos; attribute to the type &apos;%s&apos; to clarify that the type does not support structural equality
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1083)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEqualityNeeded1(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; does not support structural equality because the type parameter %s does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;NoEquality&apos; attribute to the type &apos;%s&apos; to clarify that the type does not support structural equality
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1082)
</summary>
</member>
<member name="M:FSComp.SR.tcNoComparisonNeeded2(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; is not structurally comparable because the type &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;NoComparison&apos; attribute to the type &apos;%s&apos; to clarify that the type is not comparable
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1081)
</summary>
</member>
<member name="M:FSComp.SR.tcNoComparisonNeeded1(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; is not structurally comparable because the type parameter %s does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;NoComparison&apos; attribute to the type &apos;%s&apos; to clarify that the type is not comparable
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1080)
</summary>
</member>
<member name="M:FSComp.SR.tcNoArgumentsForRecordValue">
<summary>
 No arguments may be given when constructing a record value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:640)
</summary>
</member>
<member name="M:FSComp.SR.tcNoAbstractOrVirtualMemberFound(System.String)">
<summary>
 The member &apos;%s&apos; does not correspond to any abstract or virtual method available to override or implement
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:633)
</summary>
</member>
<member name="M:FSComp.SR.tcNewRequiresObjectConstructor">
<summary>
 &apos;new&apos; may only be used with object constructors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:648)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMustBeUsedWithNamedType">
<summary>
 &apos;new&apos; must be used with a named type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:638)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMemberHidesAbstractMemberWithSuffix(System.String)">
<summary>
 This new member hides the abstract member &apos;%s&apos; once tuples, functions and/or units of measure are erased. Rename the member or use &apos;override&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:731)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMemberHidesAbstractMember(System.String)">
<summary>
 This new member hides the abstract member &apos;%s&apos;. Rename the member or use &apos;override&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:730)
</summary>
</member>
<member name="M:FSComp.SR.tcNewCannotBeUsedOnInterfaceType">
<summary>
 &apos;new&apos; cannot be used on interface types. Consider using an object expression &apos;{ new ... with ... }&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:624)
</summary>
</member>
<member name="M:FSComp.SR.tcNamespaceCannotContainValues">
<summary>
 Namespaces cannot contain values. Consider using a module to hold your value declarations.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:504)
</summary>
</member>
<member name="M:FSComp.SR.tcNamespaceCannotContainExtensionMembers">
<summary>
 Namespaces cannot contain extension members except in the same file and namespace where the type is defined. Consider using a module to hold declarations of extension members.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:505)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedTypeRequired(System.String)">
<summary>
 &apos;%s&apos; may only be used with named types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:622)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedArgumentsCannotBeUsedInUnionCaseConstructions">
<summary>
 The use of named arguments in union case expressions is reserved for future use. Arguments of the form &apos;a=b&apos; should be parenthesized.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1105)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedArgumentsCannotBeUsedInMemberTraits">
<summary>
 Named arguments cannot be given to member trait calls
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:609)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedArgumentDidNotMatch(System.String)">
<summary>
 The named argument &apos;%s&apos; did not match any argument or mutable property
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:681)
</summary>
</member>
<member name="M:FSComp.SR.tcNameNotBoundInPattern(System.String)">
<summary>
 Name &apos;%s&apos; not bound in pattern context
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:583)
</summary>
</member>
<member name="M:FSComp.SR.tcNameArgumentsMustAppearLast">
<summary>
 Named arguments must appear after all other arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:556)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesSyntax">
<summary>
 Mutable function values should be written &apos;let mutable f = (fun args -&gt; ...)&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:697)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesMayNotHaveGenericParameters">
<summary>
 Mutable values cannot have generic parameters
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:696)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesCannotBeInline">
<summary>
 Mutable values cannot be marked &apos;inline&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:695)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleVisibilityAttributesWithLet">
<summary>
 Multiple visibility attributes have been specified for this identifier. &apos;let&apos; bindings in classes are always private, as are any &apos;let&apos; bindings inside expressions.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:507)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleVisibilityAttributes">
<summary>
 Multiple visibility attributes have been specified for this identifier
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:506)
</summary>
</member>
<member name="M:FSComp.SR.tcModulesCannotUseNamedModuleSignatures">
<summary>
 Modules cannot use named module signature definitions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:837)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleRequiresQualifiedAccess(System.String)">
<summary>
 This declaration opens the module &apos;%s&apos;, which is marked as &apos;RequireQualifiedAccess&apos;. Adjust your code to use qualified references to the elements of the module instead, e.g. &apos;List.map&apos; instead of &apos;map&apos;. This change will ensure that your code is robust as new constructs are added to libraries.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:758)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleAbbreviationForNamespace(System.String)">
<summary>
 The path &apos;%s&apos; is a namespace. A module abbreviation may not abbreviate a namespace.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:833)
</summary>
</member>
<member name="M:FSComp.SR.tcMethodOverridesIllegalHere">
<summary>
 Method overrides and interface implementations are not permitted here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:720)
</summary>
</member>
<member name="M:FSComp.SR.tcMethodNotAccessible(System.String)">
<summary>
 Method &apos;%s&apos; is not accessible from this code location
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:491)
</summary>
</member>
<member name="M:FSComp.SR.tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
<summary>
 Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:825)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; is used in an invalid way. A use of &apos;%s&apos; has been inferred prior to the definition of &apos;%s&apos;, which is an invalid forward reference.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:835)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberOverridesIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of member overrides
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:734)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberOperatorDefinitionInExtrinsic">
<summary>
 Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1125)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberNotPermittedInInterfaceImplementation">
<summary>
 This member is not permitted in an interface implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:774)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberKindPropertyGetSetNotExpected">
<summary>
 MemberKindPropertyGetSet only expected in parse trees
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:503)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberIsNotSufficientlyGeneric">
<summary>
 This member is not sufficiently generic
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:742)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberAndLocalClassBindingHaveSameName(System.String)">
<summary>
 A member and a local class binding both have the name &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:768)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDefinitionsCannotHaveTypeParameters">
<summary>
 Measure definitions cannot have type parameters
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:793)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDeclarationsRequireStaticMembersNotConstructors">
<summary>
 Measure declarations may have only static members: constructors are not available
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:767)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDeclarationsRequireStaticMembers">
<summary>
 Measure declarations may have only static members
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:763)
</summary>
</member>
<member name="M:FSComp.SR.tcLookupMayNotBeUsedHere">
<summary>
 This lookup cannot be used here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:674)
</summary>
</member>
<member name="M:FSComp.SR.tcLocalClassBindingsCannotBeInline">
<summary>
 Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:760)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotHaveGenericParameters">
<summary>
 Literal values cannot have generic parameters
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:702)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotBeMutable">
<summary>
 A literal value cannot be marked &apos;mutable&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:700)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotBeInline">
<summary>
 A literal value cannot be marked &apos;inline&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:701)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralAttributeRequiresConstantValue">
<summary>
 A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. &apos;val x : int = 1&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:743)
</summary>
</member>
<member name="M:FSComp.SR.tcListLiteralMaxSize">
<summary>
 This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:607)
</summary>
</member>
<member name="M:FSComp.SR.tcLetAndDoRequiresImplicitConstructionSequence">
<summary>
 &apos;let&apos; and &apos;do&apos; bindings are not permitted in class definitions unless an implicit construction sequence is used. You can use an implicit construction sequence by modifying the type declaration to include arguments, e.g. &apos;type X(args) = ...&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:831)
</summary>
</member>
<member name="M:FSComp.SR.tcLessGenericBecauseOfAnnotation(System.String,System.String)">
<summary>
 This code is less generic than required by its annotations because the explicit type variable &apos;%s&apos; could not be generalized. It was constrained to be &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:525)
</summary>
</member>
<member name="M:FSComp.SR.tcKindOfTypeSpecifiedDoesNotMatchDefinition">
<summary>
 The kind of the type specified by its attributes does not match the kind implied by its definition
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:792)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfTypeNameOrConstructorWithOverloads(System.String)">
<summary>
 Invalid use of a type name and/or object constructor. If necessary use &apos;new&apos; and apply the constructor to its arguments, e.g. &apos;new Type(args)&apos;. Overloads are:\n\t%s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:669)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfTypeNameOrConstructor">
<summary>
 Invalid use of a type name and/or object constructor. If necessary use &apos;new&apos; and apply the constructor to its arguments, e.g. &apos;new Type(args)&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:668)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfTypeName">
<summary>
 Invalid use of a type name
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:666)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfInterfaceType">
<summary>
 Invalid use of an interface type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:670)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfDelegate">
<summary>
 Invalid use of a delegate constructor. Use the syntax &apos;new Type(args)&apos; or just &apos;Type(args)&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:671)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseNullAsTrueValue">
<summary>
 The &apos;UseNullAsTrueValue&apos; attribute flag may only be used with union types that have one nullary case and at least one non-nullary case
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1102)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseBinding">
<summary>
 &apos;use&apos; bindings must be of the form &apos;use &lt;var&gt; = &lt;expr&gt;&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:718)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUnitsOfMeasurePrefix">
<summary>
 Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:571)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeForUnitsOfMeasure">
<summary>
 Units-of-measure supported only on float, float32, decimal and signed integer types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:498)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeForLiteralEnumeration">
<summary>
 Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:820)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeExtension">
<summary>
 Invalid type extension
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:790)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeArgumentUsage">
<summary>
 Type arguments cannot be specified here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:585)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSignatureForSet">
<summary>
 Invalid signature for set member
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:727)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSequenceExpressionSyntaxForm">
<summary>
 Invalid record, sequence or computation expression. Sequence expressions should be of the form &apos;seq { ... }&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:604)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidRecordConstruction">
<summary>
 Invalid record construction
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:651)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidPropertyType">
<summary>
 This property has an invalid type. Properties taking multiple indexer arguments should have types of the form &apos;ty1 * ty2 -&gt; ty3&apos;. Properties returning functions should have types of the form &apos;(ty1 -&gt; ty2)&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:566)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidPattern">
<summary>
 This is not a valid pattern
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:595)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOptionalAssignmentToPropertyOrField">
<summary>
 Invalid optional assignment to a property or field
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:686)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinitionRelational(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the &apos;System.IComparable&apos; interface in the definition of that type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:513)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinitionEquality(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. To define equality semantics for a type, override the &apos;Object.Equals&apos; member in the definition of that type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:514)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinition(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. Consider using a different operator name
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:515)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectSequenceOrRecordExpression">
<summary>
 Invalid object, sequence or record expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:603)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectExpressionSyntaxForm">
<summary>
 Invalid object expression. Objects without overrides or interfaces should use the expression form &apos;new Type(args)&apos; without braces.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:602)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectConstructionExpression">
<summary>
 This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:561)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNonPrimitiveLiteralInPatternMatch">
<summary>
 Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use &apos;when &lt;variable&gt; = &lt;constant&gt;&apos; at the end of the match clause.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:584)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNewConstraint">
<summary>
 &apos;new&apos; constraints must take one argument of type &apos;unit&apos; and return the constructed type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:565)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNamespaceModuleTypeUnionName">
<summary>
 Invalid namespace, module, type or union case name
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:750)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidModuleName">
<summary>
 Invalid module name
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:789)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMixtureOfRecursiveForms">
<summary>
 This recursive binding uses an invalid mixture of recursive forms
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:560)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMethodNameForRelationalOperator(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. To define comparison semantics for a type, implement the &apos;System.IComparable&apos; interface. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:509)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMethodNameForEquality(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. To define equality semantics for a type, override the &apos;Object.Equals&apos; member. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:510)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberNameFixedTypes(System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name because it is given a standard definition in the F# library over fixed types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:512)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberName(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:511)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidInlineSpecification">
<summary>
 Invalid inline specification
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:717)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexerExpression">
<summary>
 Invalid indexer expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:617)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexOperatorDefinition(System.String)">
<summary>
 The &apos;%s&apos; operator cannot be redefined. Consider using a different operator name
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:516)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexIntoActivePatternArray">
<summary>
 Internal error. Invalid index into active pattern array
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:588)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidEnumerationLiteral">
<summary>
 This is not a valid value for an enumeration literal
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:753)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidEnumConstraint">
<summary>
 An &apos;enum&apos; constraint must be of the form &apos;enum&lt;type&gt;&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:564)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidDelegateSpecification">
<summary>
 Delegate specifications must be of the form &apos;typ -&gt; typ&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:818)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidDeclaration">
<summary>
 Invalid declaration
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:547)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstraintTypeSealed">
<summary>
 Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:563)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstraint">
<summary>
 Invalid constraint
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:562)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstantExpression">
<summary>
 This is not a valid constant expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:703)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidAssignment">
<summary>
 Invalid assignment
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:665)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidArgForParameterizedPattern">
<summary>
 Invalid argument to parameterized pattern label
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:587)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidActivePatternName">
<summary>
 This is not a valid name for an active pattern
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:693)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfacesShouldUseInheritNotInterface">
<summary>
 Interfaces inherited by other interfaces should be declared using &apos;inherit ...&apos; instead of &apos;interface ...&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1114)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfaceTypesCannotBeSealed">
<summary>
 Interface types cannot be sealed
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:817)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfaceTypesAndDelegatesCannotContainFields">
<summary>
 Interface types and delegate types cannot contain fields
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:812)
</summary>
</member>
<member name="M:FSComp.SR.tcInstanceMemberRequiresTarget">
<summary>
 This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation &apos;member x.Member(args) = ...&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:538)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritedTypeIsNotObjectModelType">
<summary>
 The inherited type is not an object model type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:653)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritIllegalHere">
<summary>
 A inheritance declaration is not permitted here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:757)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritDeclarationMissingArguments">
<summary>
 This &apos;inherit&apos; declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. &apos;inherit BaseType(args)&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:829)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritConstructionCallNotPartOfImplicitSequence">
<summary>
 This &apos;inherit&apos; construction call is not part of an implicit construction sequence. Only the inherited type should be specified at this point. Calls to the inherited constructor should be placed inside the object initialization expression of your object constructor. Alternatively use an implicit construction sequence by modifying the type declaration to include arguments, e.g. &apos;type X(args) = ...&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:830)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritCannotBeUsedOnInterfaceType">
<summary>
 &apos;inherit&apos; cannot be used on interface types. Consider implementing the interface by using &apos;interface ... with ... end&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:623)
</summary>
</member>
<member name="M:FSComp.SR.tcImplicitMeasureFollowingSlash">
<summary>
 Implicit product of measures following /
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:493)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIStructuralEquatableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IStructuralEquatable&apos; explicitly. Apply the &apos;CustomEquality&apos; attribute to the type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:779)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIStructuralComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IStructuralComparable&apos; explicitly. Apply the &apos;CustomComparison&apos; attribute to the type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:520)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIEquatableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IEquatable&lt;_&gt;&apos; explicitly. Apply the &apos;CustomEquality&apos; attribute to the type and provide a consistent implementation of the non-generic override &apos;System.Object.Equals(obj)&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:780)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IComparable&apos; explicitly. You must apply the &apos;CustomComparison&apos; attribute to the type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:518)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsGenericIComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IComparable&lt;_&gt;&apos; explicitly. You must apply the &apos;CustomComparison&apos; attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:519)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalSyntaxInTypeExpression">
<summary>
 Illegal syntax in type expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:577)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalPattern">
<summary>
 Illegal pattern
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:597)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalFormForExplicitTypeDeclaration">
<summary>
 Explicit type declarations for constructors must be of the form &apos;ty1 * ... * tyN -&gt; resTy&apos;. Parentheses may be required around &apos;resTy&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:751)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalAttributesForLiteral">
<summary>
 A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:699)
</summary>
</member>
<member name="M:FSComp.SR.tcIDisposableTypeShouldUseNew">
<summary>
 It is recommended that objects that support the IDisposable interface are created using &apos;new Type(args)&apos; rather than &apos;Type(args)&apos; to indicate that resources may be owned by the generated value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:626)
</summary>
</member>
<member name="M:FSComp.SR.tcGenericTypesCannotHaveStructLayout">
<summary>
 Generic types cannot be given the &apos;StructLayout&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:800)
</summary>
</member>
<member name="M:FSComp.SR.tcGenericParameterHasBeenConstrained(System.String)">
<summary>
 A generic type parameter has been used in a way that constrains it to always be &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:527)
</summary>
</member>
<member name="M:FSComp.SR.tcFunctionRequiresExplicitTypeArguments(System.String)">
<summary>
 The generic function &apos;%s&apos; must be given explicit type argument(s)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:549)
</summary>
</member>
<member name="M:FSComp.SR.tcFunctionRequiresExplicitLambda(System.Int32)">
<summary>
 This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking %d arguments.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:557)
</summary>
</member>
<member name="M:FSComp.SR.tcFormalArgumentIsNotOptional">
<summary>
 The corresponding formal argument is not optional
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:685)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldsDoNotDetermineUniqueRecordType">
<summary>
 The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:532)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldValIllegalHere">
<summary>
 A field/val declaration is not permitted here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:756)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldRequiresName">
<summary>
 This field requires a name
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:749)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldRequiresAssignment(System.String,System.String)">
<summary>
 No assignment given for field &apos;%s&apos; of type &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:630)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNotLiteralCannotBeUsedInPattern">
<summary>
 This field is not a literal and cannot be used in a pattern
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:593)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsReadonly">
<summary>
 This field is readonly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:555)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsNotStatic(System.String)">
<summary>
 Field &apos;%s&apos; is not static
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:592)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsNotMutable">
<summary>
 This field is not mutable
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:612)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldAppearsTwiceInRecord(System.String)">
<summary>
 The field &apos;%s&apos; appears twice in this record expression or pattern
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:533)
</summary>
</member>
<member name="M:FSComp.SR.tcFSharpCoreRequiresExplicit">
<summary>
 All record, union and struct types in FSharp.Core.dll must be explicitly labelled with &apos;StructuralComparison&apos; or &apos;NoComparison&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1077)
</summary>
</member>
<member name="M:FSComp.SR.tcExtraneousFieldsGivenValues">
<summary>
 Extraneous fields have been given values
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:631)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionWithIfRequiresParenthesis">
<summary>
 This list or array expression includes an element of the form &apos;if ... then ... else&apos;. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:605)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionRequiresSequence">
<summary>
 This expression form may only be used in sequence and computation expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:601)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionFormRequiresRecordTypes">
<summary>
 The expression form { expr with ... } may only be used with record types. To build object types use { new Type(...) with ... }
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:652)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionFormRequiresObjectConstructor">
<summary>
 The expression form &apos;expr then expr&apos; may only be used as part of an explicit object constructor
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:608)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionCountMisMatch(System.Int32,System.Int32)">
<summary>
 Expected %d expressions, got %d
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:599)
</summary>
</member>
<member name="M:FSComp.SR.tcExprUndelayed">
<summary>
 TcExprUndelayed: delayed
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:600)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
<summary>
 Explicit type specifications cannot be used for exception constructors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:781)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitTypeParameterInvalid">
<summary>
 Explicit type parameters may only be used on module or member bindings
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:530)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitStaticInitializerSyntax">
<summary>
 An explicit static initializer should use the syntax &apos;static new(args) = expr&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:543)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitSignaturesInImplementationFileCannotBeUsed">
<summary>
 Explicit signatures within implementation files may no longer be used
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:836)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitObjectConstructorSyntax">
<summary>
 An explicit object constructor should use the syntax &apos;new(args) = expr&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:544)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedUnitOfMeasureNotType">
<summary>
 Expected unit-of-measure, not type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:570)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedUnitOfMeasureMarkWithAttribute">
<summary>
 Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:567)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedTypeParameter">
<summary>
 Expected type parameter, not unit-of-measure parameter
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:568)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedTypeNotUnitOfMeasure">
<summary>
 Expected type, not unit-of-measure
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:569)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedInterfaceType">
<summary>
 Expected an interface type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:645)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectModuleOrNamespaceParent(System.String)">
<summary>
 Expected module or namespace parent %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:517)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionAbbreviationsShouldNotHaveArgumentList">
<summary>
 Exception abbreviations should not have argument lists
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:782)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionAbbreviationsMustReferToValidExceptions">
<summary>
 Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:784)
</summary>
</member>
<member name="M:FSComp.SR.tcEventIsStatic(System.String)">
<summary>
 Event &apos;%s&apos; is static
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:679)
</summary>
</member>
<member name="M:FSComp.SR.tcEventIsNotStatic(System.String)">
<summary>
 Event &apos;%s&apos; is not static
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:680)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumerationsMayNotHaveMembers">
<summary>
 Enumerations cannot have members
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:762)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumerationsCannotHaveInterfaceDeclaration">
<summary>
 Enumerations cannot have interface declarations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:770)
</summary>
</member>
<member name="M:FSComp.SR.tcEntryPointAttributeRequiresFunctionInModule">
<summary>
 The &apos;EntryPointAttribute&apos; attribute may only be used on function definitions in modules
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:694)
</summary>
</member>
<member name="M:FSComp.SR.tcEmptyRecordInvalid">
<summary>
 &apos;{ }&apos; is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list &apos;[]&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:655)
</summary>
</member>
<member name="M:FSComp.SR.tcDuplicateSpecOfInterface">
<summary>
 Duplicate specification of an interface
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:755)
</summary>
</member>
<member name="M:FSComp.SR.tcDoesNotAllowExplicitTypeArguments(System.String)">
<summary>
 The method or function &apos;%s&apos; should not be given explicit type argument(s) because it does not declare its type parameters explicitly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:550)
</summary>
</member>
<member name="M:FSComp.SR.tcDoBangIllegalInSequenceExpression">
<summary>
 &apos;do!&apos; cannot be used within sequence expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:660)
</summary>
</member>
<member name="M:FSComp.SR.tcDllImportStubsCannotBeInlined">
<summary>
 DLLImport stubs cannot be inlined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:522)
</summary>
</member>
<member name="M:FSComp.SR.tcDelegatesCannotBeCurried">
<summary>
 Delegate specifications must not be curried types. Use &apos;typ * ... * typ -&gt; typ&apos; for multi-argument delegates, and &apos;typ -&gt; (typ -&gt; typ)&apos; for delegates returning function values.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:819)
</summary>
</member>
<member name="M:FSComp.SR.tcDelegateConstructorMustBePassed">
<summary>
 A delegate constructor must be passed a single function value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:687)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultValueAttributeRequiresVal">
<summary>
 The &apos;DefaultValue&apos; attribute may only be used on &apos;val&apos; declarations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:691)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultStructConstructorCall">
<summary>
 The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:552)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
<summary>
 A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:773)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultImplementationAlreadyExists">
<summary>
 This method already has a default implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:723)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultAmbiguous">
<summary>
 The method implemented by this default is ambiguous
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:724)
</summary>
</member>
<member name="M:FSComp.SR.tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(System.String)">
<summary>
 The declared type parameters for this type extension do not match the declared type parameters on the original type &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:826)
</summary>
</member>
<member name="M:FSComp.SR.tcDeclarationElementNotPermittedInAugmentation">
<summary>
 This declaration element is not permitted in an augmentation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:775)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeMustInvokeConstructor">
<summary>
 A custom attribute must invoke an object constructor
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:714)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeMustBeReferenceType">
<summary>
 A custom attribute must be a reference type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:712)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeArgumentMismatch">
<summary>
 The number of args for a custom attribute does not match the expected number of args for the attribute constructor
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:713)
</summary>
</member>
<member name="M:FSComp.SR.tcCouldNotFindIDisposable">
<summary>
 Couldn&apos;t find Dispose on IDisposable, or it was overloaded
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:553)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsIllegalForThisType">
<summary>
 Constructors cannot be defined for this type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:738)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsDisallowedInExceptionAugmentation">
<summary>
 Constructors cannot be specified in exception augmentations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:736)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsCannotBeFirstClassValues">
<summary>
 Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function &apos;(fun arg1 ... argN -&gt; new Type(arg1,...,argN))&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:677)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorRequiresCall(System.String)">
<summary>
 Constructors for the type &apos;%s&apos; must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:628)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorRequiresArguments">
<summary>
 This object constructor requires arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:647)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorForInterfacesDoNotTakeArguments">
<summary>
 Constructor expressions for interfaces do not take arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:646)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorCannotHaveTypeParameters">
<summary>
 A constructor cannot have explicit type parameters. Consider using a static construction method instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:537)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresSequenceOrComputations">
<summary>
 This construct may only be used within sequence or computation expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:615)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresListArrayOrSequence">
<summary>
 This construct may only be used within list, array and sequence expressions, e.g. expressions of the form &apos;seq { ... }&apos;, &apos;[ ... ]&apos; or &apos;[| ... |]&apos;. These use the syntax &apos;for ... in ... do ... yield...&apos; to generate elements
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:613)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresComputationExpressions">
<summary>
 This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without &apos;return&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:614)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresComputationExpression">
<summary>
 This construct may only be used within computation expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:616)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructIsAmbiguousInSequenceExpression">
<summary>
 This construct is ambiguous as part of a sequence expression. Nested expressions may be written using &apos;let _ = (...)&apos; and nested sequences using &apos;yield! seq {... }&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:659)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructIsAmbiguousInComputationExpression">
<summary>
 This construct is ambiguous as part of a computation expression. Nested expressions may be written using &apos;let _ = (...)&apos; and nested computations using &apos;let! res = builder { ... }&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:658)
</summary>
</member>
<member name="M:FSComp.SR.tcConstrainedTypeVariableCannotBeGeneralized">
<summary>
 One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:526)
</summary>
</member>
<member name="M:FSComp.SR.tcConditionalAttributeUsage">
<summary>
 Attribute &apos;System.Diagnostics.ConditionalAttribute&apos; is only valid on methods or attribute classes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1123)
</summary>
</member>
<member name="M:FSComp.SR.tcConditionalAttributeRequiresMembers">
<summary>
 The &apos;ConditionalAttribute&apos; attribute may only be used on members
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:692)
</summary>
</member>
<member name="M:FSComp.SR.tcConcreteMembersIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type, or use implicit class construction, to indicate that the type is a concrete implementation class.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:735)
</summary>
</member>
<member name="M:FSComp.SR.tcCompiledNameAttributeMisused">
<summary>
 The &apos;CompiledName&apos; attribute cannot be used with this language element
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:621)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromVariableType">
<summary>
 Cannot inherit from a variable type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:619)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromSealedType">
<summary>
 Cannot inherit a sealed type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:814)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromInterfaceType">
<summary>
 Cannot inherit from interface type. Use interface ... with instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:815)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCreateExtensionOfSealedType">
<summary>
 Cannot create an extension of a sealed type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:639)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCallAbstractBaseMember(System.String)">
<summary>
 Cannot call an abstract base member: &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1107)
</summary>
</member>
<member name="M:FSComp.SR.tcBindingCannotBeUseAndRec">
<summary>
 A binding cannot be marked both &apos;use&apos; and &apos;rec&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:688)
</summary>
</member>
<member name="M:FSComp.SR.tcBadReturnTypeForGetEnumerator">
<summary>
 This expression has a method called GetEnumerator, but its return type is a value type. Methods returning struct enumerators cannot be used in this expression form.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:559)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesOfTypeSpecifyMultipleKindsForType">
<summary>
 The attributes of this type specify multiple kinds for the type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:791)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesInvalidInPatterns">
<summary>
 Attributes are not allowed within patterns
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:548)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesAreNotPermittedOnLetBindings">
<summary>
 Attributes are not permitted on &apos;let&apos; bindings in expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:690)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeIsNotValidForLanguageElementUseDo">
<summary>
 This attribute is not valid for use on this language element. Assembly attributes should be attached to a &apos;do ()&apos; declaration, if necessary within an F# module.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:707)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeIsNotValidForLanguageElement">
<summary>
 This attribute is not valid for use on this language element
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:708)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeExpressionsMustBeConstructorCalls">
<summary>
 Attribute expressions must be calls to object constructors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:715)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeAutoOpenWasIgnored(System.String,System.String)">
<summary>
 The attribute &apos;AutoOpen(\&quot;%s\&quot;)&apos; in the assembly &apos;%s&apos; did not refer to a valid module or namespace in that assembly and has been ignored
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:838)
</summary>
</member>
<member name="M:FSComp.SR.tcAttribArgsDiffer(System.String)">
<summary>
 The attribute &apos;%s&apos; appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1106)
</summary>
</member>
<member name="M:FSComp.SR.tcAtLeastOneOverrideIsInvalid">
<summary>
 At least one override did not correctly implement its corresponding abstract member
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:649)
</summary>
</member>
<member name="M:FSComp.SR.tcArgumentArityMismatchOneOverload(System.String,System.Int32)">
<summary>
 The member &apos;%s&apos; does not accept the correct number of arguments. One overload accepts %d arguments.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:635)
</summary>
</member>
<member name="M:FSComp.SR.tcArgumentArityMismatch(System.String,System.Int32)">
<summary>
 The member &apos;%s&apos; does not accept the correct number of arguments, %d arguments are expected
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:634)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonymousUnitsOfMeasureCannotBeNested">
<summary>
 Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:578)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonymousTypeInvalidInDeclaration">
<summary>
 Anonymous type variables are not permitted in this declaration
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:579)
</summary>
</member>
<member name="M:FSComp.SR.tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
<summary>
 Types with the &apos;AllowNullLiteral&apos; attribute may only inherit from or implement types which also allow the use of the null literal
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:799)
</summary>
</member>
<member name="M:FSComp.SR.tcAllImplementedInterfacesShouldBeDeclared">
<summary>
 All implemented interfaces should be declared on the initial declaration of the type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:772)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractTypeCannotBeInstantiated">
<summary>
 Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression &apos;{ new ... with ... }&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:625)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractPropertyMissingGetOrSet(System.String)">
<summary>
 This property overrides or implements an abstract property but the abstract property doesn&apos;t have a corresponding %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:726)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractMembersIllegalInAugmentation">
<summary>
 Abstract members are not permitted in an augmentation - they must be defined as part of the type itself
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:719)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
<summary>
 Abbreviations for Common IL exception types must have a matching object constructor
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:785)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
<summary>
 Abbreviations for Common IL exceptions cannot take arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:783)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviatedTypesCannotBeSealed">
<summary>
 Abbreviated types cannot be given the &apos;Sealed&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:813)
</summary>
</member>
<member name="M:FSComp.SR.tastValueMustBeLocalAndMutable">
<summary>
 A value must be mutable in order to mutate the contents or take the address of a value type, e.g. &apos;let mutable x = ...&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:88)
</summary>
</member>
<member name="M:FSComp.SR.tastValueHasBeenCopied">
<summary>
 The value has been copied to ensure the original is not mutated by this operation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:90)
</summary>
</member>
<member name="M:FSComp.SR.tastValueDoesNotHaveSetterType">
<summary>
 This value does not have a valid property setter type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:84)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfInternalsVisibleToAttribute">
<summary>
 Unexpected decode of InternalsVisibleToAttribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:95)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
<summary>
 Unexpected decode of InterfaceDataVersionAttribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:96)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfAutoOpenAttribute">
<summary>
 Unexpected decode of AutoOpenAttribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:94)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedByRef">
<summary>
 Unexpected use of a byref-typed variable
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:87)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedTyconItemUnionCase(System.String,System.String)">
<summary>
 The type %s did not contain the union case &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1098)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedTyconItemField(System.String,System.String)">
<summary>
 The type %s did not contain the field &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1097)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefVal(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the val &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1100)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefModuleNamespaceType(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the namespace, module or type &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1101)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefModuleNamespace(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the module/namespace &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1099)
</summary>
</member>
<member name="M:FSComp.SR.tastTypeOrModuleNotConcrete(System.String)">
<summary>
 The type/module &apos;%s&apos; is not a concrete module or type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:74)
</summary>
</member>
<member name="M:FSComp.SR.tastTypeHasAssemblyCodeRepresentation(System.String)">
<summary>
 The type &apos;%s&apos; has an inline assembly code representation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:75)
</summary>
</member>
<member name="M:FSComp.SR.tastTwoModulesWithSameNameInAssembly(System.String)">
<summary>
 Two modules named &apos;%s&apos; occur in two parts of this assembly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:77)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotBeInConstructionOfTuple">
<summary>
 Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:91)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotBeAssignedToNonMutableField(System.String,System.String)">
<summary>
 Recursive values cannot be directly assigned to the non-mutable field &apos;%s&apos; of the type &apos;%s&apos; within a recursive binding. Consider using a mutable field instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:93)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotAppearInConstructionOfType(System.String)">
<summary>
 Recursive values cannot appear directly as a construction of the type &apos;%s&apos; within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:92)
</summary>
</member>
<member name="M:FSComp.SR.tastNotAConstantExpression">
<summary>
 This is not a constant expression or valid custom attribute value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:99)
</summary>
</member>
<member name="M:FSComp.SR.tastNamespaceAndModuleWithSameNameInAssembly(System.String)">
<summary>
 A namespace and a module named &apos;%s&apos; both occur in two parts of this assembly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:76)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidMutationOfConstant">
<summary>
 Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. &apos;let mutable x = ...&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:89)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidMemberSignature">
<summary>
 Invalid member signature encountered because of an earlier error
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:83)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidFormForPropertySetter">
<summary>
 Invalid form for a property setter. At least one argument is required.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:86)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidFormForPropertyGetter">
<summary>
 Invalid form for a property getter. At least one &apos;()&apos; argument is required when using the explicit syntax.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:85)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidAddressOfMutableAcrossAssemblyBoundary">
<summary>
 This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. &apos;let mutable x = ...&apos;, and if necessary assigning the value back after the completion of the operation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1093)
</summary>
</member>
<member name="M:FSComp.SR.tastDuplicateTypeDefinitionInAssembly(System.String,System.String)">
<summary>
 Two type definitions named &apos;%s&apos; occur in namespace &apos;%s&apos; in two parts of this assembly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:78)
</summary>
</member>
<member name="M:FSComp.SR.tastConstantCannotBeCustomAttribute">
<summary>
 This constant cannot be used as a custom attribute value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:98)
</summary>
</member>
<member name="M:FSComp.SR.tastConflictingModuleAndTypeDefinitionInAssembly(System.String,System.String)">
<summary>
 A module and a type definition named &apos;%s&apos; occur in namespace &apos;%s&apos; in two parts of this assembly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:79)
</summary>
</member>
<member name="M:FSComp.SR.tastActivePatternsLimitedToSeven">
<summary>
 Active patterns cannot return more than 7 possibilities
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:97)
</summary>
</member>
<member name="M:FSComp.SR.structOrClassFieldIsNotAccessible(System.String)">
<summary>
 The struct or class field &apos;%s&apos; is not accessible from this code location
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:973)
</summary>
</member>
<member name="P:FSComp.SR.SwallowResourceText(System.Boolean)">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:FSComp.SR.recursiveClassHierarchy(System.String)">
<summary>
 Recursive class hierarchy in type &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:965)
</summary>
</member>
<member name="M:FSComp.SR.pickleErrorReadingWritingMetadata(System.String,System.String)">
<summary>
 Error reading/writing metadata for the F# compiled DLL &apos;%s&apos;. Was the DLL compiled with an earlier version of the F# compiler? (error: &apos;%s&apos;).
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:70)
</summary>
</member>
<member name="M:FSComp.SR.patcPartialActivePatternsGenerateOneResult">
<summary>
 Partial active patterns may only generate one result
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:992)
</summary>
</member>
<member name="M:FSComp.SR.patcMissingVariable(System.String)">
<summary>
 Missing variable &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:991)
</summary>
</member>
<member name="M:FSComp.SR.parsVisibilityIllegalOnInherit">
<summary>
 Accessibility modifiers are not permitted on an &apos;inherits&apos; declaration
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:436)
</summary>
</member>
<member name="M:FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier">
<summary>
 Accessibility modifiers should come immediately prior to the identifier naming a construct
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:407)
</summary>
</member>
<member name="M:FSComp.SR.parsUseBindingsIllegalInModules">
<summary>
 &apos;use&apos; bindings are not permitted in modules and are treated as &apos;let&apos; bindings
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:400)
</summary>
</member>
<member name="M:FSComp.SR.parsUseBindingsIllegalInImplicitClassConstructors">
<summary>
 &apos;use&apos; bindings are not permitted in implicit class constructors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:399)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedWith">
<summary>
 Unmatched &apos;with&apos; or badly formatted &apos;with&apos; block
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:423)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedParen">
<summary>
 Unmatched &apos;(&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:450)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLetOrDo">
<summary>
 No body found for this &apos;let&apos; or &apos;do&apos;. The body must be indented to the same column as this line.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:449)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedIf">
<summary>
 Unmatched &apos;if&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:455)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedClassInterfaceOrStruct">
<summary>
 Unmatched &apos;class&apos;, &apos;interface&apos; or &apos;struct&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:421)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBracketBar">
<summary>
 Unmatched &apos;[|&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:469)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBracket">
<summary>
 Unmatched &apos;[&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:464)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBrace">
<summary>
 Unmatched &apos;{&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:470)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBeginOrStruct">
<summary>
 Unmatched &apos;begin&apos; or &apos;struct&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:414)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBegin">
<summary>
 Unmatched &apos;begin&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:426)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatched(System.String)">
<summary>
 Unmatched &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:468)
</summary>
</member>
<member name="M:FSComp.SR.parsUnionCasesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on union cases. Use &apos;type U = internal ...&apos; or &apos;type U = private ...&apos; to give an accessibility to the whole representation.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:444)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedVisibilityDeclaration">
<summary>
 Accessibility modifiers are not permitted here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:405)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedTypeParameter">
<summary>
 Syntax error: unexpected type parameter specification
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:481)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedSemicolon">
<summary>
 A semicolon is not expected at this point
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:403)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure">
<summary>
 Unexpected infix operator in unit-of-measure expression. Legal operators are &apos;*&apos;, &apos;/&apos; and &apos;^&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:479)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedIntegerLiteralForUnitOfMeasure">
<summary>
 Unexpected integer literal in unit-of-measure expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:480)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedIntegerLiteral">
<summary>
 Unexpected integer literal in type expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:478)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedInfixOperator">
<summary>
 Unexpected infix operator in type expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:476)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedIdentifier(System.String)">
<summary>
 Unexpected identifier: &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:443)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFile">
<summary>
 Unexpected end of input
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:404)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEmptyModuleDefn">
<summary>
 Unexpected empty type moduleDefn list
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:416)
</summary>
</member>
<member name="M:FSComp.SR.parsUnclosedFor">
<summary>
 Unclosed &apos;for&apos;, e.g. no &apos;done&apos; found to match this &apos;for&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:459)
</summary>
</member>
<member name="M:FSComp.SR.parsUnClosedBlockInHashLight">
<summary>
 Unclosed block
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:413)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeAnnotationsOnGetSet">
<summary>
 Type annotations on property getters and setters must be given after the &apos;get()&apos; or &apos;set(v)&apos;, e.g. &apos;with get() : string = ...&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:429)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted in this position for type abbreviations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:439)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxModuleStructEndDeprecated">
<summary>
 The syntax &apos;module ... = struct .. end&apos; is not used in F# code. Consider using &apos;module ... = begin .. end&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:485)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxModuleSigEndDeprecated">
<summary>
 The syntax &apos;module ... : sig .. end&apos; is not used in F# code. Consider using &apos;module ... = begin .. end&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:486)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxErrorInLabeledType">
<summary>
 Syntax error in labelled type argument
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:475)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxError">
<summary>
 Syntax error
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:419)
</summary>
</member>
<member name="M:FSComp.SR.parsSuccessivePatternsShouldBeSpacedOrTupled">
<summary>
 Successive patterns should be separated by spaces or tupled
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:451)
</summary>
</member>
<member name="M:FSComp.SR.parsSuccessiveArgsShouldBeSpacedOrTupled">
<summary>
 Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:463)
</summary>
</member>
<member name="M:FSComp.SR.parsSetterAtMostTwoArguments">
<summary>
 A setter property may have at most two argument groups
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1090)
</summary>
</member>
<member name="M:FSComp.SR.parsSetSyntax">
<summary>
 Property setters must be defined using &apos;set value = &apos;, &apos;set idx value = &apos; or &apos;set (idx1,...,idxN) value = ... &apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:432)
</summary>
</member>
<member name="M:FSComp.SR.parsRecordFieldsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on record fields. Use &apos;type R = internal ...&apos; or &apos;type R = private ...&apos; to give an accessibility to the whole representation.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:447)
</summary>
</member>
<member name="M:FSComp.SR.parsParenFormIsForML">
<summary>
 In F# code you may use &apos;expr.[expr]&apos;. A type annotation may be required to indicate the first expression is an array
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:466)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyOneWithAugmentationAllowed">
<summary>
 At most one &apos;with&apos; augmentation is permitted
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:402)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyHashDirectivesAllowed">
<summary>
 Only &apos;#&apos; compiler directives may occur prior to the first &apos;namespace&apos; declaration
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:406)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyClassCanTakeValueArguments">
<summary>
 Only class types may take value arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:425)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAtomicType">
<summary>
 The use of the type syntax &apos;int C&apos; and &apos;C  &lt;int&gt;&apos; is not permitted here. Consider adjusting this type to be written in the form &apos;C&lt;int&gt;&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1096)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAdjacentTypars">
<summary>
 Type parameters must be placed directly adjacent to the type name, e.g. \&quot;type C&lt;&apos;T&gt;\&quot;, not     type \&quot;C   &lt;&apos;T&gt;\&quot;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1094)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAdjacentTyargs">
<summary>
 Type arguments must be placed directly adjacent to the type name, e.g. \&quot;C&lt;&apos;T&gt;\&quot;, not \&quot;C  &lt;&apos;T&gt;\&quot;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1095)
</summary>
</member>
<member name="M:FSComp.SR.parsNoMatchingInForLet">
<summary>
 No matching &apos;in&apos; found for this &apos;let&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:452)
</summary>
</member>
<member name="M:FSComp.SR.parsNoHashEndIfFound">
<summary>
 No #endif found for #if or #else
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:397)
</summary>
</member>
<member name="M:FSComp.SR.parsNoEqualShouldFollowNamespace">
<summary>
 No &apos;=&apos; symbol should follow a &apos;namespace&apos; declaration
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:484)
</summary>
</member>
<member name="M:FSComp.SR.parsNamespaceOrModuleNotBoth">
<summary>
 Files should begin with either a namespace or module declaration, e.g. &apos;namespace SomeNamespace.SubNamespace&apos; or &apos;module SomeNamespace.SomeModule&apos;, but not both. To define a module within a namespace use &apos;module SomeModule = ...&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:408)
</summary>
</member>
<member name="M:FSComp.SR.parsMultipleAccessibilitiesForGetSet">
<summary>
 Multiple accessibilities given for property getter or setter
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:431)
</summary>
</member>
<member name="M:FSComp.SR.parsMultiArgumentGenericTypeFormDeprecated">
<summary>
 The syntax &apos;(typ,...,typ) ident&apos; is not used in F# code. Consider using &apos;ident&lt;typ,...,typ&gt;&apos; instead
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:477)
</summary>
</member>
<member name="M:FSComp.SR.parsModuleDefnMustBeSimpleName">
<summary>
 A module name must be a simple name, not a path
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:415)
</summary>
</member>
<member name="M:FSComp.SR.parsModuleAbbreviationMustBeSimpleName">
<summary>
 A module abbreviation must be a simple name, not a path
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:409)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingQualificationAfterDot">
<summary>
 Missing qualification after &apos;.&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:465)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingFunctionBody">
<summary>
 Missing function body
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:473)
</summary>
</member>
<member name="M:FSComp.SR.parsMismatchedQuote(System.String)">
<summary>
 Mismatched quotation, beginning with &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:467)
</summary>
</member>
<member name="M:FSComp.SR.parsMismatchedQuotationName(System.String)">
<summary>
 Mismatched quotation operator name, beginning with &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:482)
</summary>
</member>
<member name="M:FSComp.SR.parsMemberIllegalInObjectImplementation">
<summary>
 This member is not permitted in an object implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:472)
</summary>
</member>
<member name="M:FSComp.SR.parsLetAndForNonRecBindings">
<summary>
 The declaration form &apos;let ... and ...&apos; for non-recursive bindings is not used in F# code. Consider using a sequence of &apos;let&apos; bindings
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:448)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidProperty">
<summary>
 Invalid property getter or setter
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1091)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidPrefixOperatorDefinition">
<summary>
 Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1116)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidPrefixOperator">
<summary>
 Invalid prefix operator
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1115)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidDeclarationSyntax">
<summary>
 Invalid declaration syntax
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:427)
</summary>
</member>
<member name="M:FSComp.SR.parsInterfacesHaveSameVisibilityAsEnclosingType">
<summary>
 Interfaces always have the same visibility as the enclosing type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:433)
</summary>
</member>
<member name="M:FSComp.SR.parsIntegerForLoopRequiresSimpleIdentifier">
<summary>
 An integer for loop must use a simple identifier
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:401)
</summary>
</member>
<member name="M:FSComp.SR.parsInlineAssemblyCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on inline assembly code types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:442)
</summary>
</member>
<member name="M:FSComp.SR.parsInheritDeclarationsCannotHaveAsBindings">
<summary>
 &apos;inherit&apos; declarations cannot have &apos;as&apos; bindings. To access members of the base class when overriding a method, the syntax &apos;base.SomeMember&apos; may be used; &apos;base&apos; is a keyword. Remove this &apos;as&apos; binding.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:437)
</summary>
</member>
<member name="M:FSComp.SR.parsIndexerPropertyRequiresAtLeastOneArgument">
<summary>
 An indexer property must be given at least one argument
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1092)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
<summary>
 Ignoring visibility attribute on module abbreviation. Module abbreviations are always private.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:412)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
<summary>
 Ignoring accessibility attribute on module abbreviation. Module abbreviations are always private.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:411)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreAttributesOnModuleAbbreviation">
<summary>
 Ignoring attributes on module abbreviation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:410)
</summary>
</member>
<member name="M:FSComp.SR.parsIdentifierExpected">
<summary>
 Identifier expected
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:460)
</summary>
</member>
<member name="M:FSComp.SR.parsGetterMustHaveAtLeastOneArgument">
<summary>
 A getter property is expected to be a function, e.g. &apos;get() = ...&apos; or &apos;get(index) = ...&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:430)
</summary>
</member>
<member name="M:FSComp.SR.parsGetterAtMostOneArgument">
<summary>
 A getter property may have at most one argument group
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1089)
</summary>
</member>
<member name="M:FSComp.SR.parsGetOrSetRequired">
<summary>
 &apos;get&apos;, &apos;set&apos; or &apos;get,set&apos; required
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:424)
</summary>
</member>
<member name="M:FSComp.SR.parsGetAndOrSetRequired">
<summary>
 &apos;get&apos; and/or &apos;set&apos; required
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:428)
</summary>
</member>
<member name="M:FSComp.SR.parsFieldBinding">
<summary>
 Field bindings must have the form &apos;id = expr;&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:471)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedStatementAfterLet(System.String)">
<summary>
 Block following this &apos;%s&apos; is unfinished. Expect an expression.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:454)
</summary>
</member>
<member name="M:FSComp.SR.parsErrorInReturnForLetIncorrectIndentation">
<summary>
 Error in the return expression for this &apos;let&apos;. Possible incorrect indentation.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:453)
</summary>
</member>
<member name="M:FSComp.SR.parsErrorInFunctionBlock">
<summary>
 Error in &apos;function&apos; block
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:474)
</summary>
</member>
<member name="M:FSComp.SR.parsEqualExpected">
<summary>
 &apos;=&apos; expected
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:461)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInVerbatimStringInComment">
<summary>
 End of file in verbatim string embedded in comment begun at or before here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:394)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInVerbatimString">
<summary>
 End of file in verbatim string begun at or before here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:391)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInStringInComment">
<summary>
 End of file in string embedded in comment begun at or before here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:393)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInString">
<summary>
 End of file in string begun at or before here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:390)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInIfOcaml">
<summary>
 End of file in IF-OCAML section begun at or before here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:395)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInHashIf">
<summary>
 End of file in #if section begun at or after here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:389)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInDirective">
<summary>
 End of file in directive begun at or before here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:396)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInComment">
<summary>
 End of file in comment begun at or before here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:392)
</summary>
</member>
<member name="M:FSComp.SR.parsEnumTypesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted in this position for enum types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:440)
</summary>
</member>
<member name="M:FSComp.SR.parsEnumFieldsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on enumeration fields
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:445)
</summary>
</member>
<member name="M:FSComp.SR.parsEmptyTypeDefinition">
<summary>
 A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use &apos;type ... = class end&apos;, &apos;interface end&apos; or &apos;struct end&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:422)
</summary>
</member>
<member name="M:FSComp.SR.parsDoneExpected">
<summary>
 &apos;done&apos; expected after this expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:457)
</summary>
</member>
<member name="M:FSComp.SR.parsDoExpected">
<summary>
 &apos;do&apos; expected after this expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:458)
</summary>
</member>
<member name="M:FSComp.SR.parsDoCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on &apos;do&apos; bindings
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:388)
</summary>
</member>
<member name="M:FSComp.SR.parsConsiderUsingSeparateRecordType">
<summary>
 Consider using a separate record type instead
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:446)
</summary>
</member>
<member name="M:FSComp.SR.parsAugmentationsIllegalOnDelegateType">
<summary>
 Augmentations are not permitted on delegate type moduleDefns
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:420)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesMustComeBeforeVal">
<summary>
 Attributes should be placed before &apos;val&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:417)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIllegalOnInherit">
<summary>
 Attributes are not permitted on &apos;inherit&apos; declarations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:435)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIllegalHere">
<summary>
 Attributes are not allowed here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:438)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIgnored">
<summary>
 Attributes have been ignored in this construct
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:398)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesAreNotPermittedOnInterfaceImplementations">
<summary>
 Attributes are not permitted on interface implementations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:418)
</summary>
</member>
<member name="M:FSComp.SR.parsAssertIsNotFirstClassValue">
<summary>
 &apos;assert&apos; may no longer be used as a first class value. Use &apos;assert &lt;expr&gt;&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:456)
</summary>
</member>
<member name="M:FSComp.SR.parsArrowUseIsLimited">
<summary>
 The use of &apos;-&gt;&apos; in sequence and computation expressions is limited to the form &apos;for pat in expr -&gt; expr&apos;. Use the syntax &apos;for ... in ... do ... yield...&apos; to generate elements in more complex sequence expressions.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:462)
</summary>
</member>
<member name="M:FSComp.SR.parsAllEnumFieldsRequireValues">
<summary>
 All enum fields must be given values
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:441)
</summary>
</member>
<member name="M:FSComp.SR.parsActivePatternCaseMustBeginWithUpperCase">
<summary>
 Active pattern case identifiers must begin with an uppercase letter
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:483)
</summary>
</member>
<member name="M:FSComp.SR.parsAccessibilityModsIllegalForAbstract">
<summary>
 Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:434)
</summary>
</member>
<member name="M:FSComp.SR.optsWriteXml">
<summary>
 Write the xmldoc of the assembly to the given file
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:876)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32res">
<summary>
 Specify a Win32 resource file (.res)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:884)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32manifest">
<summary>
 Specify a Win32 manifest file
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:885)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnaserrorPM">
<summary>
 Report all warnings as errors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:894)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnaserror">
<summary>
 Report specific warnings as errors
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:895)
</summary>
</member>
<member name="M:FSComp.SR.optsWarn">
<summary>
 Set a warning level (0-4)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:896)
</summary>
</member>
<member name="M:FSComp.SR.optsUtf8output">
<summary>
 Output messages in UTF-8 encoding
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:904)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedTarget(System.String)">
<summary>
 Unrecognized target &apos;%s&apos;, expected &apos;exe&apos;, &apos;winexe&apos;, &apos;library&apos; or &apos;module&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:913)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedDebugType(System.String)">
<summary>
 Unrecognized debug type &apos;%s&apos;, expected &apos;pdbonly&apos; or &apos;full&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:914)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownPlatform(System.String)">
<summary>
 Unrecognized platform &apos;%s&apos;, valid values are &apos;x86&apos;, &apos;x64&apos;, &apos;Itanium&apos;, and &apos;anycpu&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:928)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownArgumentToTheTestSwitch(System.String)">
<summary>
 Unknown --test argument: &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:927)
</summary>
</member>
<member name="M:FSComp.SR.optsTailcalls">
<summary>
 Enable or disable tailcalls
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:892)
</summary>
</member>
<member name="M:FSComp.SR.optsStrongKeyFile">
<summary>
 Specify a strong name key file
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:877)
</summary>
</member>
<member name="M:FSComp.SR.optsStrongKeyContainer">
<summary>
 Specify a strong name key container
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:878)
</summary>
</member>
<member name="M:FSComp.SR.optsStaticlink">
<summary>
 Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:910)
</summary>
</member>
<member name="M:FSComp.SR.optsStandalone">
<summary>
 Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:909)
</summary>
</member>
<member name="M:FSComp.SR.optsSimpleresolution">
<summary>
 Resolve assembly references using directory-based mono rules rather than MSBuild resolution (Default=false except when running fsc.exe under mono)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:912)
</summary>
</member>
<member name="M:FSComp.SR.optsSig">
<summary>
 Print the inferred interface of the assembly to a file
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:882)
</summary>
</member>
<member name="M:FSComp.SR.optsShortFormOf(System.String)">
<summary>
 Short form of &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:916)
</summary>
</member>
<member name="M:FSComp.SR.optsResource">
<summary>
 Embed the specified managed resource
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:887)
</summary>
</member>
<member name="M:FSComp.SR.optsReference">
<summary>
 Reference an assembly (Short form: -r)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:883)
</summary>
</member>
<member name="M:FSComp.SR.optsProblemWithCodepage(System.Int32,System.String)">
<summary>
 Problem with codepage &apos;%d&apos;: %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:868)
</summary>
</member>
<member name="M:FSComp.SR.optsPlatform">
<summary>
 Limit which platforms this code can run on: x86, Itanium, x64 or anycpu. The default is anycpu.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:879)
</summary>
</member>
<member name="M:FSComp.SR.optsPdb">
<summary>
 Name the output debug file
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:911)
</summary>
</member>
<member name="M:FSComp.SR.optsOptimize">
<summary>
 Enable optimizations (Short form: -O)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:891)
</summary>
</member>
<member name="M:FSComp.SR.optsNowin32manifest">
<summary>
 Do not include the default Win32 manifest
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:886)
</summary>
</member>
<member name="M:FSComp.SR.optsNowarn">
<summary>
 Disable specific warning messages
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:897)
</summary>
</member>
<member name="M:FSComp.SR.optsNologo">
<summary>
 Suppress compiler copyright message
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:901)
</summary>
</member>
<member name="M:FSComp.SR.optsNoframework">
<summary>
 Do not reference the default CLI assemblies by default
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:908)
</summary>
</member>
<member name="M:FSComp.SR.optsNoOpt">
<summary>
 Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:880)
</summary>
</member>
<member name="M:FSComp.SR.optsNoInterface">
<summary>
 Don&apos;t add a resource to the generated assembly containing F#-specific metadata
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:881)
</summary>
</member>
<member name="M:FSComp.SR.optsNameOfOutputFile">
<summary>
 Name of the output file (Short form: -o)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:870)
</summary>
</member>
<member name="M:FSComp.SR.optsMlcompatibility">
<summary>
 Ignore ML compatibility warnings
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:900)
</summary>
</member>
<member name="M:FSComp.SR.optsLinkresource">
<summary>
 Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:888)
</summary>
</member>
<member name="M:FSComp.SR.optsLib">
<summary>
 Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:906)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidWarningLevel(System.Int32)">
<summary>
 Invalid warning level &apos;%d&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:915)
</summary>
</member>
<member name="M:FSComp.SR.optsInternalNoDescription(System.String)">
<summary>
 The command-line option &apos;%s&apos; is for internal use only
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:929)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerResources">
<summary>
 - RESOURCES -
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:921)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerOutputFiles">
<summary>
 - OUTPUT FILES -
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:919)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerMisc">
<summary>
 - MISCELLANEOUS -
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:924)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerLanguage">
<summary>
 - LANGUAGE -
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:925)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerInputFiles">
<summary>
 - INPUT FILES -
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:920)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerErrsAndWarns">
<summary>
 - ERRORS AND WARNINGS -
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:926)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerCodeGen">
<summary>
 - CODE GENERATION -
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:922)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerAdvanced">
<summary>
 - ADVANCED -
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:923)
</summary>
</member>
<member name="M:FSComp.SR.optsHelp">
<summary>
 Display this usage message (Short form: -?)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:902)
</summary>
</member>
<member name="M:FSComp.SR.optsFullpaths">
<summary>
 Output messages with fully qualified paths
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:905)
</summary>
</member>
<member name="M:FSComp.SR.optsDelaySign">
<summary>
 Delay-sign the assembly using only the public portion of the strong name key
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:875)
</summary>
</member>
<member name="M:FSComp.SR.optsDefine">
<summary>
 Define conditional compilation symbols (Short form: -d)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:899)
</summary>
</member>
<member name="M:FSComp.SR.optsDebugPM">
<summary>
 Emit debug information (Short form: -g)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:889)
</summary>
</member>
<member name="M:FSComp.SR.optsDebug">
<summary>
 Specify debugging type: full, pdbonly. (&apos;full&apos; is the default and enables attaching a debugger to a running program).
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:890)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLONoDescription(System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:930)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLOHtmlDoc(System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:932)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLODeprecatedSuggestAlternative(System.String,System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated. Use &apos;%s&apos; instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:931)
</summary>
</member>
<member name="M:FSComp.SR.optsCrossoptimize">
<summary>
 Enable or disable cross-module optimizations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:893)
</summary>
</member>
<member name="M:FSComp.SR.optsCopyright">
<summary>
 Copyright (c) Microsoft Corporation. All Rights Reserved.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:869)
</summary>
</member>
<member name="M:FSComp.SR.optsCodepage">
<summary>
 Specify the codepage used to read source files
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:903)
</summary>
</member>
<member name="M:FSComp.SR.optsClirootDescription">
<summary>
 Use to override where the compiler looks for mscorlib.dll and framework components
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:918)
</summary>
</member>
<member name="M:FSComp.SR.optsClirootDeprecatedMsg">
<summary>
 The command-line option &apos;--cliroot&apos; has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:917)
</summary>
</member>
<member name="M:FSComp.SR.optsChecked">
<summary>
 Generate overflow checks
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:898)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildWindows">
<summary>
 Build a Windows executable
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:872)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildModule">
<summary>
 Build a module that can be added to another assembly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:874)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildLibrary">
<summary>
 Build a library (Short form: -a)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:873)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildConsole">
<summary>
 Build a console executable
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:871)
</summary>
</member>
<member name="M:FSComp.SR.optsBaseaddress">
<summary>
 Base address for the library to be built
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:907)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineHasUnexpectedValue">
<summary>
 A value marked as &apos;inline&apos; has an unexpected value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1007)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineCouldNotBeInlined">
<summary>
 A value marked as &apos;inline&apos; could not be inlined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1008)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineButWasNotBoundInTheOptEnv(System.String)">
<summary>
 The value &apos;%s&apos; was marked inline but was not bound in the optimization environment
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1005)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineButIncomplete(System.String)">
<summary>
 The value &apos;%s&apos; was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1004)
</summary>
</member>
<member name="M:FSComp.SR.optRecursiveValValue(System.String)">
<summary>
 Recursive ValValue %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1010)
</summary>
</member>
<member name="M:FSComp.SR.optLocalValueNotFoundDuringOptimization(System.String)">
<summary>
 Local value %s not found during optimization
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1006)
</summary>
</member>
<member name="M:FSComp.SR.optFailedToInlineValue(System.String)">
<summary>
 Failed to inline the value &apos;%s&apos; marked &apos;inline&apos;, perhaps because a recursive value was marked &apos;inline&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1009)
</summary>
</member>
<member name="M:FSComp.SR.nrUnexpectedEmptyLongId">
<summary>
 Unexpected empty long identifier
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1025)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeInstantiationNeededToDisambiguateTypesWithSameName(System.String,System.String)">
<summary>
 Multiple types exist called &apos;%s&apos;, taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1021)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeInstantiationIsMissingAndCouldNotBeInferred(System.String,System.String)">
<summary>
 The instantiation of the generic type &apos;%s&apos; is missing and can&apos;t be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1022)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeDoesNotContainSuchField(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not contain a field &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1026)
</summary>
</member>
<member name="M:FSComp.SR.nrNoConstructorsAvailableForType(System.String)">
<summary>
 No constructors are available for the type &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1029)
</summary>
</member>
<member name="M:FSComp.SR.nrIsNotConstructorOrLiteral">
<summary>
 This is not a constructor or literal, or a constructor is being used incorrectly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1024)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidModuleExprType">
<summary>
 Invalid module/expression/type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1020)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidFieldLabel">
<summary>
 Invalid field label
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1027)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidExpression(System.String)">
<summary>
 Invalid expression &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1028)
</summary>
</member>
<member name="M:FSComp.SR.nrGlobalUsedOnlyAsFirstName">
<summary>
 &apos;global&apos; may only be used as the first name in a qualified path
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1023)
</summary>
</member>
<member name="M:FSComp.SR.noInvokeMethodsFound">
<summary>
 No Invoke methods found for delegate type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:975)
</summary>
</member>
<member name="M:FSComp.SR.moreThanOneInvokeMethodFound">
<summary>
 More than one Invoke method found for delegate type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:976)
</summary>
</member>
<member name="M:FSComp.SR.monoRegistryBugWorkaround">
<summary>
 Could not determine highest installed .NET framework version from Registry keys, using version 2.0
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1124)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatMessage(System.String)">
<summary>
 This construct is for ML compatibility. %s. You can disable this warning by using &apos;--mlcompatibility&apos; or &apos;--nowarn:62&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1111)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNonPairArgument(System.String,System.Int32)">
<summary>
 Infix operator member &apos;%s&apos; has %d initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1075)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNoArguments(System.String)">
<summary>
 Infix operator member &apos;%s&apos; has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1074)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithCurriedArguments(System.String)">
<summary>
 Infix operator member &apos;%s&apos; has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1076)
</summary>
</member>
<member name="M:FSComp.SR.lexhlpIdentifiersContainingAtSymbolReserved">
<summary>
 Identifiers containing &apos;@&apos; are reserved for use in F# code generation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:986)
</summary>
</member>
<member name="M:FSComp.SR.lexhlpIdentifierReserved(System.String)">
<summary>
 The identifier &apos;%s&apos; is reserved for future use by F#
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:987)
</summary>
</member>
<member name="M:FSComp.SR.lexfltTokenIsOffsideOfContextStartedEarlier(System.String)">
<summary>
 Possible incorrect indentation: this token is offside of context started at position %s. Try indenting this token further or using standard formatting conventions.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1015)
</summary>
</member>
<member name="M:FSComp.SR.lexfltSeparatorTokensOfPatternMatchMisaligned">
<summary>
 The &apos;|&apos; tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1016)
</summary>
</member>
<member name="M:FSComp.SR.lexfltIncorrentIndentationOfIn">
<summary>
 The indentation of this &apos;in&apos; token is incorrect with respect to the corresponding &apos;let&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1014)
</summary>
</member>
<member name="M:FSComp.SR.lexWrongNestedHashEndif">
<summary>
 Syntax error. Wrong nested #endif, unexpected tokens before it.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1072)
</summary>
</member>
<member name="M:FSComp.SR.lexUnexpectedChar(System.String)">
<summary>
 Unexpected character &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1041)
</summary>
</member>
<member name="M:FSComp.SR.lexTokenReserved">
<summary>
 This token is reserved for future use
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1062)
</summary>
</member>
<member name="M:FSComp.SR.lexThisUnicodeOnlyInStringLiterals">
<summary>
 This Unicode encoding is only valid in string literals
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1061)
</summary>
</member>
<member name="M:FSComp.SR.lexTabsNotAllowed">
<summary>
 TABs are not allowed in F# code unless the #indent \&quot;off\&quot; option is used
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1063)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitUnsigned">
<summary>
 This number is outside the allowable range for 32-bit unsigned integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1050)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitSigned">
<summary>
 This number is outside the allowable range for 32-bit signed integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1049)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixtyFourBitUnsigned">
<summary>
 This number is outside the allowable range for 64-bit unsigned integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1052)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixtyFourBitSigned">
<summary>
 This number is outside the allowable range for 64-bit signed integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1051)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixteenBitUnsigned">
<summary>
 This number is outside the allowable range for 16-bit unsigned integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1048)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixteenBitSigned">
<summary>
 This number is outside the allowable range for 16-bit signed integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1047)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideNativeUnsigned">
<summary>
 This number is outside the allowable range for unsigned native integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1054)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideNativeSigned">
<summary>
 This number is outside the allowable range for signed native integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1053)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideIntegerRange">
<summary>
 This number is outside the allowable range for this integer type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1038)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitUnsigned">
<summary>
 This number is outside the allowable range for 8-bit unsigned integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1046)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitSignedHex">
<summary>
 This number is outside the allowable range for hexadecimal 8-bit signed integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1045)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitSigned">
<summary>
 This number is outside the allowable range for 8-bit signed integers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1044)
</summary>
</member>
<member name="M:FSComp.SR.lexOusideThirtyTwoBitFloat">
<summary>
 This number is outside the allowable range for 32-bit floats
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1057)
</summary>
</member>
<member name="M:FSComp.SR.lexOusideDecimal">
<summary>
 This number is outside the allowable range for decimal literals
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1056)
</summary>
</member>
<member name="M:FSComp.SR.lexOpNamesCannotStartWithQuestionMark">
<summary>
 Character sequences beginning with &apos;?&apos; are no longer permitted as operator names
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1040)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidNumericLiteral">
<summary>
 This is not a valid numeric literal. Sample formats include 4, 0x4, 0b0100, 4L, 4UL, 4u, 4s, 4us, 4y, 4uy, 4.0, 4.0f, 4I.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1058)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidLineNumber(System.String)">
<summary>
 Invalid line number: &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1064)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidFloat">
<summary>
 Invalid floating point number
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1055)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidCharLiteral">
<summary>
 This is not a valid character literal
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1060)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidByteLiteral">
<summary>
 This is not a valid byte literal
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1059)
</summary>
</member>
<member name="M:FSComp.SR.lexIndentOffForML">
<summary>
 Consider using a file with extension &apos;.ml&apos; or &apos;.mli&apos; instead
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1118)
</summary>
</member>
<member name="M:FSComp.SR.lexIdentEndInMarkReserved(System.String)">
<summary>
 Identifiers followed by &apos;%s&apos; are reserved for future use
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1043)
</summary>
</member>
<member name="M:FSComp.SR.lexHashIfMustHaveIdent">
<summary>
 #if directive should be immediately followed by an identifier
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1071)
</summary>
</member>
<member name="M:FSComp.SR.lexHashIfMustBeFirst">
<summary>
 #if directive must appear as the first non-whitespace character on a line
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1065)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndingNoMatchingIf">
<summary>
 #endif has no matching #if
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1069)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndifRequiredForElse">
<summary>
 #endif required for #else
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1067)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndifMustBeFirst">
<summary>
 #endif directive must appear as the first non-whitespace character on a line
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1070)
</summary>
</member>
<member name="M:FSComp.SR.lexHashElseNoMatchingIf">
<summary>
 #else has no matching #if
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1066)
</summary>
</member>
<member name="M:FSComp.SR.lexHashElseMustBeFirst">
<summary>
 #else directive must appear as the first non-whitespace character on a line
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1068)
</summary>
</member>
<member name="M:FSComp.SR.lexExpectedSingleLineComment">
<summary>
 Expected single line comment or end of line
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1073)
</summary>
</member>
<member name="M:FSComp.SR.lexCharNotAllowedInOperatorNames(System.String)">
<summary>
 &apos;%s&apos; is not permitted as a character in operator names and is reserved for future use
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1039)
</summary>
</member>
<member name="M:FSComp.SR.lexByteArrayCannotEncode">
<summary>
 This byte array literal contains characters that do not encode as a single byte
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1042)
</summary>
</member>
<member name="M:FSComp.SR.impTypeRequiredUnavailable(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is required here and is unavailable. You must add a reference to assembly &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:996)
</summary>
</member>
<member name="M:FSComp.SR.impReferencedTypeCouldNotBeFoundInAssembly(System.String,System.String)">
<summary>
 A reference to the type &apos;%s&apos; in assembly &apos;%s&apos; was found, but the type could not be found in that assembly
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:997)
</summary>
</member>
<member name="M:FSComp.SR.impReferenceToDllRequiredByAssembly(System.String,System.String,System.String)">
<summary>
 A reference to the DLL %s is required by assembly %s. The imported type %s is located in the first assembly and could not be resolved.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:999)
</summary>
</member>
<member name="M:FSComp.SR.impNotEnoughTypeParamsInScopeWhileImporting">
<summary>
 Internal error or badly formed metadata: not enough type parameters were in scope while importing
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:998)
</summary>
</member>
<member name="M:FSComp.SR.impImportedAssemblyUsesNotPublicType(System.String)">
<summary>
 An imported assembly uses the type &apos;%s&apos; but that type is not public
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1000)
</summary>
</member>
<member name="M:FSComp.SR.ilwriteNoPDBsOnMonoWarning">
<summary>
 PDB files cannot be generated when running on Mono
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1034)
</summary>
</member>
<member name="M:FSComp.SR.ilwriteErrorCreatingPdb(System.String)">
<summary>
 Unexpected error creating debug information file &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1033)
</summary>
</member>
<member name="M:FSComp.SR.ilValuesWithLiteralAttributeMustBeSimple">
<summary>
 Values marked with &apos;LiteralAttribute&apos; must currently be simple integer, character, Boolean, string or floating point constants
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:849)
</summary>
</member>
<member name="M:FSComp.SR.ilValuesWithLiteralAttributeCannotBeMutable">
<summary>
 Values marked with &apos;LiteralAttribute&apos; cannot be mutable
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:848)
</summary>
</member>
<member name="M:FSComp.SR.ilUnexpectedUnrealizedValue">
<summary>
 Compiler error: unexpected unrealized value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:857)
</summary>
</member>
<member name="M:FSComp.SR.ilUnexpectedGetSetAnnotation">
<summary>
 Unexpected GetSet annotation on a property
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:860)
</summary>
</member>
<member name="M:FSComp.SR.ilUndefinedValue(System.String)">
<summary>
 Undefined value &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:842)
</summary>
</member>
<member name="M:FSComp.SR.ilTypeCannotBeUsedForLiteralField">
<summary>
 This type cannot be used for a literal field
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:859)
</summary>
</member>
<member name="M:FSComp.SR.ilStructLayoutAttributeCouldNotBeDecoded">
<summary>
 The StructLayout attribute could not be decoded
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:862)
</summary>
</member>
<member name="M:FSComp.SR.ilStaticMethodIsNotLambda(System.String)">
<summary>
 GenSetStorage: %s was represented as a static method but was not an appropriate lambda expression
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:855)
</summary>
</member>
<member name="M:FSComp.SR.ilSignatureForExternalFunctionContainsTypeParameters">
<summary>
 The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:852)
</summary>
</member>
<member name="M:FSComp.SR.ilReflectedDefinitionsCannotUseSliceOperator">
<summary>
 Reflected definitions cannot contain uses of the prefix splice operator &apos;%%&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:864)
</summary>
</member>
<member name="M:FSComp.SR.ilMutableVariablesCannotEscapeMethod">
<summary>
 Mutable variables cannot escape their method
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:856)
</summary>
</member>
<member name="M:FSComp.SR.ilMarshalAsAttributeCannotBeDecoded">
<summary>
 The MarshalAs attribute could not be decoded
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:851)
</summary>
</member>
<member name="M:FSComp.SR.ilMainModuleEmpty">
<summary>
 Main module of program is empty: nothing will happen when it is run
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:858)
</summary>
</member>
<member name="M:FSComp.SR.ilLiteralFieldsCannotBeSet">
<summary>
 Literal fields cannot be set
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:854)
</summary>
</member>
<member name="M:FSComp.SR.ilLabelNotFound(System.String)">
<summary>
 Label %s not found
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:843)
</summary>
</member>
<member name="M:FSComp.SR.ilIncorrectNumberOfTypeArguments">
<summary>
 Incorrect number of type arguments to local call
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:844)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldOffsetAttributeCouldNotBeDecoded">
<summary>
 The FieldOffset attribute could not be decoded
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:861)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldHasOffsetForSequentialLayout">
<summary>
 The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1121)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldDoesNotHaveValidOffsetForStructureLayout(System.String,System.String)">
<summary>
 The type &apos;%s&apos; has been marked as having an Explicit layout, but the field &apos;%s&apos; has not been marked with the &apos;FieldOffset&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1113)
</summary>
</member>
<member name="M:FSComp.SR.ilDynamicInvocationNotSupported(System.String)">
<summary>
 Dynamic invocation of %s is not supported
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:845)
</summary>
</member>
<member name="M:FSComp.SR.ilDllImportAttributeCouldNotBeDecoded">
<summary>
 The DllImport attribute could not be decoded
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:853)
</summary>
</member>
<member name="M:FSComp.SR.ilDefaultAugmentationAttributeCouldNotBeDecoded">
<summary>
 The DefaultAugmentation attribute could not be decoded
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:863)
</summary>
</member>
<member name="M:FSComp.SR.ilCustomMarshallersCannotBeUsedInFSharp">
<summary>
 Custom marshallers cannot be specified in F# code. Consider using a C# helper function.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:850)
</summary>
</member>
<member name="M:FSComp.SR.ilAddressOfValueHereIsInvalid(System.String)">
<summary>
 This operation involves taking the address of a value &apos;%s&apos; represented using a local variable or other special representation. This is invalid.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:847)
</summary>
</member>
<member name="M:FSComp.SR.ilAddressOfLiteralFieldIsInvalid">
<summary>
 Taking the address of a literal field is invalid
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:846)
</summary>
</member>
<member name="M:FSComp.SR.gotoDefinitionHeader">
<summary>
 This file was automatically generated by a call to Goto Definition
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:936)
</summary>
</member>
<member name="P:FSComp.SR.SwallowResourceText">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:FSComp.SR.forPrefixFlagSpacePlusSetTwice">
<summary>
 Prefix flag (&apos; &apos; or &apos;+&apos;) set twice
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:237)
</summary>
</member>
<member name="M:FSComp.SR.forPrecisionMissingAfterDot">
<summary>
 Precision missing after the &apos;.&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:242)
</summary>
</member>
<member name="M:FSComp.SR.forPositionalSpecifiersNotPermitted">
<summary>
 Positional specifiers are not permitted in format strings
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:234)
</summary>
</member>
<member name="M:FSComp.SR.forMissingFormatSpecifier">
<summary>
 Missing format specifier
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:235)
</summary>
</member>
<member name="M:FSComp.SR.forLIsUnnecessary">
<summary>
 The &apos;l&apos; or &apos;L&apos; in this format specifier is unnecessary except for ML compatibility. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:245)
</summary>
</member>
<member name="M:FSComp.SR.forHashSpecifierIsInvalid">
<summary>
 The # formatting modifier is invalid in F#
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:238)
</summary>
</member>
<member name="M:FSComp.SR.forHIsUnnecessary">
<summary>
 The &apos;h&apos; or &apos;H&apos; in this format specifier is unnecessary. You can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types..
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:246)
</summary>
</member>
<member name="M:FSComp.SR.forFormatDoesntSupportPrecision(System.String)">
<summary>
 &apos;%s&apos; format does not support precision
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:243)
</summary>
</member>
<member name="M:FSComp.SR.forFlagSetTwice(System.String)">
<summary>
 &apos;%s&apos; flag set twice
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:236)
</summary>
</member>
<member name="M:FSComp.SR.forDoesNotSupportZeroFlag(System.String)">
<summary>
 &apos;%s&apos; format does not support &apos;0&apos; flag
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:241)
</summary>
</member>
<member name="M:FSComp.SR.forDoesNotSupportPrefixFlag(System.String,System.String)">
<summary>
 &apos;%s&apos; does not support prefix &apos;%s&apos; flag
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:247)
</summary>
</member>
<member name="M:FSComp.SR.forBadWidth">
<summary>
 Bad width in format specifier
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:240)
</summary>
</member>
<member name="M:FSComp.SR.forBadPrecision">
<summary>
 Bad precision in format specifier
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:239)
</summary>
</member>
<member name="M:FSComp.SR.forBadFormatSpecifierGeneral(System.String)">
<summary>
 Bad format specifier: &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:248)
</summary>
</member>
<member name="M:FSComp.SR.forBadFormatSpecifier">
<summary>
 Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. These format specifiers support ML compatibility. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:244)
</summary>
</member>
<member name="M:FSComp.SR.fieldIsNotAccessible(System.String)">
<summary>
 The record, struct or class field &apos;%s&apos; is not accessible from this code location
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:972)
</summary>
</member>
<member name="M:FSComp.SR.experimentalConstruct">
<summary>
 This construct is experimental
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:974)
</summary>
</member>
<member name="M:FSComp.SR.eventHasNonStandardType(System.String,System.String,System.String)">
<summary>
 The event &apos;%s&apos; has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit %s and %s methods for the event. If this event is declared in F#, make the type of the event an instantiation of either &apos;IDelegateEvent&lt;_&gt;&apos; or &apos;IEvent&lt;_,_&gt;&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:967)
</summary>
</member>
<member name="M:FSComp.SR.elSysEnvExitDidntExit">
<summary>
 System.Environment.Exit did not exit
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:252)
</summary>
</member>
<member name="M:FSComp.SR.elDeprecatedOperator">
<summary>
 The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:253)
</summary>
</member>
<member name="M:FSComp.SR.delegatesNotAllowedToHaveCurriedSignatures">
<summary>
 Delegates are not allowed to have curried signatures
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:977)
</summary>
</member>
<member name="M:FSComp.SR.csTypeParameterCannotBeNullable">
<summary>
 This type parameter cannot be instantiated to &apos;Nullable&apos;. This is a restriction imposed in order to ensure the meaning of &apos;null&apos; in some CLI languages is not confusing when used in conjunction with &apos;Nullable&apos; values.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:349)
</summary>
</member>
<member name="M:FSComp.SR.csTypeNotCompatibleBecauseOfPrintf(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is not compatible with any of the types %s, arising from the use of a printf-style format string
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:352)
</summary>
</member>
<member name="M:FSComp.SR.csTypeIsNotEnumType(System.String)">
<summary>
 The type &apos;%s&apos; is not a CLI enum type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:346)
</summary>
</member>
<member name="M:FSComp.SR.csTypeIsNotDelegateType(System.String)">
<summary>
 The type &apos;%s&apos; is not a CLI delegate type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:348)
</summary>
</member>
<member name="M:FSComp.SR.csTypeInstantiationLengthMismatch">
<summary>
 Type instantiation length mismatch
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:356)
</summary>
</member>
<member name="M:FSComp.SR.csTypeInferenceMaxDepth">
<summary>
 Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:330)
</summary>
</member>
<member name="M:FSComp.SR.csTypeHasNonStandardDelegateType(System.String)">
<summary>
 The type &apos;%s&apos; has a non-standard delegate type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:347)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportOperator(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support any operators named &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:334)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality3(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it is a record, union or struct with one or more structural element types which do not support the &apos;equality&apos; constraint. Either avoid the use of equality with this type, or add the &apos;StructuralEquality&apos; attribute to the type to determine which field type does not support equality
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:345)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality2(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it is a function type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:344)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality1(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it has the &apos;NoEquality&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:343)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportConversion(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support a conversion to the type &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:335)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison3(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint because it is a record, union or struct with one or more structural element types which do not support the &apos;comparison&apos; constraint. Either avoid the use of comparison with this type, or add the &apos;StructuralComparison&apos; attribute to the type to determine which field type does not support comparison
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:342)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison2(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint. For example, it does not support the &apos;System.IComparable&apos; interface
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:341)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison1(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint because it has the &apos;NoComparison&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:340)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotHaveNull(System.String)">
<summary>
 The type &apos;%s&apos; does not have &apos;null&apos; as a proper value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:339)
</summary>
</member>
<member name="M:FSComp.SR.csTypeCannotBeResolvedAtCompileTime(System.String)">
<summary>
 The declared type parameter &apos;%s&apos; cannot be used here since the type parameter cannot be resolved at compile time
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:328)
</summary>
</member>
<member name="M:FSComp.SR.csStructConstraintInconsistent">
<summary>
 The constraints &apos;struct&apos; and &apos;not struct&apos; are inconsistent
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:338)
</summary>
</member>
<member name="M:FSComp.SR.csRequiredSignatureIs(System.String)">
<summary>
 The required signature is %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:368)
</summary>
</member>
<member name="M:FSComp.SR.csOptionalArgumentNotPermittedHere">
<summary>
 Optional arguments not permitted here
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:357)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFound(System.String)">
<summary>
 No overloads match for method &apos;%s&apos;. The available overloads are shown below (or in the Error List window).
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:383)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments3(System.String,System.String,System.Int32,System.String)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments. The named argument &apos;%s&apos; doesn&apos;t correspond to any argument or settable return property for any overload.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:381)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments2(System.String,System.String,System.Int32,System.Int32)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments. Note the call to this member also provides %d named arguments.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:380)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments(System.String,System.String,System.Int32)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:379)
</summary>
</member>
<member name="M:FSComp.SR.csMethodNotFound(System.String)">
<summary>
 Method or object constructor &apos;%s&apos; not found
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:382)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsOverloaded(System.String)">
<summary>
 A unique overload for method &apos;%s&apos; could not be determined based on type information prior to this program point. The available overloads are shown below (or in the Error List window). A type annotation may be needed.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:384)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsNotAnInstanceMethod(System.String)">
<summary>
 %s is not an instance method
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:366)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsNotAStaticMethod(System.String)">
<summary>
 %s is not a static method
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:365)
</summary>
</member>
<member name="M:FSComp.SR.csMethodFoundButIsStatic(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; has a method &apos;%s&apos; (full name &apos;%s&apos;), but the method is static
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:336)
</summary>
</member>
<member name="M:FSComp.SR.csMethodFoundButIsNotStatic(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; has a method &apos;%s&apos; (full name &apos;%s&apos;), but the method is not static
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:337)
</summary>
</member>
<member name="M:FSComp.SR.csMethodExpectsParams">
<summary>
 This method expects a CLI &apos;params&apos; parameter in this position. &apos;params&apos; is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:362)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArityType(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; takes %d type argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:375)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArityNamed(System.String,System.Int32,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s) but is here given %d unnamed and %d named argument(s). The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:373)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArity(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; takes %d argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:374)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch4(System.String,System.Int32,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d additional argument(s). The required signature is &apos;%s&apos;. Some names for missing arguments are %s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:372)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch3(System.String,System.Int32,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s). The required signature is &apos;%s&apos;. Some names for missing arguments are %s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:371)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch2(System.String,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d additional argument(s). The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:370)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch(System.String,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s). The required signature is &apos;%s&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:369)
</summary>
</member>
<member name="M:FSComp.SR.csMemberOverloadArityMismatch(System.String,System.Int32,System.Int32)">
<summary>
 The member or object constructor &apos;%s&apos; does not take %d argument(s). An overload was found taking %d arguments.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:378)
</summary>
</member>
<member name="M:FSComp.SR.csMemberNotAccessible(System.String,System.Int32,System.String,System.Int32)">
<summary>
 The member or object constructor &apos;%s&apos; taking %d arguments are not accessible from this code location. All accessible versions of method &apos;%s&apos; take %d arguments.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:376)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotStatic(System.String)">
<summary>
 %s is not a static member
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:358)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotInstance(System.String)">
<summary>
 %s is not an instance member
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:359)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotAccessible2(System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; is not %s. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:364)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotAccessible(System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; is not %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:363)
</summary>
</member>
<member name="M:FSComp.SR.csMemberHasNoArgumentOrReturnProperty(System.String,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; has no argument or settable return property &apos;%s&apos;. %s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:367)
</summary>
</member>
<member name="M:FSComp.SR.csIndexArgumentMismatch(System.Int32,System.Int32)">
<summary>
 This indexer expects %d arguments but is here given %d
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:332)
</summary>
</member>
<member name="M:FSComp.SR.csIncorrectGenericInstantiation(System.String,System.String,System.Int32)">
<summary>
 Incorrect generic instantiation. No %s member named &apos;%s&apos; takes %d generic arguments.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:377)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresUnmanagedType(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; is an unmanaged type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:351)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresStructType(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; is a CLI or F# struct type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:350)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresReferenceSemantics(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; have reference semantics, but it does not, i.e. it is a struct
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:353)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresPublicDefaultConstructor(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; have a public default constructor
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:355)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresNonAbstract(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; be non-abstract
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:354)
</summary>
</member>
<member name="M:FSComp.SR.csExpectedArguments">
<summary>
 Expected arguments to an instance member
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:331)
</summary>
</member>
<member name="M:FSComp.SR.csExpectTypeWithOperatorButGivenFunction(System.String)">
<summary>
 Expecting a type supporting the operator &apos;%s&apos; but given a function type. You may be missing an argument to a function.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:333)
</summary>
</member>
<member name="M:FSComp.SR.csCodeLessGeneric">
<summary>
 This code is less generic than indicated by its annotations. A unit-of-measure specified using &apos;_&apos; has been determined to be &apos;1&apos;, i.e. dimensionless. Consider making the code generic, or removing the use of &apos;_&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:329)
</summary>
</member>
<member name="M:FSComp.SR.csArgumentTypesDoNotMatch">
<summary>
 The argument types don&apos;t match
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:361)
</summary>
</member>
<member name="M:FSComp.SR.csArgumentLengthMismatch">
<summary>
 Argument length mismatch
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:360)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantSetUnionFields">
<summary>
 Quotations cannot contain expressions that set union case fields
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:315)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantSetExceptionFields">
<summary>
 Quotations cannot contain expressions that set fields in exception values
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:316)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantRequireByref">
<summary>
 Quotations cannot contain expressions that require byref pointers
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:317)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantFetchUnionIndexes">
<summary>
 Quotations cannot contain expressions that fetch union case indexes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:314)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisType">
<summary>
 Quotations cannot contain this kind of type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:322)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisPatternMatch">
<summary>
 Quotations cannot contain this kind of pattern match
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:320)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisConstant">
<summary>
 Quotations cannot contain this kind of constant
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:319)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainStaticFieldRef">
<summary>
 Quotations cannot contain expressions that fetch static fields
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:311)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainObjExprs">
<summary>
 Quotations cannot contain object expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:309)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainLiteralByteArrays">
<summary>
 Quotations cannot contain literal byte arrays
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:323)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainInlineIL">
<summary>
 Quotations cannot contain inline assembly code or pattern matching on arrays
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:312)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainGenericFunctions">
<summary>
 Quotations cannot contain function declarations that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:308)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainGenericExprs">
<summary>
 Quotations cannot contain uses of generic expressions
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:307)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainDescendingForLoops">
<summary>
 Quotations cannot contain descending for loops
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:313)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainArrayPatternMatching">
<summary>
 Quotations cannot contain array pattern matching
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:321)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainAddressOf">
<summary>
 Quotations cannot contain expressions that take the address of a field
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:310)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantCallTraitMembers">
<summary>
 Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:318)
</summary>
</member>
<member name="M:FSComp.SR.crefNoInnerGenericsInQuotations">
<summary>
 Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:324)
</summary>
</member>
<member name="M:FSComp.SR.crefBoundVarUsedInSplice(System.String)">
<summary>
 The variable &apos;%s&apos; is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:306)
</summary>
</member>
<member name="M:FSComp.SR.chkVariableUsedInInvalidWay(System.String)">
<summary>
 The variable &apos;%s&apos; is used in an invalid way
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:261)
</summary>
</member>
<member name="M:FSComp.SR.chkValueWithDefaultValueMustHaveDefaultValue">
<summary>
 The type of a field using the &apos;DefaultValue&apos; attribute must admit default initialization, i.e. have &apos;null&apos; as a proper value or be a struct type whose fields all admit default initialization. You can use &apos;DefaultValue(false)&apos; to disable this check
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:301)
</summary>
</member>
<member name="M:FSComp.SR.chkUnusedValue(System.String)">
<summary>
 The value &apos;%s&apos; is unused
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1087)
</summary>
</member>
<member name="M:FSComp.SR.chkUnusedThisVariable(System.String)">
<summary>
 The recursive object reference &apos;%s&apos; is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1088)
</summary>
</member>
<member name="M:FSComp.SR.chkUnionCaseDefaultAugmentation">
<summary>
 default augmentation of the union case
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:286)
</summary>
</member>
<member name="M:FSComp.SR.chkUnionCaseCompiledForm">
<summary>
 compiled form of the union case
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:285)
</summary>
</member>
<member name="M:FSComp.SR.chkTypeLessAccessibleThanType(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is less accessible than the value, member or type &apos;%s&apos; it is used in
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:262)
</summary>
</member>
<member name="M:FSComp.SR.chkSystemVoidOnlyInTypeof">
<summary>
 &apos;System.Void&apos; can only be used as &apos;typeof&lt;System.Void&gt;&apos; in F#
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:263)
</summary>
</member>
<member name="M:FSComp.SR.chkSplicingOnlyInQuotations">
<summary>
 Expression-splicing operators may only be used within quotations
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:266)
</summary>
</member>
<member name="M:FSComp.SR.chkReturnTypeNoByref">
<summary>
 A method return type would contain byrefs which is not permitted
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:278)
</summary>
</member>
<member name="M:FSComp.SR.chkReflectedDefCantSplice">
<summary>
 [&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator &apos;%%&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:283)
</summary>
</member>
<member name="M:FSComp.SR.chkProtectedOrBaseCalled">
<summary>
 A protected member is called or &apos;base&apos; is being used. This is only allowed in the direct implementation of members since they could escape their object scope.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:257)
</summary>
</member>
<member name="M:FSComp.SR.chkPropertySameNameMethod(System.String)">
<summary>
 Name clash. The property &apos;%s&apos; has the same name as a method in this type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:287)
</summary>
</member>
<member name="M:FSComp.SR.chkPropertySameNameIndexer(System.String)">
<summary>
 The property &apos;%s&apos; has the same name as another property in this type, but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:289)
</summary>
</member>
<member name="M:FSComp.SR.chkObjCtorsCantUseExceptionHandling">
<summary>
 Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as &apos;for x in ...&apos; that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:272)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassSplicing">
<summary>
 First-class uses of the expression-splicing operator are not permitted
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:267)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassRethrow">
<summary>
 First-class uses of the &apos;reraise&apos; function is not permitted
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:269)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassAddressOf">
<summary>
 First-class uses of the address-of operators are not permitted
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:268)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefInTypeAbbrev">
<summary>
 The type abbreviation contains byrefs. This is not permitted by F#.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:302)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAtThisPoint(System.String)">
<summary>
 The byref typed value &apos;%s&apos; cannot be used at this point
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:270)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAsTopValue">
<summary>
 A byref typed value would be stored here. Top-level let-bound byref values are not permitted.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:282)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressStaticFieldAtThisPoint(System.String)">
<summary>
 The address of the static field &apos;%s&apos; cannot be used at this point
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:274)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressOfAtThisPoint(System.String)">
<summary>
 The address of the variable &apos;%s&apos; cannot be used at this point
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:273)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressOfArrayElementAtThisPoint">
<summary>
 The address of an array element cannot be used at this point
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:276)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressFieldAtThisPoint(System.String)">
<summary>
 The address of the field &apos;%s&apos; cannot be used at this point
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:275)
</summary>
</member>
<member name="M:FSComp.SR.chkMutableUsedInInvalidWay(System.String)">
<summary>
 The mutable variable &apos;%s&apos; is used in an invalid way. Mutable variables cannot be captured by closures. Consider eliminating this use of mutation or using a heap-allocated mutable reference cell via &apos;ref&apos; and &apos;!&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:259)
</summary>
</member>
<member name="M:FSComp.SR.chkMultipleGenericInterfaceInstantiations(System.String,System.String)">
<summary>
 This type implements or inherits the same interface at different generic instantiations &apos;%s&apos; and &apos;%s&apos;. This is not permitted in this version of F#.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:300)
</summary>
</member>
<member name="M:FSComp.SR.chkMemberUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; is used in an invalid way. A use of &apos;%s&apos; has been inferred prior to its definition at or near &apos;%s&apos;. This is an invalid forward reference.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:281)
</summary>
</member>
<member name="M:FSComp.SR.chkLimitationsOfBaseKeyword">
<summary>
 &apos;base&apos; values may only be used to make direct calls to the base implementations of overridden members
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:271)
</summary>
</member>
<member name="M:FSComp.SR.chkInvalidCustAttrVal">
<summary>
 Invalid custom attribute value (not a constant or literal)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:279)
</summary>
</member>
<member name="M:FSComp.SR.chkGetterSetterDoNotMatchAbstract(System.String)">
<summary>
 The property &apos;%s&apos; has a getter and a setter that do not match. If one is abstract then the other must be as well.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:288)
</summary>
</member>
<member name="M:FSComp.SR.chkFirstClassFuncNoByref">
<summary>
 The type of a first-class function cannot contain byrefs
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:277)
</summary>
</member>
<member name="M:FSComp.SR.chkErrorUseOfByref">
<summary>
 A type instantiation involves a byref type. This is not permitted by the rules of Common IL.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:264)
</summary>
</member>
<member name="M:FSComp.SR.chkErrorContainsCallToRethrow">
<summary>
 Calls to &apos;reraise&apos; may only occur directly in a handler of a try-with
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:265)
</summary>
</member>
<member name="M:FSComp.SR.chkEntryPointUsage">
<summary>
 A function labeled with the &apos;EntryPointAttribute&apos; attribute must be the last declaration in the last file in the compilation sequence, and can only be used when compiling to a .exe
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:284)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicatePropertyWithSuffix(System.String)">
<summary>
 Duplicate property. The property &apos;%s&apos; has the same name and signature as another property in this type once tuples, functions and/or units of measure are erased.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:297)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateProperty(System.String)">
<summary>
 Duplicate property. The property &apos;%s&apos; has the same name and signature as another property in this type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:296)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodWithSuffix(System.String)">
<summary>
 Duplicate method. The method &apos;%s&apos; has the same name and signature as another method in this type once tuples, functions and/or units of measure are erased.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:293)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodInheritedTypeWithSuffix(System.String)">
<summary>
 Duplicate method. The abstract method &apos;%s&apos; has the same name and signature as an abstract method in an inherited type once tuples, functions and/or units of measure are erased.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:299)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodInheritedType(System.String)">
<summary>
 Duplicate method. The abstract method &apos;%s&apos; has the same name and signature as an abstract method in an inherited type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:298)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodCurried(System.String)">
<summary>
 The method &apos;%s&apos; has curried arguments but has the same name as another method in this type. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:294)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethod(System.String)">
<summary>
 Duplicate method. The method &apos;%s&apos; has the same name and signature as another method in this type.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:292)
</summary>
</member>
<member name="M:FSComp.SR.chkCurriedMethodsCantHaveOutParams">
<summary>
 Methods with curried arguments cannot declare &apos;out&apos;, &apos;ParamArray&apos;, &apos;optional&apos; or &apos;byref&apos; arguments
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:295)
</summary>
</member>
<member name="M:FSComp.SR.chkCantStoreByrefValue">
<summary>
 A type would store a byref typed value. This is not permitted by Common IL.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:290)
</summary>
</member>
<member name="M:FSComp.SR.chkByrefUsedInInvalidWay(System.String)">
<summary>
 The byref-typed variable &apos;%s&apos; is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:258)
</summary>
</member>
<member name="M:FSComp.SR.chkBaseUsedInInvalidWay">
<summary>
 The &apos;base&apos; keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:260)
</summary>
</member>
<member name="M:FSComp.SR.chkAttrHasAllowMultiFalse(System.String)">
<summary>
 The attribute type &apos;%s&apos; has &apos;AllowMultiple=false&apos;. Multiple instances of this attribute cannot be attached to a single language element.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:280)
</summary>
</member>
<member name="M:FSComp.SR.buildUnrecognizedOption(System.String)">
<summary>
 Unrecognized option: &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:60)
</summary>
</member>
<member name="M:FSComp.SR.buildUnknownFileSuffix(System.String)">
<summary>
 ParseInput: unknown file suffix for &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:41)
</summary>
</member>
<member name="M:FSComp.SR.buildUnexpectedTypeArgs(System.String,System.Int32)">
<summary>
 The non-generic type &apos;%s&apos; does not expect any type arguments, but here is given %d type argument(s)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:17)
</summary>
</member>
<member name="M:FSComp.SR.buildSignatureWithoutImplementation(System.String)">
<summary>
 The signature file &apos;%s&apos; does not have a corresponding implementation file. If an implementation file exists then check the &apos;module&apos; and &apos;namespace&apos; declarations in the signature and implementation files match.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:57)
</summary>
</member>
<member name="M:FSComp.SR.buildSignatureAlreadySpecified(System.String)">
<summary>
 A signature for the file or module &apos;%s&apos; has already been specified
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:54)
</summary>
</member>
<member name="M:FSComp.SR.buildSearchDirectoryNotFound(System.String)">
<summary>
 The search directory &apos;%s&apos; could not be found
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:27)
</summary>
</member>
<member name="M:FSComp.SR.buildRequiresCLI2(System.String)">
<summary>
 The file &apos;%s&apos; is a CLI 1.x version of mscorlib. F# requires CLI version 2.0 or greater.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:32)
</summary>
</member>
<member name="M:FSComp.SR.buildProductName(System.String)">
<summary>
 Microsoft (R) F# 2.0 Compiler build %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:21)
</summary>
</member>
<member name="M:FSComp.SR.buildProblemWithFilename(System.String,System.String)">
<summary>
 Problem with filename &apos;%s&apos;: %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:22)
</summary>
</member>
<member name="M:FSComp.SR.buildPdbRequiresDebug">
<summary>
 The &apos;--pdb&apos; option requires the &apos;--debug&apos; option to be used
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:25)
</summary>
</member>
<member name="M:FSComp.SR.buildOptionRequiresParameter(System.String)">
<summary>
 Option requires parameter: %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:42)
</summary>
</member>
<member name="M:FSComp.SR.buildNoInputsSpecified">
<summary>
 No inputs specified
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:23)
</summary>
</member>
<member name="M:FSComp.SR.buildMultipleToplevelModules">
<summary>
 This file contains multiple declarations of the form &apos;module SomeNamespace.SomeModule&apos;. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use &apos;module ModuleName = ...&apos; to define your modules.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:40)
</summary>
</member>
<member name="M:FSComp.SR.buildMultipleReferencesNotAllowed(System.String)">
<summary>
 Multiple references to &apos;%s.dll&apos; are not permitted
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:31)
</summary>
</member>
<member name="M:FSComp.SR.buildMultiFileRequiresNamespaceOrModule">
<summary>
 Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. &apos;namespace SomeNamespace.SubNamespace&apos; or &apos;module SomeNamespace.SomeModule&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:39)
</summary>
</member>
<member name="M:FSComp.SR.buildMscorlibAndReferencedAssemblyMismatch(System.String)">
<summary>
 The referenced or default base CLI library &apos;mscorlib&apos; is binary-incompatible with the referenced library &apos;%s&apos;. Consider recompiling the library or making an explicit reference to a version of this library that matches the CLI version you are using.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:34)
</summary>
</member>
<member name="M:FSComp.SR.buildMscorLibAndFSharpCoreMismatch(System.String)">
<summary>
 The referenced or default base CLI library &apos;mscorlib&apos; is binary-incompatible with the referenced F# core library &apos;%s&apos;. Consider recompiling the library or making an explicit reference to a version of this library that matches the CLI version you are using.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:36)
</summary>
</member>
<member name="M:FSComp.SR.buildMismatchOutputExtension">
<summary>
 The output name extension doesn&apos;t match the options used. If &apos;-a&apos; or &apos;--target:library&apos; is used the output file name must end with &apos;.dll&apos;, if &apos;--target:module&apos; is used the output extension must be &apos;.netmodule&apos;, otherwise &apos;.exe&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:24)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidWarningNumber(System.String)">
<summary>
 Invalid warning number &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:18)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidVersionString(System.String)">
<summary>
 Invalid version string &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:19)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidVersionFile(System.String)">
<summary>
 Invalid version file &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:20)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSourceFileExtension(System.String)">
<summary>
 The file extension of &apos;%s&apos; is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:44)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSearchDirectory(System.String)">
<summary>
 The search directory &apos;%s&apos; is invalid
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:26)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidPrivacy(System.String)">
<summary>
 Unrecognized privacy setting &apos;%s&apos; for managed resource, valid options are &apos;public&apos; and &apos;private&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:30)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidModuleOrNamespaceName">
<summary>
 Invalid module or namespace name
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:61)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashtimeDirective">
<summary>
 Invalid directive. Expected &apos;#time&apos;, &apos;#time \&quot;on\&quot;&apos; or &apos;#time \&quot;off\&quot;&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:52)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashrDirective">
<summary>
 Invalid directive. Expected &apos;#r \&quot;&lt;file-or-assembly&gt;\&quot;&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:50)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashloadDirective">
<summary>
 Invalid directive. Expected &apos;#load \&quot;&lt;file&gt;\&quot; ... \&quot;&lt;file&gt;\&quot;&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:51)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashIDirective">
<summary>
 Invalid directive. Expected &apos;#I \&quot;&lt;path&gt;\&quot;&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:49)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidFilename(System.String)">
<summary>
 &apos;%s&apos; is not a valid filename
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:28)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidAssemblyName(System.String)">
<summary>
 &apos;%s&apos; is not a valid assembly name
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:29)
</summary>
</member>
<member name="M:FSComp.SR.buildImplicitModuleIsNotLegalIdentifier(System.String,System.String)">
<summary>
 The declarations in this file will be placed in an implicit module &apos;%s&apos; based on the file name &apos;%s&apos;. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a &apos;module&apos; or &apos;namespace&apos; declaration at the top of the file.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:38)
</summary>
</member>
<member name="M:FSComp.SR.buildImplementationAlreadyGivenDetail(System.String)">
<summary>
 An implementation of file or module &apos;%s&apos; has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:55)
</summary>
</member>
<member name="M:FSComp.SR.buildImplementationAlreadyGiven(System.String)">
<summary>
 An implementation of the file or module &apos;%s&apos; has already been given
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:56)
</summary>
</member>
<member name="M:FSComp.SR.buildExplicitCoreLibRequiresNoFramework(System.String)">
<summary>
 When mscorlib.dll or FSharp.Core.dll is explicitly referenced the %s option must also be passed
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:62)
</summary>
</member>
<member name="M:FSComp.SR.buildExpectedSigdataFile">
<summary>
 FSharp.Core.sigdata not found alongside FSharp.Core
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:64)
</summary>
</member>
<member name="M:FSComp.SR.buildExpectedFileAlongSideFSharpCore(System.String)">
<summary>
 File &apos;%s&apos; not found alongside FSharp.Core
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:66)
</summary>
</member>
<member name="M:FSComp.SR.buildErrorOpeningBinaryFile(System.String,System.String)">
<summary>
 Error opening binary file &apos;%s&apos;: %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:47)
</summary>
</member>
<member name="M:FSComp.SR.buildDirectivesInModulesAreIgnored">
<summary>
 Directives inside modules are ignored
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:53)
</summary>
</member>
<member name="M:FSComp.SR.buildDifferentVersionMustRecompile(System.String)">
<summary>
 The F#-compiled DLL &apos;%s&apos; needs to be recompiled to be used with this version of F#
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:48)
</summary>
</member>
<member name="M:FSComp.SR.buildDidNotExpectSigdataResource">
<summary>
 Did not expect to find sigdata resource in FSharp.Core.dll
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:63)
</summary>
</member>
<member name="M:FSComp.SR.buildDidNotExpectOptDataResource">
<summary>
 Did not expect to find optdata resource in FSharp.Core.dll
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:65)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotResolveAssemblyRequiredByFile(System.String,System.String)">
<summary>
 Could not resolve assembly &apos;%s&apos; required by &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:46)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotResolveAssembly(System.String)">
<summary>
 Could not resolve assembly &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:45)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotReadVersionInfoFromMscorlib">
<summary>
 Could not read version from mscorlib.dll
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:33)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotFindSourceFile(System.String)">
<summary>
 Source file &apos;%s&apos; could not be found
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:43)
</summary>
</member>
<member name="M:FSComp.SR.buildCompilingExtensionIsForML">
<summary>
 The file extensions &apos;.ml&apos; and &apos;.mli&apos; are for ML compatibility
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1117)
</summary>
</member>
<member name="M:FSComp.SR.buildCannotReadAssembly(System.String)">
<summary>
 Unable to read assembly &apos;%s&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:35)
</summary>
</member>
<member name="M:FSComp.SR.buildAssemblyResolutionFailed">
<summary>
 Assembly resolution failure at or near this location
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:37)
</summary>
</member>
<member name="M:FSComp.SR.buildArgInvalidInt(System.String)">
<summary>
 &apos;%s&apos; is not a valid integer argument
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:58)
</summary>
</member>
<member name="M:FSComp.SR.buildArgInvalidFloat(System.String)">
<summary>
 &apos;%s&apos; is not a valid floating point argument
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:59)
</summary>
</member>
<member name="M:FSComp.SR.augTypeCantHaveRefEqAndStructAttrs">
<summary>
 A type cannot have both the &apos;ReferenceEquality&apos; and &apos;StructuralEquality&apos; or &apos;StructuralComparison&apos; attributes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:223)
</summary>
</member>
<member name="M:FSComp.SR.augStructEqNeedsNoCompOrStructComp">
<summary>
 The &apos;StructuralEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; or &apos;StructuralComparison&apos; attributes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:222)
</summary>
</member>
<member name="M:FSComp.SR.augStructCompNeedsStructEquality">
<summary>
 The &apos;StructuralComparison&apos; attribute must be used in conjunction with the &apos;StructuralEquality&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:221)
</summary>
</member>
<member name="M:FSComp.SR.augRefEqCantHaveObjEquals">
<summary>
 A type with attribute &apos;ReferenceEquality&apos; cannot have an explicit implementation of &apos;Object.Equals(obj)&apos;, &apos;System.IEquatable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralEquatable&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:225)
</summary>
</member>
<member name="M:FSComp.SR.augOnlyCertainTypesCanHaveAttrs">
<summary>
 Only record, union, exception and struct types may be augmented with the &apos;ReferenceEquality&apos;, &apos;StructuralEquality&apos; and &apos;StructuralComparison&apos; attributes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:224)
</summary>
</member>
<member name="M:FSComp.SR.augNoRefEqualsOnStruct">
<summary>
 The &apos;ReferenceEquality&apos; attribute cannot be used on structs. Consider using the &apos;StructuralEquality&apos; attribute instead, or implement an override for &apos;System.Object.Equals(obj)&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:218)
</summary>
</member>
<member name="M:FSComp.SR.augNoEqualityNeedsNoComparison">
<summary>
 The &apos;NoEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; attribute
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:220)
</summary>
</member>
<member name="M:FSComp.SR.augNoEqNeedsNoObjEquals">
<summary>
 A type with attribute &apos;NoEquality&apos; should not usually have an explicit implementation of &apos;Object.Equals(obj)&apos;. Disable this warning if this is intentional for interoperability purposes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:228)
</summary>
</member>
<member name="M:FSComp.SR.augNoCompCantImpIComp">
<summary>
 A type with attribute &apos;NoComparison&apos; should not usually have an explicit implementation of &apos;System.IComparable&apos;, &apos;System.IComparable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralComparable&apos;. Disable this warning if this is intentional for interoperability purposes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:229)
</summary>
</member>
<member name="M:FSComp.SR.augInvalidAttrs">
<summary>
 This type uses an invalid mix of the attributes &apos;NoEquality&apos;, &apos;ReferenceEquality&apos;, &apos;StructuralEquality&apos;, &apos;NoComparison&apos; and &apos;StructuralComparison&apos; attributes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:219)
</summary>
</member>
<member name="M:FSComp.SR.augCustomEqNeedsObjEquals">
<summary>
 A type with attribute &apos;CustomEquality&apos; must have an explicit implementation of at least one of &apos;Object.Equals(obj)&apos;, &apos;System.IEquatable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralEquatable&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:226)
</summary>
</member>
<member name="M:FSComp.SR.augCustomEqNeedsNoCompOrCustomComp">
<summary>
 The &apos;CustomEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; or &apos;CustomComparison&apos; attributes
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:230)
</summary>
</member>
<member name="M:FSComp.SR.augCustomCompareNeedsIComp">
<summary>
 A type with attribute &apos;CustomComparison&apos; must have an explicit implementation of at least one of &apos;System.IComparable&apos; or &apos;System.Collections.IStructuralComparable&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:227)
</summary>
</member>
<member name="M:FSComp.SR.astParseEmbeddedILTypeError">
<summary>
 Error while parsing embedded IL type
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:212)
</summary>
</member>
<member name="M:FSComp.SR.astParseEmbeddedILError">
<summary>
 Error while parsing embedded IL
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:211)
</summary>
</member>
<member name="M:FSComp.SR.astInvalidExprLeftHandOfAssignment">
<summary>
 Invalid expression on left of assignment
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:214)
</summary>
</member>
<member name="M:FSComp.SR.astDeprecatedIndexerNotation">
<summary>
 This indexer notation has been removed from the F# language
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:213)
</summary>
</member>
<member name="M:FSComp.SR.assemblyResolutionNetFramework">
<summary>
 .NET Framework
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:960)
</summary>
</member>
<member name="M:FSComp.SR.assemblyResolutionGAC">
<summary>
 Global Assembly Cache
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:961)
</summary>
</member>
<member name="M:FSComp.SR.assemblyResolutionFoundByAssemblyFoldersKey">
<summary>
 Found by AssemblyFolders registry key
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:958)
</summary>
</member>
<member name="M:FSComp.SR.assemblyResolutionFoundByAssemblyFoldersExKey">
<summary>
 Found by AssemblyFoldersEx registry key
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:959)
</summary>
</member>
<member name="M:FSComp.SR.activePatternIdentIsNotFunctionTyped(System.String)">
<summary>
 Active pattern &apos;%s&apos; is not a function
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1119)
</summary>
</member>
<member name="M:FSComp.SR.activePatternChoiceHasFreeTypars(System.String)">
<summary>
 Active pattern &apos;%s&apos; has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. &apos;let (|A|B|) (x:int) = A x&apos;. This can be fixed with a type constraint, e.g. &apos;let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x&apos;
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:1120)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityVirtualsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is virtual and the other isn&apos;t
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:120)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityTypesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe types differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:112)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityStaticsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is static and the other isn&apos;t
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:119)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityStaticButInstance(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:125)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityParameterCountsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe respective type parameter counts differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:111)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOverridesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is marked as an override and the other isn&apos;t
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:123)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOneIsTypeFunction(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:110)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOneIsConstructor(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a constructor/property and the other is not
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:124)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:104)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityLiteralConstantValuesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe literal constant values and/or attributes differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:109)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityInstanceButStatic(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:126)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityInlineFlagsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe inline flags differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:108)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityGenericParametersDiffer(System.String,System.String,System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe number of generic parameters in the signature and implementation differ (the signature declares %s but the implementation declares %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:115)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityGenericParametersAreDifferentKinds(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:116)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityFinalsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is final and the other isn&apos;t
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:122)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityExtensionsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is an extension member and the other is not
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:113)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityDotNetNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe CLI member names differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:118)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityDisplayNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe display names differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:106)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityCompiledNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled names differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:105)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAttributesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe mutability attributes differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:103)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityArityNotInferred(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nAn arity was not inferred for this value
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:114)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAritiesDiffer(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe arities in the signature and implementation differ. The signature specifies that &apos;%s&apos; is function definition or lambda expression accepting at least %s argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval %s: int -&gt; (int -&gt; int)\ninstead of\n\tval %s: int -&gt; int -&gt; int.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:117)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAccessibilityMore(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe accessibility specified in the signature is more than that specified in the implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:107)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAbstractsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is abstract and the other isn&apos;t
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:121)
</summary>
</member>
<member name="M:FSComp.SR.RunStartupValidation">
<summary>
 Call this method once to validate that all known resources are valid; throws if not
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButTypesOfFieldsDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe types of the fields differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:161)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButNamesDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:159)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButDataFieldsDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe respective number of data fields differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:160)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButAccessibilityDiffers(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:162)
</summary>
</member>
<member name="M:FSComp.SR.InvalidRecursiveReferenceToAbstractSlot">
<summary>
 Invalid recursive reference to an abstract slot
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:966)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedTypesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe types differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:168)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedStaticsDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;static&apos; modifiers differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:165)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedNamesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:163)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedMutablesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;mutable&apos; modifiers differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:166)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedLiteralsDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;literal&apos; modifiers differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:167)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedAccessibilitiesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:164)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleSignaturesDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:187)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleHiddenBySignature(System.String,System.String)">
<summary>
 The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:184)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldOrderDiffers(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:191)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldInSigButNotImpl(System.String,System.String,System.String)">
<summary>
 The exception definitions are not compatible because the field &apos;%s&apos; was required by the signature but was not specified by the implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:189)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldInImplButNotSig(System.String,System.String,System.String)">
<summary>
 The exception definitions are not compatible because the field &apos;%s&apos; was present in the implementation but not in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:190)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleExceptionDeclarationsDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:188)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleDotNetRepresentationsDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:185)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleAbbreviationHiddenBySignature(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:186)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the types have different base types
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:139)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypeIsHidden(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because a type representation is being hidden by a signature
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:145)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the types are of different kinds
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:146)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:134)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureSaysNull(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:133)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:138)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature defines the %s &apos;%s&apos; but the implementation does not (or does, but not in the same order)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:141)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature declares a %s while the implementation declares a %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:155)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:158)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the representations differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:148)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the respective type parameter counts differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:128)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleNumbersDiffer(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the number of %ss differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:140)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleNamesDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the names differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:127)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleMissingInterface(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature requires that the type supports the interface %s but the interface has not been implemented
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:130)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSealed(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:135)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:132)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSaysNull(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:131)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:136)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:137)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplDefinesStruct(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:143)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation defines the %s &apos;%s&apos; but the signature does not (or does, but not in the same order)
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:142)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleILDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the IL representations differ
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:147)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldWasPresent(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the field %s was present in the implementation but not in the signature
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:149)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the field %s was required by the signature but was not specified by the implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:151)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:150)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the field %s was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled &apos;private&apos; or &apos;internal&apos;.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:152)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:144)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:129)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the abstract member &apos;%s&apos; was present in the implementation but not in the signature
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:154)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the abstract member &apos;%s&apos; was required by the signature but was not specified by the implementation
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:153)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the abbreviations differ: %s versus %s
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:156)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.
 (Originally from C:\fsharp\staging\src\fsharp\FSComp.txt:157)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Internal.Utilities.FSharpEnvironment.Option.ofString(System.String)">
<summary>
 Convert string into Option string where null and String.Empty result in None
</summary>
</member>
<member name="T:Internal.Utilities.FSharpEnvironment.Option">

</member>
<member name="T:Internal.Utilities.FSharpEnvironment">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpAssembly.ReflectionAssembly">
<summary>
 Get the System.Reflection.Assembly object for the assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpAssembly.QualifiedName">
<summary>
 Holds the full qualified assembly name
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpAssembly.FSharpLibrary">
<summary>
 Get the object representing the F# core library (FSharp.Core.dll) for the running program
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpAssembly.Entities">
<summary>
 A handle to the full specification of the contents of the module contained in this Assembly 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpAssembly.CodeLocation">
<summary>
 A hint as to where does the code for the CCU live (e.g what was the tcConfig.implicitIncludeDir at compilation time for this DLL?) 
</summary>
</member>
<member name="M:Microsoft.FSharp.Metadata.FSharpAssembly.GetEntity(System.String)">
<summary>
 Return the System.Reflection.Assembly object for the assembly
</summary>
</member>
<member name="M:Microsoft.FSharp.Metadata.FSharpAssembly.FromFile(System.String)">
<summary>
 This is one way of starting the loading process off. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Metadata.FSharpAssembly.FromAssembly(System.Reflection.Assembly)">
<summary>
 This is one way of starting the loading process off. Dependencies are automatically
 resolved by calling System.Reflection.Assembly.Load.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.XmlDocSig">
<summary>
 Get the XML documentation signature for the entity
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.UsesPrefixDisplay">
<summary>
 Indicates the type prefers the &quot;tycon&lt;a,b&gt;&quot; syntax for display etc. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.UnionCases">
<summary>
 Get the cases of a discriminated union
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.RepresentationAccessibility">
<summary>
 Get the declared accessibility of the representation, not taking signatures into account 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.ReflectionType">
<summary>
 Get the System.Type for the type

 Raises InvalidOperationException if the type is an abbreviation or has an assembly code representation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.ReflectionAssembly">
<summary>
 Get the System.Reflection.Assembly for the type

 May raise an exception if an assembly load fails
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.RecordFields">
<summary>
 Get the fields of the class, struct or enum 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.QualifiedName">
<summary>
 Get the fully qualified name of the type or module
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.Namespace">
<summary>
 Get the namespace containing the type or module, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.MembersOrValues">
<summary>
 Properties, methods etc. with implementations, also values in a module
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.LogicalName">
<summary>
 Get the name of the type or module, possibly with `n mangling  
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.IsValueType">
<summary>
 Indicates the entity is a struct or enum
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.IsUnion">
<summary>
 Indicates the entity is union type
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.IsRecord">
<summary>
 Indicates the entity is record type
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.IsModule">
<summary>
 Indicates the entity is an F# module definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.IsMeasure">
<summary>
 Indicates the entity is a measure definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.IsExternal">
<summary>
 If true, then this is a reference to something in some .NET assembly from another .NET language
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.IsExceptionDeclaration">
<summary>
 Indicates an F# exception declaration
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.IsAbbreviation">
<summary>
 Indicates the entity is a measure, type or exception abbreviation
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.Implements">
<summary>
 Interface implementations - boolean indicates compiler-generated 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.HasFSharpModuleSuffix">
<summary>
 Indicates that a module is compiled to a class with the given mangled name. The mangling is reversed during lookup 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.HasAssemblyCodeRepresentation">
<summary>
 Indicates the type is implemented through a mapping to IL assembly code. THis is only
 true for types in FSharp.Core.dll
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.GenericParameters">
<summary>
 Get the generic parameters, possibly including unit-of-measure parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.DisplayName">
<summary>
 Get the name of the type or module as displayed in F# code
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.DeclaringEntity">
<summary>
 Get the entity containing the type or module, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.DeclarationLocation">
<summary>
 Get the declaration location for the type constructor 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.CompiledName">
<summary>
 Get the compiled name of the type or module, possibly with `n mangling. This is identical to LogicalName
 unless the CompiledName attribute is used.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.BaseType">
<summary>
 Base type, if any 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.Attributes">
<summary>
 Get the declared attributes for the type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpEntity.Accessibility">
<summary>
 Get the declared accessibility of the type
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Metadata.FSharpEntity.FromType(System.Type)">
<summary>
 Return the FSharpEntity corresponding to a .NET type
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.FSharpEntity">
<summary>
 Represents an F# type or module
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameter.XmlDoc">
<summary>
 Get the documentation for the type parameter. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameter.Name">
<summary>
 Get the name of the generic parameter 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameter.IsSolveAtCompileTime">
<summary>
 Indicates if this is a statically resolved type variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameter.IsMeasure">
<summary>
 Indicates if this is a measure variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameter.DeclarationLocation">
<summary>
 Get the range of the generic parameter 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameter.Constraints">
<summary>
 Get the declared or inferred constraints for the type parameter
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameter.Attributes">
<summary>
 Get the declared attributes of the type parameter. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsUnmanagedConstraint">
<summary>
 Indicates a constraint that a type is an unmanaged type
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsSupportsNullConstraint">
<summary>
 Indicates a constraint that a type has a &apos;null&apos; value 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsSimpleChoiceConstraint">
<summary>
 Indicates a constraint that a type is a simple choice between one of the given ground types. Used by printf format strings.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsRequiresDefaultConstructorConstraint">
<summary>
 Indicates a constraint that a type has a parameterless constructor 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsReferenceTypeConstraint">
<summary>
 Indicates a constraint that a type is a reference type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsNonNullableValueTypeConstraint">
<summary>
 Indicates a constraint that a type is a non-Nullable value type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsMemberConstraint">
<summary>
 Indicates a constraint that a type has a member with the given signature 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsEqualityConstraint">
<summary>
 Indicates a constraint that a type supports F# generic equality
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsEnumConstraint">
<summary>
 Indicates a constraint that a type is an enum with the given underlying 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsDelegateConstraint">
<summary>
 Indicates a constraint that a type is a delegate from the given tuple of args to the given return type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsDefaultsToConstraint">
<summary>
 Indicates a default value for an inference type variable should it be netiher generalized nor solved 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsComparisonConstraint">
<summary>
 Indicates a constraint that a type supports F# generic comparison
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpGenericParameterConstraint.IsCoercesToConstraint">
<summary>
 Indicates a constraint that a type is a subtype of the given type 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Microsoft.FSharp.Metadata.FSharpInlineAnnotation.AlwaysInline">
<summary>
 Indictes the value is inlined but the code for the function still exists, e.g. to satisfy interfaces on objects, but that it is also always inlined 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.XmlDocSig">
<summary>
 XML documentation signature for the value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.Type">
<summary>
 Get the full type of the member or value when used as a first class value
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.ReflectionMemberInfo">
<summary>
 Get the reflection object for this member
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.LogicalName">
<summary>
 Get the logical name of the member
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.LogicalEnclosingEntity">
<summary>
 Get the logical enclosing entity, which for an extension member is type being extended
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsTypeFunction">
<summary>
 Indicates if this is an F# type function
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsSetterMethod">
<summary>
 Indicates if this is a setter method for a property
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsMutable">
<summary>
 Indicates if this is a mutable value
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsModuleValueOrMember">
<summary>
 Indicates if this is a module or member value
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsMember">
<summary>
 Indicates if this is a member, including extension members?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsInstanceMember">
<summary>
 Indicates if this is an instance member, when seen from F#?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsImplicitConstructor">
<summary>
 Indicates if this is an implicit constructor?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsGetterMethod">
<summary>
 Indicates if this is a getter method for a property
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsExtensionMember">
<summary>
 Indicates if this is an extension member?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsDispatchSlot">
<summary>
 Indicates if this is an abstract member?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsCompilerGenerated">
<summary>
 Indicates if this is a compiler generated value
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.IsActivePattern">
<summary>
 Indicates if this value or member is an F# active pattern
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.InlineAnnotation">
<summary>
 Get a result indicating if this is a must-inline value
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.GenericParameters">
<summary>
 Get the typars of the member or value
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.DisplayName">
<summary>
 Get the name as presented in F# error messages and documentation
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.DeclarationLocation">
<summary>
 Get the declaration location of the member or value
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.CompiledName">
<summary>
 Get the member name in compiled code
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.Attributes">
<summary>
 Custom attributes attached to the value. These contain references to other values (i.e. constructors in types). Mutable to fixup  
 these value references after copying a colelction of values. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpMemberOrVal.Accessibility">
<summary>
 How visible is this? 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.XmlDocSig">
<summary>
 Get the XML documentation signature for the field 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.Type">
<summary>
 Get the type of the field, w.r.t. the generic parameters of the enclosing type constructor 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.PropertyAttributes">
<summary>
 Get the attributes attached to generated property 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.Name">
<summary>
 Get the name of the field 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.IsStatic">
<summary>
 Indicates a static field 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.IsMutable">
<summary>
 Is the field declared in F#? 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.IsCompilerGenerated">
<summary>
 Indicates a compiler generated field, not visible to Intellisense or name resolution 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.FieldAttributes">
<summary>
 Get the attributes attached to generated field 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.DeclarationLocation">
<summary>
 Get the declaration location of the field 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpRecordField.Accessibility">
<summary>
  Indicates the declared visibility of the field, not taking signatures into account 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpType.NamedEntity">
<summary>
 Get the named entity for a type constructed using a named entity
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpType.IsTuple">
<summary>
 Indicates the type is a tuple type. The GenericArguments property returns the elements of the tuple type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpType.IsNamed">
<summary>
 Indicates the type is constructed using a named entity
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpType.IsGenericParameter">
<summary>
 Indicates the type is a variable type, whether declared, generalized or an inference type parameter  
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpType.IsFunction">
<summary>
 Indicates the type is a function type. The GenericArguments property returns the domain and range of the function type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpType.GenericParameterIndex">
<summary>
 Get the index for a generic parameter type
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpType.GenericParameter">
<summary>
 Get the generic parameter data for a generic parameter type
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpType.GenericArguments">
<summary>
 Get the generic arguments for a tuple type, a function type or a type constructed using a named entity
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpUnionCase.XmlDocSig">
<summary>
 Get the XML documentation signature for the case 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpUnionCase.ReturnType">
<summary>
 Get type constructed by the case. Normally exactly the type of the enclosing type, sometimes an abbreviation of it 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpUnionCase.Name">
<summary>
 Get the name of the case 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpUnionCase.Fields">
<summary>
 Get the data carried by the case. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpUnionCase.DeclarationLocation">
<summary>
 Get the range of the name of the case 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpUnionCase.CompiledName">
<summary>
 Gete the name of the case in generated IL code 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpUnionCase.Attributes">
<summary>
 Get the attributes for the case, attached to the generated static method to make instances of the case 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.FSharpUnionCase.Accessibility">
<summary>
  Indicates the declared visibility of the union constructor, not taking signatures into account 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.QueueList`1.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Note this operation is O(n) anyway, so executing lastElements() here is OK
</summary>
</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.QueueList`1.AppendOne(`0)">
<summary>
 Note this operation is O(1), unless a push happens, which is rare 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.QueueList`1">
<summary>
 Iterable functional collection with O(1) append-1 time. Useful for data structures where elements get added at the
 end but the collection must occadionally be iterated. Iteration is slower and may allocate because 
 a suffix of elements is stored in reverse order.

 The type doesn&apos;t support structural hashing or comparison.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.TypeDefsMap">
<summary>
 keyed first on namespace then on type name.  The namespace is often a unique key for a given type map.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.ILFieldDef.Offset">
<summary>
 The explicit offset in bytes when explicit layout is used.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.MethodDefMap">
<summary>
 Index table by name and arity. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.ILTypeSpec.tspecInst">
<summary>
 The type instantiation if the type is generic
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.ILArgumentConvention">
<summary>
 Calling conventions.  These are used in method pointer types.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.ILAssemblyRef">
<summary>
 Global state: table of all assembly references keyed by AssemblyRefData
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.LazyOrderedMultiMap`2">
<summary>
 This is used to store event, property and field maps.

 Review: this is not such a great data structure.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.memoize_namespace_tab">
<summary>
 Global State. All namespace splits
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.lazyMap``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Metadata.Reader.Internal.Prelude.PPLazy{``0})">
<summary>
 A little ugly, but the idea is that if a data structure does not 
 contain lazy values then we don&apos;t add laziness.  So if the thing to map  
 is already evaluated then immediately apply the function.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL.SHA1">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.AbstractIL.IL">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Env">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.FlatListModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Pickle.PickledDataWithReferences`1.FixupThunks">
<summary>
 The assumptions that need to be fixed up
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Pickle.PickledDataWithReferences`1.RawData">
<summary>
 The data that uses a collection of CcuThunks internally
</summary>
</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.Pickle.PickledDataWithReferences`1.OptionalFixup(Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuThunk}})">
<summary>
 Like Fixup but loader may return None, in which case there is no fixup.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Pickle">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.PPLazy`1.funcOrException@40">
<summary>
 This field holds either the function to run or a PPLazyFailure object recording the exception raised 
 from running the function. It is null if the thunk has been evaluated successfully.
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.PPLazy`1.value@35">
<summary>
 This field holds the result of a successful computation. It&apos;s initial value is Unchecked.defaultof
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.Bytestream">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.NameMultiMapModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.MultiMapModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.NameMapModule">

</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.ListAssoc.containsKey``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 Treat a list of key-value pairs as a lookup collection.
 This function returns true if two keys are the same according to the predicate
 function passed in.
</summary>
</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.ListAssoc.find``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``1,``2}})">
<summary>
 Treat a list of key-value pairs as a lookup collection.
 This function looks up a value based on a match from the supplied
 predicate function.
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.ListAssoc">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.ListSet">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Prelude.String">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Prelude">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.PrettyNaming.tryChopPropertyName(System.String)">
<summary>
 Try to chop &quot;get_&quot; or &quot;set_&quot; from a string
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.PrettyNaming">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.QueueListModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CompiledTypeRepr">
<summary>
 Specifies the compiled representations of type and exception definitions.  
 Computed and cached by later phases (never computed type checking).  Cached at 
 type and exception definitions. Not pickled. Cache an optional ILType object for 
 non-generic types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ObjExprMethod">
<summary>
 A representation of a method in an object expression. 
 Note: Methods associated with types are represented as val declarations
 Note: We should probably use val_specs for object expressions, as then the treatment of members 
 in object expressions could be more unified with the treatment of members in types 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValUseFlag.VSlotDirectCall">
<summary>
 A call to a base method, e.g. &apos;base.OnPaint(args)&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValUseFlag.CtorValUsedAsSelfInit">
<summary>
 A call to a constructor, e.g. &apos;new C() = new C(3)&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValUseFlag.CtorValUsedAsSuperInit">
<summary>
 A call to a constructor, e.g. &apos;inherit C()&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValUseFlag.NormalValUse">
<summary>
 A normal use of a value
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValUseFlag.PossibleConstrainedCall">
<summary>
 Indicates a use of a value represents a call to a method that may require
 a .NET 2.0 constrained call. A constrained call is only used for calls where 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.SequentialOpKind.ThenDoSeq">
<summary>
 let res = a in b;res 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.SequentialOpKind.NormalSeq">
<summary>
 a ; b 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.LValueOperation.LByrefSet">
<summary>
 In C syntax this is: *localv_ptr = e   
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.LValueOperation.LSet">
<summary>
 In C syntax this is:  localv = e     , note == *(&amp;localv) = e == LGetAddr; LByrefSet
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.LValueOperation.LByrefGet">
<summary>
 In C syntax this is: *localv_ptr        
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.LValueOperation.LGetAddr">
<summary>
 In C syntax this is: &amp;localv            
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ForLoopStyle.CSharpForLoopUp">
<summary>
 Evaluate start once and end multiple times, loop up
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ForLoopStyle.FSharpForLoopDown">
<summary>
 Evaluate start and end once, loop down
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ForLoopStyle.FSharpForLoopUp">
<summary>
 Evaluate start and end once, loop up
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_ilcall">
<summary>
 IL method calls 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_lval_op">
<summary>
 Operation nodes represnting C-style operations on byrefs and mutable vals (l-values) 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_trait_call">
<summary>
 Pseudo method calls. This is used for overloaded operations like op_Addition. 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_reraise">
<summary>
 Represents a &quot;rethrow&quot; operation. May not be rebound, or used outside of try-finally, expecting a unit argument 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_coerce">
<summary>
 Conversion node, compiled via type-directed translation or to box/unbox 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_get_ref_lval">
<summary>
 generate a ldflda on an &apos;a ref. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_asm">
<summary>
 IL assembly code - type list are the types pushed on the stack 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_tuple_field_get">
<summary>
 An operation representing a field-get from an F# tuple value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_exnconstr_field_set">
<summary>
 An operation representing a field-set on an F# exception value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_exnconstr_field_get">
<summary>
 An operation representing a field-get from an F# exception value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_ucase_field_set">
<summary>
 An operation representing a field-get from a union value. THe value is not assumed to have been proven to be of the corresponding union case.
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_ucase_field_get">
<summary>
 An operation representing a field-get from a union value, where that value has been proven to be of the corresponding union case.
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_ucase_proof">
<summary>
 An operation representing a coercion that proves a union value is of a particular union case. THis is not a test, its
 simply added proof to enable us to generate verifiable code for field access on union types
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_ucase_tag_get">
<summary>
 An operation representing getting an integer tag for a union value representing the union case number
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_field_get_addr">
<summary>
 An operation representing getting the address of a record field
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_rfield_get">
<summary>
 An operation representing getting a record field
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_rfield_set">
<summary>
 An operation representing setting a record field
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_recd">
<summary>
 Construct a record or object-model value. The ValRef is for self-referential class constructors, otherwise 
 it indicates that we&apos;re in a constructor and the purpose of the expression is to 
 fill in the fields of a pre-created but uninitialized object, and to assign the initialized 
 version of the object into the optional mutable cell pointed to be the given value. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_try_finally">
<summary>
 An operation representing a lambda-encoded try/finally
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_try_catch">
<summary>
 An operation representing a lambda-encoded try/catch
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_for">
<summary>
 An operation representing a lambda-encoded for loop
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_while">
<summary>
 An operation representing a lambda-encoded while loop. The special while loop marker is used to mark compilations of &apos;foreach&apos; expressions
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_bytes">
<summary>
 Constant bytes, but a new mutable blob is generated each time the construct is executed 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_array">
<summary>
 An operation representing the creation of an array value
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_tuple">
<summary>
 An operation representing the creation of a tuple value
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_exnconstr">
<summary>
 An operation representing the creation of an exception value using an F# exception declaration
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExprOpSpec.TOp_ucase">
<summary>
 An operation representing the creation of a union value of the particular union case
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecordConstructionInfo.RecdExpr">
<summary>
 Normal record construction 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecordConstructionInfo.RecdExprIsObjInit">
<summary>
 We&apos;re in a constructor. The purpose of the record expression is to 
 fill in the fields of a pre-created but uninitialized object 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecordConstructionInfo">
<summary>
 This ModuleOrNamespace that represents the compilation of a module as a class. 
 The same set of tycons etc. are bound in the ModuleOrNamespace as in the ModuleOrNamespaceExpr
 This is the body of the module/namespace 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceBinding">
<summary>
 A named module-or-namespace-fragment definition 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceExpr.TMDefRec">
<summary>
 Indicates the module fragment is a &apos;rec&apos; definition of types, values and modules
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceExpr.TMDefDo">
<summary>
 Indicates the module fragment is an evaluation of expression for side-effects
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceExpr.TMDefLet">
<summary>
 Indicates the module fragment is a &apos;let&apos; definition 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceExpr.TMDefs">
<summary>
 Indicates the module fragment is made of several module fragments in succession 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceExpr.TMAbstract">
<summary>
 Indicates the module is a module with a signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceExpr">
<summary>
 The module_typ is a binder. However it is not used in the ModuleOrNamespaceExpr: it is only referenced from the &apos;outside&apos; 
 The contents of a module-or-namespace-fragment definition 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceExprWithSig">
<summary>
 A type for a module-or-namespace-fragment and the actual definition of the module-or-namespace-fragment
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_link">
<summary>
 Typechecking residue: A TExpr_link occurs for every use of a recursively bound variable. While type-checking 
 the recursive bindings a dummy expression is stored in the mutable reference cell. 
 After type checking the bindings this is replaced by a use of the variable, perhaps at an 
 appropriate type instantiation. These are immediately eliminated on subsequent rewrites. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_tchoose">
<summary>
 Typechecking residue: Indicates a free choice of typars that arises due to 
 minimization of polymorphism at let-rec bindings.  These are 
 resolved to a concrete instantiation on subsequent rewrites. 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_op">
<summary>
 An intrinsic applied to some (strictly evaluated) arguments 
 A few of intrinsics (TOp_try, TOp_while, TOp_for) expect arguments kept in a normal form involving lambdas 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_static_optimization">
<summary>
 If we statically know some infomation then in many cases we can use a more optimized expression 
 This is primarily used by terms in the standard library, particularly those implementing overloaded 
 operators. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_match">
<summary>
 Matches are a more complicated form of &quot;let&quot; with multiple possible destinations 
 and possibly multiple ways to get to each destination.  
 The first mark is that of the expression being matched, which is used 
 as the mark for all the decision making and binding that happens during the match. 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_let">
<summary>
 Bind a value. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_letrec">
<summary>
 Bind a recursive set of values. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_app">
<summary>
 Applications combine type and term applications, and are normalized so 
 that sequential applications are combined, so &quot;(f x y)&quot; becomes &quot;f [[x];[y]]&quot;. 
 The type attached to the function is the formal function type, used to ensure we don&apos;t build application 
 nodes that over-apply when instantiating at function types. 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_lambda">
<summary>
 Lambda expressions. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_seq">
<summary>
 Sequence expressions, used for &quot;a;b&quot;, &quot;let a = e in b;a&quot; and &quot;a then b&quot; (the last an OO constructor). 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_val">
<summary>
 Reference a value. The flag is only relevant if the value is an object model member 
 and indicates base calls and special uses of object constructors. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr.TExpr_const">
<summary>
 A constant expression. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.expr">
<summary>
 The big type of expressions.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TopTyparInfo">
<summary>
 The extra metadata stored about typars for top-level definitions. Any information here is propagated from signature through
 to the compiled code.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TopArgInfo">
<summary>
 The extra metadata stored about typars for top-level definitions. Any information here is propagated from signature through
 to the compiled code.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTreeTarget">
<summary>
 A target of a decision tree. Can be thought of as a little function, though is compiled as a local block. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTreeDiscriminator.TTest_query">
<summary>
 Run the active pattern and bind a successful result to the (one) variable in the remaining tree 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTreeDiscriminator.TTest_isinst">
<summary>
 Test if the input to a decision tree is an instance of the given type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTreeDiscriminator.TTest_isnull">
<summary>
 Test if the input to a decision tree is null 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTreeDiscriminator.TTest_const">
<summary>
 Test if the input to a decision tree is the given constant value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTreeDiscriminator.TTest_array_length">
<summary>
 Test if the input to a decision tree is an array of the given length 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTreeDiscriminator.TTest_unionconstr">
<summary>
 Test if the input to a decision tree matches the given constructor 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTree.TDBind">
<summary>
 Bind the given value throught the remaining cases of the dtree. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTree.TDSuccess">
<summary>
 Indicates the decision tree has terminated with success, calling the given target with the given parameters 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTree.TDSwitch">
<summary>
 Indicates a decision point in a decision tree. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.DecisionTree">
<summary>
 Decision trees. Pattern matching has been compiled down to
 a decision tree by this point.  The right-hand-sides (actions) of
 the decision tree are labelled by integers that are unique for that
 particular tree.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Constant">
<summary>
 Constants in expressions
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.AttribNamedArg">
<summary>
 AttribNamedArg(name,type,isField,value)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.AttribExpr">
<summary>
 We keep both source expression and evaluated expression around to help intellisense and signature printing
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Attrib">
<summary>
 Attrib(kind,unnamedArgs,propVal,appliedToAGetterOrSetter,range)
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.AttribKind.FSAttrib">
<summary>
 Indicates an attribute refers to a type defined in an imported F# assembly 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.AttribKind.ILAttrib">
<summary>
 Indicates an attribute refers to a type defined in an imported .NET assembly 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuResolutionResult">
<summary>
 The result of attempting to resolve an assembly name to a full ccu.
 UnresolvedCcu will contain the name of the assembly that could not be resolved.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuThunk.EnsureDerefable(System.String[])">
<summary>
 Ensure the ccu is derefable in advance. Supply a path to attach to any resulting error message.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuThunk">
<summary>
 A relinkable handle to the contents of a compilation unit. Relinking is performed by mutation.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuData.ccu_memberSignatureEquality">
<summary>
 A helper function used to link method signatures using type equality. This is effectively a forward call to the type equality 
 logic in tastops.fs
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuData.ccu_contents">
<summary>
 A handle to the full specification of the contents of the module contained in this ccu
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuData.ccu_usesQuotations">
<summary>
 Indicates that this DLL uses quotation literals somewhere. This is used to implement a restriction on static linking
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuData.ccu_fsharp">
<summary>
 Indicates that this DLL was compiled using the F# compiler 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuData.ccu_code_dir">
<summary>
 A hint as to where does the code for the CCU live (e.g what was the tcConfig.implicitIncludeDir at compilation time for this DLL?) 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuData.ccu_qname">
<summary>
 The fully qualified assembly reference string to refer to this assembly. This is persisted in quotations 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuData.ccu_stamp">
<summary>
 A unique stamp for this DLL 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuData.ccu_scoref">
<summary>
 Holds the data indicating how this assembly/module is referenced from the code being compiled. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuData.ccu_filename">
<summary>
 Holds the filename for the DLL, if any 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.typ.TType_var">
<summary>
 Indicates the type is a variable type, whether declared, generalized or an inference type parameter  
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.typ.TType_ucase">
<summary>
 Indicates the type is a non-F#-visible type representing a &quot;proof&quot; that a union value belongs to a particular union case
 These types are not user-visible and will never appear as an inferred type. They are the types given to
 the temporaries arising out of pattern matching on union values.
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.typ.TType_fun">
<summary>
 Indicates the type is a function type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.typ.TType_tuple">
<summary>
 Indicates the type is a tuple type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.typ.TType_app">
<summary>
 Indicates the type is a type application 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.typ.TType_forall">
<summary>
 Indicates the type is a universal type, only used for types of values, members and record fields 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.typ">
<summary>
 The algebra of types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValRef.nlr">
<summary>
 Indicates a reference to something bound in another CCU 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValRef.binding">
<summary>
 Indicates a reference to something bound in this CCU 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValRef">
<summary>
 References are either local or nonlocal
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceRef">
<summary>
 note: ModuleOrNamespaceRef and TyconRef are type equivalent 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityRef.nlr">
<summary>
 Indicates a reference to something bound in another CCU 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityRef.binding">
<summary>
 Indicates a reference to something bound in this CCU 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityRef.CanDeref">
<summary>
 Is the destination assembly available?
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.NonLocalEntityRef">
<summary>
 Index into the namespace/module structure of a particular CCU 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.CompilationPath">
<summary>
 The information ILXGEN needs about the location of an item
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.PublicPath">
<summary>
 A public path records where a construct lives within the global namespace
 of a CCU.
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.NonLocalValOrMemberRef.ItemKey">
<summary>
 The name of the value, or the full signature of the member
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.NonLocalValOrMemberRef.EnclosingEntity">
<summary>
 A reference to the entity containing the value or member. THis will always be a non-local reference
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValMemberInfo.IsImplemented">
<summary>
 Gets updated with &apos;true&apos; if an abstract slot is implemented in the file being typechecked.  Internal only. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValMemberInfo.ImplementedSlotSigs">
<summary>
 Gets updated with full slotsig after interface implementation relation is checked 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValMemberInfo.ApparentParent">
<summary>
 The parent type. For an extension member this is the type being extended 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValData.val_xmldocsig">
<summary>
 XML documentation signature for the value
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValData.val_xmldoc">
<summary>
 XML documentation attached to a value.
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValData.val_top_repr_info">
<summary>
 Top level values have an arity inferred and/or specified
 signatures.  The arity records the number of arguments preferred 
 in each position for a curried functions. The currying is based 
 on the number of lambdas, and in each position the elements are 
 based on attempting to deconstruct the type of the argument as a 
 tuple-type.  The field is mutable because arities for recursive 
 values are only inferred after the r.h.s. is analyzed, but the 
 value itself is created before the r.h.s. is analyzed. 

 TLR also sets this for inner bindings that it wants to 
 represent as &quot;top level&quot; bindings.
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValData.val_attribs">
<summary>
 Custom attributes attached to the value. These contain references to other values (i.e. constructors in types). Mutable to fixup  
 these value references after copying a colelction of values. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValData.val_member_info">
<summary>
 Is the value actually an instance method/property/event that augments 
 a type, and if so what name does it take in the IL?
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValData.val_access">
<summary>
 How visible is this? 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValData.val_defn">
<summary>
 What is the original, unoptimized, closed-term definition, if any? 
 Used to implement [&lt;ReflectedDefinition&gt;]
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValData.val_flags">
<summary>
 See vflags section further below for encoding/decodings here 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.XmlDocSig(System.String)">
<summary>
Get the signature for the value&apos;s XML documentation
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.XmlDocSig">
<summary>
Get the signature for the value&apos;s XML documentation
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.XmlDoc">
<summary>
 Get the declared documentation for the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.TypeScheme">
<summary>
 Get the type of the value including any generic type parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.Type">
<summary>
 The type of the value. 
 May be a Type_forall for a generic value. 
 May be a type variable or type containing type variables during type inference. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.Typars">
<summary>
 Get the generic type parameters for the value
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.TopValActualParent">
<summary>
 Get the actual parent entity for the value (a module or a type), i.e. the entity under which the
 value will appear in compiled code. For extension members this is the module where the extension member
 is declared.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.TauType">
<summary>
 Get the type of the value after removing any generic type parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.Stamp">
<summary>
 A unique stamp within the context of this invocation of the compiler process 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.RecursiveValInfo">
<summary>
 Get the information about the value used during type inference
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.Range">
<summary>
 The place where the value was defined. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.PublicPath">
<summary>
 Get the public path to the value, if any? Should be set if and only if
 IsMemberOrModuleBinding is set.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.PropertyName">
<summary>
   - If this is a property then this is &apos;Foo&apos; 
   - If this is an implementation of an abstract slot then this is the name of the property implemented by the abstract slot
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.PermitsExplicitTypeInstantiation">
<summary>
 Does the value allow the use of an explicit type instantiation (i.e. does it itself have explciti type arguments,
 or does it have a signature?)
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.MustInline">
<summary>
 Does the inline declaration for the value indicate that the value must be inlined?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.MemberInfo">
<summary>
 Is this a member, if so some more data about the member.

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.MemberApparentParent">
<summary>
 Get the apparent parent entity for a member
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.MakesNoCriticalTailcalls">
<summary>
 Was the value inferred to be a method or function that definitely makes no critical tailcalls?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.LogicalName">
<summary>
 The name of the method. 
   - If this is a property then this is &apos;get_Foo&apos; or &apos;set_Foo&apos;
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an extension member then this will be the simple name
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.LiteralValue">
<summary>
 The value of a value or member marked with [&lt;LiteralAttribute&gt;] 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsOverrideOrExplicitImpl">
<summary>
 Was this member declared &apos;override&apos; or is it an implementation of an interface slot
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsMutable">
<summary>
 Was the value declared &apos;mutable&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsModuleBinding">
<summary>
 Is this a value in a module, or an extension member, but excluding compiler generated bindings from optimizations
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsMemberOrModuleBinding">
<summary>
 Is this a member definition or module definition?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsMember">
<summary>
 Is this a member, if so some more data about the member.

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsIntrinsicMember">
<summary>
 Is this a member, excluding extension members
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsInstanceMember">
<summary>
 Is this an instance member. 

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsIncrClassGeneratedMember">
<summary>
 Is this a member generated from the de-sugaring of &apos;let&apos; function bindings in the implicit class syntax?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsIncrClassConstructor">
<summary>
 Is this a constructor member generated from the de-sugaring of implicit constructor for a class type?
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsConstructor">
<summary>
 Is this a &apos;new&apos; constructor member
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsCompilerGenerated">
<summary>
 Was the value generated by the compiler?

 Note: this is true for the overrides generated by hash/compare augmentations
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsCompiledIntoModule">
<summary>
 Is this something compiled into a module, i.e. a user-defined value, an extension member or a compiler-generated value
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsCompiledAsTopLevel">
<summary>
 Is this represented as a &quot;top level&quot; static binding (i.e. a static field, static member,
 instance member), rather than an &quot;inner&quot; binding that may result in a closure.

 This is implied by IsMemberOrModuleBinding, however not vice versa, for two reasons.
 Some optimizations mutate this value when they decide to change the representation of a 
 binding to be IsCompiledAsTopLevel. Second, even immediately after type checking we expect
 some non-module, non-member bindings to be marked IsCompiledAsTopLevel, e.g. &apos;y&apos; in 
 &apos;let x = let y = 1 in y + y&apos; (NOTE: check this, don&apos;t take it as gospel)
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsCompiledAsStaticPropertyWithoutField">
<summary>
 Was the value ever referenced?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.IsClassConstructor">
<summary>
 Is this a compiler-generated class constructor member
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.InlineInfo">
<summary>
 Get the inline declaration on the value
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.HasBeenReferenced">
<summary>
 Was the value ever referenced?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.DisplayName">
<summary>
   - If this is a property then this is &apos;Foo&apos; 
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an operator then this is &apos;(+)&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.DefinitionRange">
<summary>
 Range of the definition (implementation) of the value, used by Visual Studio 
 Updated by mutation when the implementation is matched against the signature. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.CoreDisplayName">
<summary>
 The name of the method. 
   - If this is a property then this is &apos;Foo&apos; 
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an operator then this is &apos;op_Addition&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.CompiledName">
<summary>
 The name of the method in compiled code (with some exceptions where ilxgen.fs decides not to use a method impl)
   - If this is a property then this is &apos;get_Foo&apos; or &apos;set_Foo&apos;
   - If this is an implementation of an abstract slot then this may be a mangled name
   - If this is an extension member then this will be a mangled name
   - If this is an operator then this is &apos;op_Addition&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.BaseOrThisInfo">
<summary>
 Is this a &apos;base&apos; or &apos;this&apos; value?
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.Attribs">
<summary>
 Get the declared attributes for the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.ApparentParent">
<summary>
 Get the apparent parent entity for the value, i.e. the entity under with which the
 value is associated. For extension members this is the nominal type the member extends.
 For other values it is just the actual parent.
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Val.ActualParent">
<summary>
 The parent type or module, if any (None for expression bindings and parameters)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TraitConstraintInfo.TTrait">
<summary>
 Indicates the signature of a member constraint. Contains a mutable solution cell
 to store the inferred solution of the constraint.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TraitConstraintInfo">
<summary>
 The specification of a member constraint that must be solved 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparIsUnmanaged">
<summary>
 Indicates a constraint that a type is .NET unmanaged type
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparIsDelegate">
<summary>
 Indicates a constraint that a type is a delegate from the given tuple of args to the given return type
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparSupportsEquality">
<summary>
 Indicates a constraint that a type does not have the Equality(false) attribute, or is not a structural type with this attribute, with special rules for some known structural container types
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparSupportsComparison">
<summary>
 Indicates a constraint that a type implements IComparable, with special rules for some known structural container types
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparIsEnum">
<summary>
 Indicates a constraint that a type is an enum with the given underlying 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparRequiresDefaultConstructor">
<summary>
 Indicates a constraint that a type has a parameterless constructor 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparSimpleChoice">
<summary>
 Indicates a constraint that a type is a simple choice between one of the given ground types. See format.fs 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparIsReferenceType">
<summary>
 Indicates a constraint that a type is a reference type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparIsNotNullableValueType">
<summary>
 Indicates a constraint that a type is a non-Nullable value type 
 These are part of .NET&apos;s model of generic constraints, and in order to 
 generate verifiable code we must attach them to F# generalzied type variables as well. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparMayResolveMemberConstraint">
<summary>
 Indicates a constraint that a type has a member with the given signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparSupportsNull">
<summary>
 Indicates a constraint that a type has a &apos;null&apos; value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparDefaultsToType">
<summary>
 Indicates a default value for an inference type variable should it be netiher generalized nor solved 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparConstraint.TTyparCoercesToType">
<summary>
 Indicates a constraint that a type is a subtype of the given type 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparData.typar_constraints">
<summary>
 The inferred constraints for the type inference variable 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparData.typar_solution">
<summary>
 An inferred equivalence for a type inference variable. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparData.typar_attribs">
<summary>
 The declared attributes of the type parameter. Empty for type inference variables. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparData.typar_xmldoc">
<summary>
 The documentation for the type parameter. Empty for type inference variables.
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparData.typar_stamp">
<summary>
 The unique stamp of the typar blob. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Accessibility.TAccess">
<summary>
 Indicates the construct can only be accessed from any code in the given type constructor, module or assembly. [] indicates global scope. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.entities@884">
<summary>
 Mutation used during compilation of FSharp.Core.dll
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.ModuleOrNamespaceKind">
<summary>
 Namespace or module-compiled-as-type? 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.AllValsAndMembers">
<summary>
 Values, including members in F# types in this module-or-namespace-fragment. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.AllEntities">
<summary>
 Type, mapping mangled name to Tycon, e.g. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceType.AddModuleOrNamespaceByMutation(Microsoft.FSharp.Metadata.Reader.Internal.Tast.Entity)">
<summary>
 Mutation used during compilation of FSharp.Core.dll
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceKind.Namespace">
<summary>
 Indicates that a &apos;module&apos; is really a namespace 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceKind.FSharpModule">
<summary>
 Indicates that a module is compiled to a class with the same name as the original module 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ModuleOrNamespaceKind.FSharpModuleWithSuffix">
<summary>
 Indicates that a module is compiled to a class with the &quot;Module&quot; suffix added. 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExceptionInfo.TExnNone">
<summary>
 Indicates that an exception is abstract, i.e. is in a signature file, and we do not know the representation 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExceptionInfo.TExnFresh">
<summary>
 Indicates that an exception carries the given record of values 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExceptionInfo.TExnAsmRepr">
<summary>
 Indicates that an exception is shorthand for the given .NET exception type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ExceptionInfo.TExnAbbrevRepr">
<summary>
 Indicates that an exception is an abbreviation for the given exception 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_id">
<summary>
 Name/declaration-location of the field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_fattribs">
<summary>
 Attributes attached to generated field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_pattribs">
<summary>
 Attributes attached to generated property 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_access">
<summary>
  Indicates the declared visibility of the field, not taking signatures into account 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_const">
<summary>
 The default initialization info, for static literals 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_secret">
<summary>
 Indicates a compiler generated field, not visible to Intellisense or name resolution 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_volatile">
<summary>
 Indicates a volatile field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_static">
<summary>
 Indicates a static field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_type">
<summary>
 The type of the field, w.r.t. the generic parameters of the enclosing type constructor 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_xmldocsig">
<summary>
 XML Documentation signature for the field
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_xmldoc">
<summary>
 Documentation for the field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField.rfield_mutable">
<summary>
 Is the field declared mutable in F#? 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.RecdField">
<summary>
 This may represent a &quot;field&quot; in either a struct, class, record or union
 It is normally compiled to a property.
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.UnionCase.ucase_attribs">
<summary>
 Attributes, attached to the generated static method to make instances of the case 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.UnionCase.ucase_access">
<summary>
  Indicates the declared visibility of the union constructor, not taking signatures into account 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.UnionCase.ucase_id">
<summary>
 Name/range of the case 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.UnionCase.ucase_xmldocsig">
<summary>
 XML documentation signature for the case
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.UnionCase.ucase_xmldoc">
<summary>
 Documentation for the case 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.UnionCase.ucase_il_name">
<summary>
 Name of the case in generated IL code 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.UnionCase.ucase_rty">
<summary>
 Return type constructed by the case. Normally exactly the type of the enclosing type, sometimes an abbreviation of it 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.UnionCase.ucase_rfields">
<summary>
 Data carried by the case. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconUnionData.funion_ucases">
<summary>
 The cases contained in the discriminated union. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconUnionData.UnionCasesAsList">
<summary>
 The ILX data structure representing the discriminated union. 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconUnionCases.ucases_by_name">
<summary>
 The cases of the discriminated union, indexed by name. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconUnionCases.ucases_by_index">
<summary>
 The cases of the discriminated union, in declaration order. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconRecdFields.rfields_by_name">
<summary>
 The fields of the record, indexed by name. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconRecdFields.rfields_by_index">
<summary>
 The fields of the record, in declaration order. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconObjModelData.fsobjmodel_rfields">
<summary>
 The fields of the class, struct or enum 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconObjModelData.fsobjmodel_vslots">
<summary>
 The declared abstract slots of the class, interface or struct 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconObjModelData.fsobjmodel_kind">
<summary>
 Indicates whether the type declaration is a class, interface, enum, delegate or struct 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconObjModelKind.TTyconEnum">
<summary>
 Indicates the type is an enumeration 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconObjModelKind.TTyconDelegate">
<summary>
 Indicates the type is a delegate with the given Invoke signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconObjModelKind.TTyconStruct">
<summary>
 Indicates the type is a struct 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconObjModelKind.TTyconInterface">
<summary>
 Indicates the type is an interface 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconObjModelKind.TTyconClass">
<summary>
 Indicates the type is a class (also used for units-of-measure)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconRepresentation.TMeasureableRepr">
<summary>
 Indicates the type is parameterized on a measure (e.g. float&lt;_&gt;) but erases to some other type (e.g. float)
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconRepresentation.TAsmRepr">
<summary>
 Indicates the type is implemented as IL assembly code using the given closed Abstract IL type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconRepresentation.TILObjModelRepr">
<summary>
 Indicates the type is a .NET type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconRepresentation.TFiniteUnionRepr">
<summary>
 Indicates the type is a discriminated union 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconRepresentation.TRecdRepr">
<summary>
 Indicates the type is a record 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconRepresentation.TFsObjModelRepr">
<summary>
 Indicates the type is a class, struct, enum, delegate or interface 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_abstract">
<summary>
 Set to true if the type is determined to be abstract 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_closed">
<summary>
 Set to true at the end of the scope where proper augmentations are allowed 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_super">
<summary>
 Super type, if any 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_interfaces">
<summary>
 Interface implementations - boolean indicates compiler-generated 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_adhoc">
<summary>
 Properties, methods etc. as lookup table
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_adhoc_list">
<summary>
 Properties, methods etc. in declaration order
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_hasObjectGetHashCode">
<summary>
 True if the type defined an Object.GetHashCode method. In this 
 case we give a warning if we auto-generate a hash method since the semantics may not match up
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_hash_and_equals_withc">
<summary>
 This is the value implementing the auto-generated comparison
 semantics if any. It is not present if the type defines its own implementation
 of IStructuralEquatable or if the type doesn&apos;t implement IComparable implicitly.
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_equals">
<summary>
 This is the value implementing the auto-generated equality 
 semantics if any. It is not present if the type defines its own implementation 
 of Object.Equals or if the type doesn&apos;t override Object.Equals implicitly. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_compare_withc">
<summary>
 This is the value implementing the auto-generated comparison
 semantics if any. It is not present if the type defines its own implementation
 of IStructuralComparable or if the type doesn&apos;t implement IComparable implicitly.
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyconAugmentation.tcaug_compare">
<summary>
 This is the value implementing the auto-generated comparison 
 semantics if any. It is not present if the type defines its own implementation 
 of IComparable or if the type doesn&apos;t implement IComparable implicitly. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_il_repr_cache">
<summary>
 Used during codegen to hold the ILX representation indicating how to access the type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_cpath">
<summary>
 The stable path to the type, e.g. Microsoft.FSharp.Core.FSharpFunc`2 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_pubpath">
<summary>
 The stable path to the type, e.g. Microsoft.FSharp.Core.FSharpFunc`2 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_xmldocsig">
<summary>
 The XML document signature for this entity
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_xmldoc">
<summary>
 The declared documentation for the type or module 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_modul_contents">
<summary>
 This field is used when the &apos;tycon&apos; is really a module definition. It holds statically nested type definitions and nested modules 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_exn_info">
<summary>
 Field used when the &apos;tycon&apos; is really an exception definition 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_tycon_tcaug">
<summary>
 The methods and properties of the type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_tycon_abbrev">
<summary>
 If non-None, indicates the type is an abbreviation for another type. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_tycon_repr">
<summary>
 The declared representation of the type, i.e. record, union, class etc. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_attribs">
<summary>
 The declared attributes for the type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_tycon_repr_accessibility">
<summary>
 The declared accessibility of the representation, not taking signatures into account 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_range">
<summary>
 The declaration location for the type constructor 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_compiled_name">
<summary>
 The name of the type, possibly with `n mangling 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_logical_name">
<summary>
 The name of the type, possibly with `n mangling 
</summary>
</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_stamp">
<summary>
 The unique stamp of the &quot;tycon blob&quot;. Note the same tycon in signature and implementation get different stamps 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityData.entity_typars">
<summary>
 The declared type parameters of the type  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Entity.MembersOfFSharpTyconSorted">
<summary>
 Note: result is alphabetically sorted, then for each name the results are in declaration order
</summary>
</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Entity.MembersOfFSharpTyconByName">
<summary>
 Note: result is a indexed table, and for each name the results are in reverse declaration order
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Entity.IsPrefixDisplay">
<summary>
 Indicates the type prefers the &quot;tycon&lt;a,b&gt;&quot; syntax for display etc. 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Entity.IsModuleOrNamespace">
<summary>
 Indicates the &quot;tycon blob&quot; is actually a module 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.Entity.CompiledRepresentation">
<summary>
 From TAST TyconRef to IL ILTypeRef
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityFlags">
<summary>
 Encode entity flags into a bit field. We leave lots of space to allow for future expansion.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata. We pickle this as int64 to allow for future expansion
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparFlags">
<summary>
 Encode typar flags into a bit field  
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparRigidity.TyparAnon">
<summary>
 Indicates the type parameter derives from an &apos;_&apos; anonymous type
 For units-of-measure, we give a warning if this gets solved to &apos;1&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparRigidity.TyparFlexible">
<summary>
 Indicates the type parameter is an inference variable may be solved
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparRigidity.TyparWarnIfNotRigid">
<summary>
 Indicates we give a warning if the type parameter is ever solved
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparRigidity.TyparWillBeRigid">
<summary>
 Indicates the type parameter can&apos;t be solved, but the variable is not set to &quot;rigid&quot; until after inference is complete
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparRigidity.TyparRigid">
<summary>
 Indicates the type parameter can&apos;t be solved
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValBaseOrThisInfo.MemberThisVal">
<summary>
 Indicates the &apos;this&apos; value specified in a memberm e.g. &apos;x&apos; in &apos;member x.M() = 1&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValBaseOrThisInfo.NormalVal">
<summary>
 Indicates a normal value
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValBaseOrThisInfo.BaseVal">
<summary>
 Indicates the value called &apos;base&apos; available for calling base class members
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValBaseOrThisInfo.CtorThisVal">
<summary>
 Indicates a ref-cell holding &apos;this&apos; or the implicit &apos;this&apos; used throughout an 
 implicit constructor to access and set values
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparDynamicReq.DynamicReq">
<summary>
 Indicates the type parameter is needed at runtime and may not be eliminated
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TyparDynamicReq.NoDynamicReq">
<summary>
 Indicates the type parameter is not needed at runtime and may be eliminated
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValRecursiveScopeInfo.ValNotInRecScope">
<summary>
 The normal value for this flag when the value is not within its recursive scope 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValRecursiveScopeInfo.ValInRecScope">
<summary>
 Set while the value is within its recursive scope. The flag indicates if the value has been eagerly generalized and accepts generic-recursive calls 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValInlineInfo.AlwaysInline">
<summary>
 Indictes the value is inlined but the code for the function still exists, e.g. to satisfy interfaces on objects, but that it is also always inlined 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ValInlineInfo.PseudoValue">
<summary>
 Indicates the value must always be inlined 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.uniq">
<summary>
 Unique name generator for stamps attached to lambdas and object expressions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.Tast.prim_entity_ref_eq(Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityRef,Microsoft.FSharp.Metadata.Reader.Internal.Tast.EntityRef)">
<summary>
 Primitive routine to compare two EntityRef&apos;s for equality
 This takes into account the possibility that they may have type forwarders
</summary>
</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.Tast.nleref_definitely_not_eq(Microsoft.FSharp.Metadata.Reader.Internal.Tast.NonLocalEntityRef,Microsoft.FSharp.Metadata.Reader.Internal.Tast.NonLocalEntityRef)">
<summary>
 This predicate tests if non-local resolution paths are definitely known to resolve
 to different entities. All references with different named paths always resolve to 
 different entities. Two references with the same named paths may resolve to the same 
 entities even if they reference through different CCUs, because one reference
 may be forwarded to another via a .NET TypeForwarder.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Metadata.Reader.Internal.Tast.ccu_eq(Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuThunk,Microsoft.FSharp.Metadata.Reader.Internal.Tast.CcuThunk)">
<summary>
 Equality on CCU references, implemented as reference equality except when unresolved
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Metadata.Reader.Internal.Tast.newStamp">
<summary>
 Unique name generator for stamps attached to to val_specs, tycon_specs etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast.TopValInfo">
<summary>
 Metadata on values (names of arguments etc. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tast">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Metadata.Reader.Internal.Tastops">

</member>
</members>
</doc>
